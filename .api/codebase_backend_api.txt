/* ==========================================================
   CODEBASE SNAPSHOT - 2025-06-02 09:59:23
   Project: microservice
   Files: 409 (409 text, 0 binary)
   Ignored Items: 94
   ========================================================== */

/* PROJECT STRUCTURE
   ------------------------------------------------------------
   .
   ├── .idea/
   │   ├── .gitignore
   │   ├── compiler.xml
   │   ├── encodings.xml
   │   ├── jarRepositories.xml
   │   ├── microservice.iml
   │   ├── misc.xml
   │   ├── modules.xml
   │   ├── vcs.xml
   │   └── workspace.xml
   ├── api-gateway/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           └── apigateway/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── AuthenticationFilter.java
   │   │   │   │               │   └── WebClientConfiguration.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── ApiResponse.java
   │   │   │   │               │   ├── IntrospectRequest.java
   │   │   │   │               │   └── IntrospectResponse.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   └── IdentityClient.java
   │   │   │   │               ├── service/
   │   │   │   │               │   └── IdentityService.java
   │   │   │   │               └── ApiGatewayApplication.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── apigateway/
   │   │                       └── ApiGatewayApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── blog-service/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           ├── blogService/
   │   │   │   │           │   ├── config/
   │   │   │   │           │   │   ├── AuthenticationRequestInterceptor.java
   │   │   │   │           │   │   ├── CustomJwtDecoder.java
   │   │   │   │           │   │   ├── FeignMultipartSupportConfig.java
   │   │   │   │           │   │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │           │   │   └── SecurityConfig.java
   │   │   │   │           │   ├── controller/
   │   │   │   │           │   │   ├── BlogController.java
   │   │   │   │           │   │   └── CategoryController.java
   │   │   │   │           │   ├── converter/
   │   │   │   │           │   │   └── StringConverter.java
   │   │   │   │           │   ├── dto/
   │   │   │   │           │   │   ├── request/
   │   │   │   │           │   │   │   ├── BlogfilterRequest.java
   │   │   │   │           │   │   │   ├── BlogRequest.java
   │   │   │   │           │   │   │   └── CategoryRequest.java
   │   │   │   │           │   │   └── response/
   │   │   │   │           │   │       ├── ApiResponse.java
   │   │   │   │           │   │       ├── BlogResponse.java
   │   │   │   │           │   │       ├── CategoryResponse.java
   │   │   │   │           │   │       ├── ErrorsResponse.java
   │   │   │   │           │   │       ├── FileResponse.java
   │   │   │   │           │   │       ├── PageResponse.java
   │   │   │   │           │   │       └── PageResult.java
   │   │   │   │           │   ├── entity/
   │   │   │   │           │   │   ├── Blog.java
   │   │   │   │           │   │   └── Category.java
   │   │   │   │           │   ├── exception/
   │   │   │   │           │   │   ├── AppException.java
   │   │   │   │           │   │   └── GlobalExceptionHandler.java
   │   │   │   │           │   ├── mapper/
   │   │   │   │           │   │   ├── BlogMapper.java
   │   │   │   │           │   │   └── CategoryMapper.java
   │   │   │   │           │   ├── repository/
   │   │   │   │           │   │   ├── BlogRepository.java
   │   │   │   │           │   │   ├── CategoryRepository.java
   │   │   │   │           │   │   └── FileServiceClientRepository.java
   │   │   │   │           │   ├── service/
   │   │   │   │           │   │   ├── event/
   │   │   │   │           │   │   │   └── CategoryEventConsumer.java
   │   │   │   │           │   │   ├── impl/
   │   │   │   │           │   │   │   ├── BlogServiceImpl.java
   │   │   │   │           │   │   │   ├── CategoryServiceImpl.java
   │   │   │   │           │   │   │   ├── FileUploadServiceimpl.java
   │   │   │   │           │   │   │   └── SlugServiceImpl.java
   │   │   │   │           │   │   ├── BlogService.java
   │   │   │   │           │   │   ├── CategoryService.java
   │   │   │   │           │   │   ├── FileUploadService.java
   │   │   │   │           │   │   └── SlugService.java
   │   │   │   │           │   └── BlogServiceApplication.java
   │   │   │   │           └── event/
   │   │   │   │               └── dto/
   │   │   │   │                   └── CategoryEvent.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── blogService/
   │   │                       └── BlogServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── cart-service/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           └── cartservice/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── CustomJwtDecoder.java
   │   │   │   │               │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │               │   └── SecurityConfig.java
   │   │   │   │               ├── controller/
   │   │   │   │               │   ├── CartProductController.java
   │   │   │   │               │   └── InternalCartController.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── ApiResponse.java
   │   │   │   │               │   ├── CartCreateRequest.java
   │   │   │   │               │   ├── CartProductRequest.java
   │   │   │   │               │   ├── CartProductResponse.java
   │   │   │   │               │   ├── CartResponse.java
   │   │   │   │               │   └── ErrorsResponse.java
   │   │   │   │               ├── entity/
   │   │   │   │               │   ├── Cart.java
   │   │   │   │               │   ├── CartProduct.java
   │   │   │   │               │   └── Product.java
   │   │   │   │               ├── exception/
   │   │   │   │               │   ├── AppException.java
   │   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │   │               ├── mapper/
   │   │   │   │               │   ├── CartMapper.java
   │   │   │   │               │   └── CartProductMapper.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   ├── CartProductRepository.java
   │   │   │   │               │   └── CartRepository.java
   │   │   │   │               ├── service/
   │   │   │   │               │   ├── CartProductService.java
   │   │   │   │               │   ├── CartService.java
   │   │   │   │               │   └── ProductService.java
   │   │   │   │               └── CartServiceApplication.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── cartservice/
   │   │                       └── CartServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── category-service/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           ├── categoryservice/
   │   │   │   │           │   ├── config/
   │   │   │   │           │   │   ├── AuthenticationRequestInterceptor.java
   │   │   │   │           │   │   ├── CustomJwtDecoder.java
   │   │   │   │           │   │   ├── FeignMultipartSupportConfig.java
   │   │   │   │           │   │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │           │   │   └── SecurityConfig.java
   │   │   │   │           │   ├── controller/
   │   │   │   │           │   │   └── CategoryController.java
   │   │   │   │           │   ├── converter/
   │   │   │   │           │   │   └── StringConverter.java
   │   │   │   │           │   ├── dto/
   │   │   │   │           │   │   ├── request/
   │   │   │   │           │   │   │   └── CategoryRequest.java
   │   │   │   │           │   │   └── response/
   │   │   │   │           │   │       ├── ApiResponse.java
   │   │   │   │           │   │       ├── CategoryResponse.java
   │   │   │   │           │   │       ├── CategoryTreeResponse.java
   │   │   │   │           │   │       └── ErrorsResponse.java
   │   │   │   │           │   ├── entity/
   │   │   │   │           │   │   └── Category.java
   │   │   │   │           │   ├── enums/
   │   │   │   │           │   │   └── CategoryType.java
   │   │   │   │           │   ├── exception/
   │   │   │   │           │   │   ├── AppException.java
   │   │   │   │           │   │   └── GlobalExceptionHandler.java
   │   │   │   │           │   ├── mapper/
   │   │   │   │           │   │   └── CategoryMapper.java
   │   │   │   │           │   ├── repository/
   │   │   │   │           │   │   └── CategoryRepository.java
   │   │   │   │           │   ├── service/
   │   │   │   │           │   │   ├── eventProducer/
   │   │   │   │           │   │   │   └── CategoryEventProducer.java
   │   │   │   │           │   │   ├── helper/
   │   │   │   │           │   │   │   └── CategoryHelper.java
   │   │   │   │           │   │   ├── impl/
   │   │   │   │           │   │   │   ├── CategoryServiceImpl.java
   │   │   │   │           │   │   │   └── SlugServiceImpl.java
   │   │   │   │           │   │   ├── CategoryService.java
   │   │   │   │           │   │   └── SlugService.java
   │   │   │   │           │   └── CategoryServiceApplication.java
   │   │   │   │           └── event/
   │   │   │   │               └── dto/
   │   │   │   │                   └── CategoryEvent.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── categoryservice/
   │   │                       └── CategoryServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── customer-service/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           └── customerService/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── AuthenticationRequestInterceptor.java
   │   │   │   │               │   ├── CustomJwtDecoder.java
   │   │   │   │               │   ├── FeignMultipartSupportConfig.java
   │   │   │   │               │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │               │   └── SecurityConfig.java
   │   │   │   │               ├── controller/
   │   │   │   │               │   └── CustomerCareController.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── request/
   │   │   │   │               │   │   └── CustomerCareRequest.java
   │   │   │   │               │   └── response/
   │   │   │   │               │       ├── ApiResponse.java
   │   │   │   │               │       ├── CustomerCareResponse.java
   │   │   │   │               │       ├── ErrorsResponse.java
   │   │   │   │               │       ├── PageResponse.java
   │   │   │   │               │       └── PageResult.java
   │   │   │   │               ├── entity/
   │   │   │   │               │   ├── CustomerCare.java
   │   │   │   │               │   └── HomePage.java
   │   │   │   │               ├── exception/
   │   │   │   │               │   ├── AppException.java
   │   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │   │               ├── mapper/
   │   │   │   │               │   └── CustomerCareMapper.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   ├── CustomerCareRepository.java
   │   │   │   │               │   └── HomePageRepository.java
   │   │   │   │               ├── service/
   │   │   │   │               │   └── CustomerCareService.java
   │   │   │   │               └── CustomerServiceApplication.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── customerService/
   │   │                       └── CustomerServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   └── pom.xml
   ├── file-service/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           └── fileservice/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── CustomJwtDecoder.java
   │   │   │   │               │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │               │   └── SecurityConfig.java
   │   │   │   │               ├── controller/
   │   │   │   │               │   └── FileController.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── ApiResponse.java
   │   │   │   │               │   ├── ErrorsResponse.java
   │   │   │   │               │   ├── FileData.java
   │   │   │   │               │   ├── FileInfo.java
   │   │   │   │               │   ├── FileResponse.java
   │   │   │   │               │   └── PageResponse.java
   │   │   │   │               ├── entity/
   │   │   │   │               │   └── FileManagement.java
   │   │   │   │               ├── exception/
   │   │   │   │               │   ├── AppException.java
   │   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │   │               ├── mapper/
   │   │   │   │               │   └── FileManagementMapper.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   ├── FileManagementRepository.java
   │   │   │   │               │   └── FileRepository.java
   │   │   │   │               ├── service/
   │   │   │   │               │   └── FileService.java
   │   │   │   │               └── FileServiceApplication.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── fileservice/
   │   │                       └── FileServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── identity-service/
   │   ├── .codebase/
   │   ├── .mvn/
   │   ├── public/
   │   │   ├── permissions.sql
   │   │   ├── roles.sql
   │   │   ├── roles_permissions.sql
   │   │   ├── users.sql
   │   │   └── users_roles.sql
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           ├── event/
   │   │   │   │           │   └── dto/
   │   │   │   │           │       ├── NotificationEvent.java
   │   │   │   │           │       └── UserCreateEvent.java
   │   │   │   │           └── identity_service/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── ApplicationInitConfig.java
   │   │   │   │               │   ├── AuthenticationRequestInterceptor.java
   │   │   │   │               │   ├── CustomJwtDecoder.java
   │   │   │   │               │   ├── FeignMultipartSupportConfig.java
   │   │   │   │               │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │               │   └── SecurityConfig.java
   │   │   │   │               ├── controller/
   │   │   │   │               │   ├── AuthenticationController.java
   │   │   │   │               │   ├── PermissionController.java
   │   │   │   │               │   ├── RoleController.java
   │   │   │   │               │   └── UserController.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── request/
   │   │   │   │               │   │   ├── AuthenticationRequest.java
   │   │   │   │               │   │   ├── CartCreateRequest.java
   │   │   │   │               │   │   ├── ChangePasswordRequest.java
   │   │   │   │               │   │   ├── ForgotPasswordRequest.java
   │   │   │   │               │   │   ├── IntrospectRequest.java
   │   │   │   │               │   │   ├── LogoutRequest.java
   │   │   │   │               │   │   ├── PermissionCreationRequest.java
   │   │   │   │               │   │   ├── RefreshTokenRequest.java
   │   │   │   │               │   │   ├── ResetPasswordWithTokenRequest.java
   │   │   │   │               │   │   ├── RoleCreationRequest.java
   │   │   │   │               │   │   ├── UserCreateRequest.java
   │   │   │   │               │   │   ├── UserUpdateImageRequest.java
   │   │   │   │               │   │   ├── UserUpdateInfoRequest.java
   │   │   │   │               │   │   ├── UserUpdateRequest.java
   │   │   │   │               │   │   └── VerifyOtpRequest.java
   │   │   │   │               │   └── response/
   │   │   │   │               │       ├── ApiResponse.java
   │   │   │   │               │       ├── AuthenticationResponse.java
   │   │   │   │               │       ├── CartResponse.java
   │   │   │   │               │       ├── ErrorsResponse.java
   │   │   │   │               │       ├── FileResponse.java
   │   │   │   │               │       ├── IntrospectResponse.java
   │   │   │   │               │       ├── PageResponse.java
   │   │   │   │               │       ├── PermissionResponse.java
   │   │   │   │               │       ├── RoleResponse.java
   │   │   │   │               │       ├── UserResponse.java
   │   │   │   │               │       └── VerifyOtpResponse.java
   │   │   │   │               ├── entity/
   │   │   │   │               │   ├── InvalidatedToken.java
   │   │   │   │               │   ├── Permission.java
   │   │   │   │               │   ├── Role.java
   │   │   │   │               │   └── User.java
   │   │   │   │               ├── exception/
   │   │   │   │               │   ├── AppException.java
   │   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │   │               ├── mapper/
   │   │   │   │               │   ├── PermissionMapper.java
   │   │   │   │               │   ├── RoleMapper.java
   │   │   │   │               │   └── UserMapper.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   ├── CartServiceClient.java
   │   │   │   │               │   ├── FileServiceClient.java
   │   │   │   │               │   ├── InvalidatedTokenRepository.java
   │   │   │   │               │   ├── PermissionRepository.java
   │   │   │   │               │   ├── RoleRepository.java
   │   │   │   │               │   └── UserRepository.java
   │   │   │   │               ├── service/
   │   │   │   │               │   ├── AuthenticationService.java
   │   │   │   │               │   ├── ForgotPasswordService.java
   │   │   │   │               │   ├── PermissionService.java
   │   │   │   │               │   ├── RoleService.java
   │   │   │   │               │   ├── TokenService.java
   │   │   │   │               │   └── UserService.java
   │   │   │   │               └── IdentityServiceApplication.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── identity_service/
   │   │                       ├── GenerateKey.java
   │   │                       ├── IdentityServiceApplicationTests.java
   │   │                       └── JwtValidator.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── doc.txt
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── notification-service/
   │   ├── .codebase/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           ├── event/
   │   │   │   │           │   └── dto/
   │   │   │   │           │       └── NotificationEvent.java
   │   │   │   │           └── notificationservice/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── CustomJwtDecoder.java
   │   │   │   │               │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │               │   └── SecurityConfig.java
   │   │   │   │               ├── controller/
   │   │   │   │               │   ├── EmailController.java
   │   │   │   │               │   ├── FcmTokenController.java
   │   │   │   │               │   ├── NotificationController.java
   │   │   │   │               │   └── NotificationFirebaseController.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── ApiResponse.java
   │   │   │   │               │   ├── EmailRequest.java
   │   │   │   │               │   ├── EmailResponse.java
   │   │   │   │               │   ├── ErrorsResponse.java
   │   │   │   │               │   ├── FcmTokenCreateRequest.java
   │   │   │   │               │   ├── FcmTokenResponse.java
   │   │   │   │               │   ├── NotificationRequest.java
   │   │   │   │               │   ├── NotificationResponse.java
   │   │   │   │               │   ├── Recipient.java
   │   │   │   │               │   ├── SendEmailRequest.java
   │   │   │   │               │   └── Sender.java
   │   │   │   │               ├── entity/
   │   │   │   │               │   ├── FcmToken.java
   │   │   │   │               │   └── Notification.java
   │   │   │   │               ├── exception/
   │   │   │   │               │   ├── AppException.java
   │   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │   │               ├── mapper/
   │   │   │   │               │   └── NotificationMapper.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   ├── EmailClient.java
   │   │   │   │               │   ├── FcmTokenRepository.java
   │   │   │   │               │   └── NotificationRepository.java
   │   │   │   │               ├── service/
   │   │   │   │               │   ├── EmailService.java
   │   │   │   │               │   ├── FCMInitializer.java
   │   │   │   │               │   ├── FCMService.java
   │   │   │   │               │   ├── FcmTokenService.java
   │   │   │   │               │   ├── NotificationProcessingService.java
   │   │   │   │               │   └── NotificationService.java
   │   │   │   │               └── NotificationServiceApplication.java
   │   │   │   └── resources/
   │   │   │       ├── templates/
   │   │   │       │   ├── order-created-email-template.html
   │   │   │       │   └── otp-email-template.html
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── notificationservice/
   │   │                       └── NotificationServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── order-service/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           ├── event/
   │   │   │   │           │   └── dto/
   │   │   │   │           │       ├── NotificationEvent.java
   │   │   │   │           │       ├── OrderCreateEvent.java
   │   │   │   │           │       ├── PaymentCreateEvent.java
   │   │   │   │           │       ├── ProductEvent.java
   │   │   │   │           │       ├── ProfileCreateEvent.java
   │   │   │   │           │       └── UserCreateEvent.java
   │   │   │   │           └── orderservice/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── CustomJwtDecoder.java
   │   │   │   │               │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │               │   └── SecurityConfig.java
   │   │   │   │               ├── controller/
   │   │   │   │               │   ├── OrderController.java
   │   │   │   │               │   ├── PaymentController.java
   │   │   │   │               │   ├── ProductController.java
   │   │   │   │               │   ├── ProfileController.java
   │   │   │   │               │   └── UserController.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── ApiResponse.java
   │   │   │   │               │   ├── CancerOrderRequest.java
   │   │   │   │               │   ├── ErrorsResponse.java
   │   │   │   │               │   ├── OrderCreateRequest.java
   │   │   │   │               │   ├── OrderProductCreateRequest.java
   │   │   │   │               │   ├── OrderProductResponse.java
   │   │   │   │               │   ├── OrderResponse.java
   │   │   │   │               │   ├── OrderUpdateStatus.java
   │   │   │   │               │   └── PageResponse.java
   │   │   │   │               ├── entity/
   │   │   │   │               │   ├── Order.java
   │   │   │   │               │   ├── OrderProduct.java
   │   │   │   │               │   ├── Product.java
   │   │   │   │               │   ├── Profile.java
   │   │   │   │               │   └── User.java
   │   │   │   │               ├── exception/
   │   │   │   │               │   ├── AppException.java
   │   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │   │               ├── mapper/
   │   │   │   │               │   └── OrderMapper.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   ├── OrderProductRepository.java
   │   │   │   │               │   ├── OrderRepository.java
   │   │   │   │               │   ├── ProductRepository.java
   │   │   │   │               │   ├── ProfileRepository.java
   │   │   │   │               │   └── UserRepository.java
   │   │   │   │               ├── service/
   │   │   │   │               │   ├── OrderService.java
   │   │   │   │               │   ├── ProductService.java
   │   │   │   │               │   └── ProfileService.java
   │   │   │   │               └── OrderServiceApplication.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── orderservice/
   │   │                       └── OrderServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── doc.txt
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── payment-service/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           ├── event/
   │   │   │   │           │   └── dto/
   │   │   │   │           │       ├── OrderCreateEvent.java
   │   │   │   │           │       └── PaymentCreateEvent.java
   │   │   │   │           └── paymentservice/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── CustomJwtDecoder.java
   │   │   │   │               │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │               │   └── SecurityConfig.java
   │   │   │   │               ├── controller/
   │   │   │   │               │   ├── OrderController.java
   │   │   │   │               │   └── PaymentController.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── ApiResponse.java
   │   │   │   │               │   ├── CreateMomoRequest.java
   │   │   │   │               │   ├── ErrorsResponse.java
   │   │   │   │               │   ├── MomoResponse.java
   │   │   │   │               │   └── PageResponse.java
   │   │   │   │               ├── entity/
   │   │   │   │               │   ├── Order.java
   │   │   │   │               │   └── Payment.java
   │   │   │   │               ├── exception/
   │   │   │   │               │   ├── AppException.java
   │   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   ├── MomoClientApi.java
   │   │   │   │               │   ├── OrderRepository.java
   │   │   │   │               │   └── PaymentRepository.java
   │   │   │   │               ├── service/
   │   │   │   │               │   ├── OrderService.java
   │   │   │   │               │   └── PaymentService.java
   │   │   │   │               └── PaymentServiceApplication.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── paymentservice/
   │   │                       └── PaymentServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── product-service/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           ├── event/
   │   │   │   │           │   └── dto/
   │   │   │   │           │       ├── CategoryEvent.java
   │   │   │   │           │       ├── NotificationEvent.java
   │   │   │   │           │       ├── ProductEvent.java
   │   │   │   │           │       └── UserCreateEvent.java
   │   │   │   │           └── product_service/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── AuthenticationRequestInterceptor.java
   │   │   │   │               │   ├── CustomJwtDecoder.java
   │   │   │   │               │   ├── FeignMultipartSupportConfig.java
   │   │   │   │               │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │               │   └── SecurityConfig.java
   │   │   │   │               ├── controller/
   │   │   │   │               │   ├── CategoryController.java
   │   │   │   │               │   ├── ProductController.java
   │   │   │   │               │   └── RateController.java
   │   │   │   │               ├── converter/
   │   │   │   │               │   └── StringConverter.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── request/
   │   │   │   │               │   │   ├── CategoryRequest.java
   │   │   │   │               │   │   ├── ProductFilter.java
   │   │   │   │               │   │   ├── ProductImageRequest.java
   │   │   │   │               │   │   ├── ProductRequest.java
   │   │   │   │               │   │   └── RateRequest.java
   │   │   │   │               │   └── response/
   │   │   │   │               │       ├── ApiResponse.java
   │   │   │   │               │       ├── CategoryResponse.java
   │   │   │   │               │       ├── ErrorsResponse.java
   │   │   │   │               │       ├── FileResponse.java
   │   │   │   │               │       ├── PageResponse.java
   │   │   │   │               │       ├── ProductImageResponse.java
   │   │   │   │               │       ├── ProductResponse.java
   │   │   │   │               │       └── RateResponse.java
   │   │   │   │               ├── entity/
   │   │   │   │               │   ├── Category.java
   │   │   │   │               │   ├── Product.java
   │   │   │   │               │   ├── ProductImage.java
   │   │   │   │               │   ├── Rate.java
   │   │   │   │               │   └── User.java
   │   │   │   │               ├── exception/
   │   │   │   │               │   ├── AppException.java
   │   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │   │               ├── mapper/
   │   │   │   │               │   ├── CategoryMapper.java
   │   │   │   │               │   ├── ProductMapper.java
   │   │   │   │               │   └── RateMapper.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   ├── CategoryRepository.java
   │   │   │   │               │   ├── FileServiceClientRepository.java
   │   │   │   │               │   ├── ProductImageRepository.java
   │   │   │   │               │   ├── ProductRepository.java
   │   │   │   │               │   ├── RateRepository.java
   │   │   │   │               │   └── UserRepository.java
   │   │   │   │               ├── service/
   │   │   │   │               │   ├── event/
   │   │   │   │               │   │   ├── CategoryEventConsumer.java
   │   │   │   │               │   │   └── UserEventConsumer.java
   │   │   │   │               │   ├── CategoryService.java
   │   │   │   │               │   ├── FileUploadService.java
   │   │   │   │               │   ├── ProductImageService.java
   │   │   │   │               │   ├── ProductService.java
   │   │   │   │               │   ├── RateService.java
   │   │   │   │               │   └── SlugService.java
   │   │   │   │               └── ProductServiceApplication.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── product_service/
   │   │                       └── ProductServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── doc.txt
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   ├── profile-service/
   │   ├── .mvn/
   │   ├── src/
   │   │   ├── main/
   │   │   │   ├── java/
   │   │   │   │   └── com/
   │   │   │   │       └── hau/
   │   │   │   │           ├── event/
   │   │   │   │           │   └── dto/
   │   │   │   │           │       └── ProfileCreateEvent.java
   │   │   │   │           └── profile_service/
   │   │   │   │               ├── config/
   │   │   │   │               │   ├── CustomJwtDecoder.java
   │   │   │   │               │   ├── JwtAuthenticationEntryPoint.java
   │   │   │   │               │   └── SecurityConfig.java
   │   │   │   │               ├── controller/
   │   │   │   │               │   └── ProfileController.java
   │   │   │   │               ├── dto/
   │   │   │   │               │   ├── ApiResponse.java
   │   │   │   │               │   ├── CustomUserDetails.java
   │   │   │   │               │   ├── ErrorsResponse.java
   │   │   │   │               │   ├── PageResponse.java
   │   │   │   │               │   ├── ProfileCreateRequest.java
   │   │   │   │               │   ├── ProfileResponse.java
   │   │   │   │               │   └── ProfileUpdateRequest.java
   │   │   │   │               ├── entity/
   │   │   │   │               │   └── Profile.java
   │   │   │   │               ├── exception/
   │   │   │   │               │   ├── AppException.java
   │   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │   │               ├── mapper/
   │   │   │   │               │   └── ProfileMapper.java
   │   │   │   │               ├── repository/
   │   │   │   │               │   └── ProfileRepository.java
   │   │   │   │               ├── service/
   │   │   │   │               │   └── ProfileService.java
   │   │   │   │               └── ProfileServiceApplication.java
   │   │   │   └── resources/
   │   │   │       ├── application-sample.yml
   │   │   │       └── application.yml
   │   │   └── test/
   │   │       └── java/
   │   │           └── com/
   │   │               └── hau/
   │   │                   └── profile_service/
   │   │                       └── ProfileServiceApplicationTests.java
   │   ├── target/
   │   ├── .gitattributes
   │   ├── .gitignore
   │   ├── mvnw
   │   ├── mvnw.cmd
   │   └── pom.xml
   └── .gitignore
   ------------------------------------------------------------ */

/* ===== api-gateway\src\main\java\com\hau\apigateway\ApiGatewayApplication.java ===== */
package com.hau.apigateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ApiGatewayApplication {

    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }

}


/* ===== api-gateway\src\main\java\com\hau\apigateway\config\AuthenticationFilter.java ===== */
package com.hau.apigateway.config;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.hau.apigateway.dto.ApiResponse;
import com.hau.apigateway.service.IdentityService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.experimental.NonFinal;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod; // Thêm import
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map; // Sử dụng Map để lưu trữ đường dẫn theo HttpMethod

@Component
@Slf4j
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class AuthenticationFilter implements GlobalFilter, Ordered {

    IdentityService identityService;
    ObjectMapper objectMapper;

    @NonFinal
    Map<HttpMethod, List<String>> publicEndpointsByMethod = Map.of(
            HttpMethod.POST, List.of(
                    "/identity/users/register",
                    "/identity/auth/.*",
                    "/payment/vnpay_return",
                    "/payment/momo_return",
                    "/customer/.*"
            ),
            HttpMethod.GET, List.of(
                    "/file/media/download/.*",
                    "/blog/.*",
                    "/category/.*",
                    "/product/.*"
            )
    );

    @NonFinal
    @Value("${app.api-prefix}")
    String apiPrefix;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("Enter authentication filter....");

        if (isPublicEndpoint(exchange.getRequest())) {
            return chain.filter(exchange);
        }

        List<String> authHeader = exchange.getRequest().getHeaders().get(HttpHeaders.AUTHORIZATION);
        if (CollectionUtils.isEmpty(authHeader)) {
            return unauthenticated(exchange.getResponse());
        }

        String token = authHeader.getFirst().replace("Bearer ", "");
        log.info("Token: {}", token);

        return identityService.introspect(token).flatMap(introspectResponse -> {
            if (introspectResponse.getResult().isValid()) {
                return chain.filter(exchange);
            } else {
                return unauthenticated(exchange.getResponse());
            }
        }).onErrorResume(throwable -> unauthenticated(exchange.getResponse()));
    }

    @Override
    public int getOrder() {
        return -1;
    }

    boolean isPublicEndpoint(ServerHttpRequest request) {
        HttpMethod method = request.getMethod();
        String path = request.getURI().getPath();

        List<String> publicPathsForMethod = publicEndpointsByMethod.get(method);
        if (publicPathsForMethod == null) {
            return false;
        }

        return publicPathsForMethod.stream()
                .anyMatch(pattern -> path.matches(apiPrefix + pattern));
    }

    Mono<Void> unauthenticated(ServerHttpResponse response) {
        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();

        String body;
        try {
            body = objectMapper.writeValueAsString(apiResponse);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }

        response.setStatusCode(HttpStatus.UNAUTHORIZED);
        response.getHeaders().add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);

        return response.writeWith(
                Mono.just(response.bufferFactory().wrap(body.getBytes())));
    }
}

/* ===== api-gateway\src\main\java\com\hau\apigateway\config\WebClientConfiguration.java ===== */
package com.hau.apigateway.config;

import com.hau.apigateway.repository.IdentityClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.support.WebClientAdapter;
import org.springframework.web.service.invoker.HttpServiceProxyFactory;

import java.util.List;

@Configuration
public class WebClientConfiguration {
    @Value("${app.identity-service.url}")
    private String identityServiceUrl;

    @Bean
    WebClient webClient() {
        return WebClient.builder()
                .baseUrl(identityServiceUrl)
                .build();
    }

    @Bean
    CorsWebFilter corsWebFilter() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.setAllowedOrigins(List.of("*"));
        corsConfiguration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        corsConfiguration.setAllowedHeaders(List.of("*"));

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfiguration);

        return new CorsWebFilter(source);
    }

    @Bean
    IdentityClient identityClient(WebClient webClient) {
        HttpServiceProxyFactory httpServiceProxyFactory = HttpServiceProxyFactory
                .builderFor(WebClientAdapter.create(webClient)).build();

        return httpServiceProxyFactory.createClient(IdentityClient.class);
    }
}


/* ===== api-gateway\src\main\java\com\hau\apigateway\dto\ApiResponse.java ===== */
package com.hau.apigateway.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== api-gateway\src\main\java\com\hau\apigateway\dto\IntrospectRequest.java ===== */
package com.hau.apigateway.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IntrospectRequest {
    private String token;
}


/* ===== api-gateway\src\main\java\com\hau\apigateway\dto\IntrospectResponse.java ===== */
package com.hau.apigateway.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IntrospectResponse {
    private boolean valid;
    private String username;
}


/* ===== api-gateway\src\main\java\com\hau\apigateway\repository\IdentityClient.java ===== */
package com.hau.apigateway.repository;

import com.hau.apigateway.dto.ApiResponse;
import com.hau.apigateway.dto.IntrospectRequest;
import com.hau.apigateway.dto.IntrospectResponse;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.service.annotation.PostExchange;
import reactor.core.publisher.Mono;

public interface IdentityClient {
    @PostExchange(url = "/auth/introspect", contentType = MediaType.APPLICATION_JSON_VALUE)
    Mono<ApiResponse<IntrospectResponse>> introspect(@RequestBody IntrospectRequest request);
}

/* ===== api-gateway\src\main\java\com\hau\apigateway\service\IdentityService.java ===== */
package com.hau.apigateway.service;

import com.hau.apigateway.dto.ApiResponse;
import com.hau.apigateway.dto.IntrospectRequest;
import com.hau.apigateway.dto.IntrospectResponse;
import com.hau.apigateway.repository.IdentityClient;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

@Service
@RequiredArgsConstructor
public class IdentityService {

    private final IdentityClient identityClient;

    public Mono<ApiResponse<IntrospectResponse>> introspect(String token){
        return identityClient.introspect(IntrospectRequest.builder()
                .token(token)
                .build());
    }
}

/* ===== api-gateway\src\main\resources\application-sample.yml ===== */
server:
  port: 8086
  servlet:
    context-path: /customer

spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:postgresql://localhost:5432/customer_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect


/* ===== api-gateway\src\main\resources\application.yml ===== */
server:
  port: 8888

app:
  api-prefix: /api/v1
  identity-service:
    url: http://localhost:8080/identity

spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        - id: identity_service
          uri: http://localhost:8080
          predicates:
            - Path=${app.api-prefix}/identity/**
          filters:
            - StripPrefix=2
        - id: profile_service
          uri: http://localhost:8081
          predicates:
            - Path=${app.api-prefix}/profile/**
          filters:
            - StripPrefix=2
        - id: product_service
          uri: http://localhost:8082
          predicates:
            - Path=${app.api-prefix}/product/**
          filters:
            - StripPrefix=2
        - id: cart_service
          uri: http://localhost:8083
          predicates:
            - Path=${app.api-prefix}/cart/**
          filters:
            - StripPrefix=2
        - id: category_service
          uri: http://localhost:8084
          predicates:
            - Path=${app.api-prefix}/category/**
          filters:
            - StripPrefix=2
        - id: blog_service
          uri: http://localhost:8085
          predicates:
            - Path=${app.api-prefix}/blog/**
          filters:
            - StripPrefix=2
        - id: customer_service
          uri: http://localhost:8086
          predicates:
            - Path=${app.api-prefix}/customer/**
          filters:
            - StripPrefix=2
        - id: file_service
          uri: http://localhost:8087
          predicates:
            - Path=${app.api-prefix}/file/**
          filters:
            - StripPrefix=2
        - id: category_service
          uri: http://localhost:8088
          predicates:
            - Path=${app.api-prefix}/notification/**
          filters:
            - StripPrefix=2
        - id: payment_service
          uri: http://localhost:8089
          predicates:
            - Path=${app.api-prefix}/payment/**
          filters:
            - StripPrefix=2
        - id: order_service
          uri: http://localhost:8090
          predicates:
            - Path=${app.api-prefix}/order/**
          filters:
            - StripPrefix=2

/* ===== api-gateway\src\test\java\com\hau\apigateway\ApiGatewayApplicationTests.java ===== */
package com.hau.apigateway;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApiGatewayApplicationTests {

    @Test
    void contextLoads() {
    }

}


/* ===== blog-service\src\main\java\com\hau\blogService\BlogServiceApplication.java ===== */
package com.hau.blogService;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class BlogServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(BlogServiceApplication.class, args);
	}

}


/* ===== blog-service\src\main\java\com\hau\blogService\config\AuthenticationRequestInterceptor.java ===== */
package com.hau.blogService.config;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
public class AuthenticationRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes servletRequestAttributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

        assert servletRequestAttributes != null;
        var authHeader = servletRequestAttributes.getRequest().getHeader("Authorization");
        log.info("Auth header: {}", authHeader);
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            requestTemplate.header("Authorization", authHeader);
        } else {
            log.warn("No Authorization header found in the request");
        }
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\config\CustomJwtDecoder.java ===== */
package com.hau.blogService.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\config\FeignMultipartSupportConfig.java ===== */
package com.hau.blogService.config;

import feign.codec.Encoder;
import feign.form.spring.SpringFormEncoder;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringEncoder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class FeignMultipartSupportConfig {
    @Bean
    public Encoder feignFormEncoder() {
        return new SpringFormEncoder(new SpringEncoder(() -> new HttpMessageConverters(new RestTemplate().getMessageConverters())));
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.blogService.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.blogService.dto.response.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\config\SecurityConfig.java ===== */
package com.hau.blogService.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
            "/**"
    };


    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.GET, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== blog-service\src\main\java\com\hau\blogService\controller\BlogController.java ===== */
package com.hau.blogService.controller;

import com.hau.blogService.dto.request.BlogRequest;
import com.hau.blogService.dto.request.BlogfilterRequest;
import com.hau.blogService.dto.response.ApiResponse;
import com.hau.blogService.dto.response.BlogResponse;
import com.hau.blogService.dto.response.PageResponse;
import com.hau.blogService.service.BlogService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequiredArgsConstructor
public class BlogController {
    private final BlogService blogService;

    @GetMapping
    public ResponseEntity<ApiResponse<PageResponse<BlogResponse>>> getAllBlogs(
            @ModelAttribute BlogfilterRequest filter,
            @RequestParam(defaultValue = "0", required = false) Integer pageIndex,
            @RequestParam(defaultValue = "10", required = false) Integer pageSize
    ) {
        // Pass pagination and filter object to the service
        ApiResponse<PageResponse<BlogResponse>> response = blogService.getAllBlogs(filter, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<BlogResponse>> getBlogById(@PathVariable Long id) {
        ApiResponse<BlogResponse> response = blogService.findById(id);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @PostMapping
    public ResponseEntity<ApiResponse<BlogResponse>> createBlog(@RequestPart(value = "blog") @Valid BlogRequest request, @RequestPart("thumbnail") MultipartFile thumbnail) {
        ApiResponse<BlogResponse> response = blogService.createBlog(request, thumbnail);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<BlogResponse>> updateBlog(@PathVariable Long id, @RequestPart("blog") @Valid BlogRequest request,
                                                                @RequestPart(value = "thumbnail") MultipartFile thumbnail) {
        ApiResponse<BlogResponse> response = blogService.updateBlog(id, request, thumbnail);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteBlog(@PathVariable Long id) {
        ApiResponse<Void> response = blogService.deleteBlog(id);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

}


/* ===== blog-service\src\main\java\com\hau\blogService\controller\CategoryController.java ===== */
package com.hau.blogService.controller;

import com.hau.blogService.dto.response.ApiResponse;
import com.hau.blogService.dto.response.CategoryResponse;
import com.hau.blogService.service.CategoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class CategoryController {
    private final CategoryService categoryService;

    @GetMapping("/category")
    public ResponseEntity<ApiResponse<List<CategoryResponse>>> getAllCategories() {
        ApiResponse<List<CategoryResponse>> response = categoryService.getAllCategories();
        return ResponseEntity.ok(response);
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\converter\StringConverter.java ===== */
package com.hau.blogService.converter;

public class StringConverter {
    public static String toSlug(String str) {
        // Convert to lowercase
        str = str.toLowerCase();

        // Replace spaces with hyphens
        str = str.replaceAll(" ", "-");

        // Remove special characters
        str = str.replaceAll("[^a-z0-9-]", "");

        // Remove consecutive hyphens
        str = str.replaceAll("-+", "-");

        // Trim leading and trailing hyphens
        str = str.replaceAll("^-|-$", "");

        return str;
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\dto\request\BlogfilterRequest.java ===== */
package com.hau.blogService.dto.request;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BlogfilterRequest {
    private String categoryId;
    private String title;
    private String sortDirection;
}


/* ===== blog-service\src\main\java\com\hau\blogService\dto\request\BlogRequest.java ===== */
package com.hau.blogService.dto.request;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
public class BlogRequest {
    @NotNull
    @NotBlank(message = "Title không được để trống")
    private String title;
    @NotBlank(message = "Content không được để trống")
    private String content;
    @Min(value = 1, message = "Priority phải lớn hơn hoặc bằng 1")
    private Integer priority;
    @NotNull(message = "Category ID không được để trống")
    private Long categoryId;
}


/* ===== blog-service\src\main\java\com\hau\blogService\dto\request\CategoryRequest.java ===== */
package com.hau.blogService.dto.request;


import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryRequest {
    @NotNull(message = "ID danh mục không được để trống")
    private Long id;
    @NotNull(message = "Tên danh mục không được để trống")
    private String name;
    @NotNull(message = "Độ ưu tiên không được để trống")
    @Min(value = 1, message = "Mức độ ưu tiên phải lớn hơn 0")
    private Integer priority;
    private Long parentId;
    private String slug;
}


/* ===== blog-service\src\main\java\com\hau\blogService\dto\response\ApiResponse.java ===== */
package com.hau.blogService.dto.response;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== blog-service\src\main\java\com\hau\blogService\dto\response\BlogResponse.java ===== */
package com.hau.blogService.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BlogResponse {
    private Long id;
    private String title;
    private String thumbnail;
    private String content;
    private Integer priority;
    private Long categoryId;
    private String slug;
    private String createdAt;
}


/* ===== blog-service\src\main\java\com\hau\blogService\dto\response\CategoryResponse.java ===== */
package com.hau.blogService.dto.response;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CategoryResponse {
    private Long id;
    private String name;
    private Long priority;
    private Long parentId;
    private String slug;
    private List<CategoryResponse> children;
}


/* ===== blog-service\src\main\java\com\hau\blogService\dto\response\ErrorsResponse.java ===== */
package com.hau.blogService.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== blog-service\src\main\java\com\hau\blogService\dto\response\FileResponse.java ===== */
package com.hau.blogService.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FileResponse {
    private String originalFileName;
    private String url;
}


/* ===== blog-service\src\main\java\com\hau\blogService\dto\response\PageResponse.java ===== */
package com.hau.blogService.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}

/* ===== blog-service\src\main\java\com\hau\blogService\dto\response\PageResult.java ===== */
package com.hau.blogService.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult<T> {
    private List<T> data;
    private int pageIndex;
    private int pageSize;
    private int totalPages;
    private long totalItems;
    private boolean hasNext;
    private boolean hasPrevious;
}



/* ===== blog-service\src\main\java\com\hau\blogService\entity\Blog.java ===== */
package com.hau.blogService.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "blogs")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Blog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String title;
    private String content;
    private String thumbnail;
    private Integer priority;
    private String slug;

    @JsonIgnore
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private Category category;

    @CreationTimestamp
    LocalDateTime createdAt;
}


/* ===== blog-service\src\main\java\com\hau\blogService\entity\Category.java ===== */
package com.hau.blogService.entity;

import jakarta.persistence.*;
import lombok.Data;
import java.util.List;


@Table(name = "categories")
@Entity
@Data
public class Category {
    @Id
    private Long id;
    private String name;
    private String slug;
    private Long parentId;
    @OneToMany(mappedBy = "category")
    private List<Blog> blogs;
}


/* ===== blog-service\src\main\java\com\hau\blogService\exception\AppException.java ===== */
package com.hau.blogService.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\exception\GlobalExceptionHandler.java ===== */
package com.hau.blogService.exception;

import com.hau.blogService.dto.response.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.multipart.support.MissingServletRequestPartException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    @ExceptionHandler(MissingServletRequestPartException.class)
    public ResponseEntity<ErrorsResponse> handleMissingServletRequestPartException(MissingServletRequestPartException ex) {
        String errorMessage = getString(ex);

        // Tạo đối tượng ErrorsResponse với status 400 và thông báo lỗi tùy chỉnh
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), // Status luôn là 400 cho loại lỗi này
                errorMessage,
                // Bạn có thể đưa tên part bị thiếu vào trường 'error' nếu muốn chi tiết hơn
                // hoặc để null như AppException mặc định nếu error không có thông tin cụ thể
                null, // Hoặc partName
                LocalDateTime.now()
        );

        // Trả về ResponseEntity với status 400
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    private static String getString(MissingServletRequestPartException ex) {
        String partName = ex.getRequestPartName();
        String errorMessage;
        // Tạo thông báo lỗi thân thiện dựa trên tên part bị thiếu
        if ("thumbnail".equals(partName)) {
            errorMessage = "Ảnh thumbnail không được để trống";
        } else if ("images".equals(partName)) {
            errorMessage = "Danh sách ảnh sản phẩm không được để trống";
        }
        else {
            // Trường hợp thiếu part khác không phải thumbnail hoặc images
            errorMessage = "Thiếu phần yêu cầu trong request: " + partName;
        }
        return errorMessage;
    }

    // Xử lý lỗi không có quyền truy cập
//    @ExceptionHandler(AuthorizationDeniedException.class)
//    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
//    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
//    @ExceptionHandler(Exception.class)
//    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
//    }

}


/* ===== blog-service\src\main\java\com\hau\blogService\mapper\BlogMapper.java ===== */
package com.hau.blogService.mapper;

import com.hau.blogService.dto.request.BlogRequest;
import com.hau.blogService.dto.response.BlogResponse;
import com.hau.blogService.entity.Blog;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface BlogMapper {
    @Mapping(source = "category.id", target = "categoryId")
    BlogResponse toBlogResponse(Blog blog);
    Blog toBlog(BlogRequest request);

    Blog toBlogUpdateFromRequest(BlogRequest request, @MappingTarget Blog blog);



}


/* ===== blog-service\src\main\java\com\hau\blogService\mapper\CategoryMapper.java ===== */
package com.hau.blogService.mapper;

import com.hau.blogService.dto.request.CategoryRequest;
import com.hau.blogService.dto.response.CategoryResponse;
import com.hau.blogService.entity.Category;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface CategoryMapper {
    CategoryResponse toCategoryResponse(Category category);

    Category toCategory(CategoryRequest categoryRequest);

    Category toCategoryUpdateFromRequest(CategoryRequest categoryRequest, @MappingTarget Category category);
}



/* ===== blog-service\src\main\java\com\hau\blogService\repository\BlogRepository.java ===== */
package com.hau.blogService.repository;

import com.hau.blogService.entity.Blog;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface BlogRepository  extends JpaRepository<Blog, Long> {
    @Query("""
    SELECT b FROM Blog b
    WHERE (:title IS NULL OR b.title ILIKE %:title%)
      AND (:categoryId IS NULL OR b.category.id = :categoryId)
    """)
    Page<Blog> findByFilters(@Param("title") String title,
                             @Param("categoryId") Long categoryId,
                             Pageable pageable);

}


/* ===== blog-service\src\main\java\com\hau\blogService\repository\CategoryRepository.java ===== */
package com.hau.blogService.repository;

import com.hau.blogService.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;


@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    void deleteByParentId(Long id);
}


/* ===== blog-service\src\main\java\com\hau\blogService\repository\FileServiceClientRepository.java ===== */
package com.hau.blogService.repository;

import com.hau.blogService.config.AuthenticationRequestInterceptor;
import com.hau.blogService.config.FeignMultipartSupportConfig;
import com.hau.blogService.dto.response.ApiResponse;
import com.hau.blogService.dto.response.FileResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Repository;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

@Repository
@FeignClient(name = "file-service", url = "${app.file-service.url}",
        configuration = {AuthenticationRequestInterceptor.class, FeignMultipartSupportConfig.class})
public interface FileServiceClientRepository {
    @PostMapping(value = "/file/media", consumes = MediaType.MULTIPART_FORM_DATA_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    ApiResponse<FileResponse> uploadFile(@RequestPart("file") MultipartFile file);

    @DeleteMapping("/file/media/{fileName}")
    ApiResponse<FileResponse> deleteFile(@PathVariable String fileName);
}


/* ===== blog-service\src\main\java\com\hau\blogService\service\BlogService.java ===== */
package com.hau.blogService.service;

import com.hau.blogService.dto.request.BlogRequest;
import com.hau.blogService.dto.request.BlogfilterRequest;
import com.hau.blogService.dto.response.ApiResponse;
import com.hau.blogService.dto.response.BlogResponse;
import com.hau.blogService.dto.response.PageResponse;
import org.springframework.web.multipart.MultipartFile;

public interface BlogService {
    ApiResponse<BlogResponse> createBlog(BlogRequest request, MultipartFile thumbnail);
    ApiResponse<BlogResponse> updateBlog(Long id, BlogRequest request, MultipartFile thumbnail);
    ApiResponse<Void> deleteBlog(Long id);
    ApiResponse<BlogResponse> findById(Long id);
    ApiResponse<PageResponse<BlogResponse>> getAllBlogs(BlogfilterRequest filter, Integer pageIndex, Integer pageSize);
}


/* ===== blog-service\src\main\java\com\hau\blogService\service\CategoryService.java ===== */
package com.hau.blogService.service;

import com.hau.blogService.dto.request.CategoryRequest;
import com.hau.blogService.dto.response.ApiResponse;
import com.hau.blogService.dto.response.CategoryResponse;

import java.util.List;

public interface CategoryService {
    void handleCategoryCreated(CategoryRequest request);
    void handleCategoryUpdated(Long id, CategoryRequest request);
    void handleCategoryDeleted(Long id);

    ApiResponse<List<CategoryResponse>> getAllCategories();
}


/* ===== blog-service\src\main\java\com\hau\blogService\service\FileUploadService.java ===== */
package com.hau.blogService.service;

import org.springframework.web.multipart.MultipartFile;

public interface FileUploadService {
    String uploadFileAndGetUrl(MultipartFile file, String fileTypeDescription); // Uploads a file and returns its URL
}


/* ===== blog-service\src\main\java\com\hau\blogService\service\SlugService.java ===== */
package com.hau.blogService.service;

public interface SlugService {
    String generateUniqueSlug(String title, Long productId);
}


/* ===== blog-service\src\main\java\com\hau\blogService\service\event\CategoryEventConsumer.java ===== */
package com.hau.blogService.service.event;

import com.fasterxml.jackson.databind.ObjectMapper; // Import ObjectMapper
import com.hau.blogService.dto.request.CategoryRequest;
import com.hau.blogService.dto.response.CategoryResponse;
import com.hau.blogService.service.CategoryService;
import com.hau.event.dto.CategoryEvent;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class CategoryEventConsumer {

    private static final String TOPIC_CATEGORY_BLOG_EVENT = "category-blog-event";    private final CategoryService categoryService;
    private final ObjectMapper objectMapper; // Inject ObjectMapper

    @KafkaListener(topics = TOPIC_CATEGORY_BLOG_EVENT)
    public void listen(CategoryEvent event) {
        log.info("Received Category Event: {}", event);

        try {
            switch (event.getType()) {
                case "CATEGORY_CREATED":
                    log.info("Handling Category Created event for ID: {}", event.getCategoryId());
                    if (event.getData() != null) {
                        CategoryResponse createdCategory = objectMapper.convertValue(event.getData(), CategoryResponse.class); // Sử dụng convertValue
                        CategoryRequest categoryRequest = convertToCategoryRequest(createdCategory);
                        categoryService.handleCategoryCreated(categoryRequest);
                    } else {
                        log.warn("Category Created event received with no data for ID: {}", event.getCategoryId());
                    }
                    break;

                case "CATEGORY_UPDATED":
                    log.info("Handling Category Updated event for ID: {}", event.getCategoryId());
                    if (event.getData() != null) {
                        CategoryResponse updatedCategory = objectMapper.convertValue(event.getData(), CategoryResponse.class); // Sử dụng convertValue
                        CategoryRequest updatedCategoryRequest = convertToCategoryRequest(updatedCategory);
                        categoryService.handleCategoryUpdated(updatedCategory.getId() ,updatedCategoryRequest);
                    } else {
                        log.warn("Category Updated event received with no data for ID: {}", event.getCategoryId());
                    }
                    break;

                case "CATEGORY_DELETED":
                    log.info("Handling Category Deleted event for ID: {}", event.getCategoryId());
                    categoryService.handleCategoryDeleted(event.getCategoryId());
                    break;

                default:
                    log.warn("Received unknown Category Event type: {}", event.getType());
            }

            if (event.getCategoryId() != null) { // Kiểm tra null cho categoryId trước khi log
                log.info("Successfully processed Category Event for ID: {}", event.getCategoryId());
            } else {
                log.info("Successfully processed Category Event (ID not provided in event)");
            }


        } catch (Exception e) {
            String eventIdLog = (event != null && event.getCategoryId() != null) ? event.getCategoryId().toString() : "N/A";
            log.error("Error processing Category Event for ID {}: {}", eventIdLog, e.getMessage(), e);
        }
    }


    private CategoryRequest convertToCategoryRequest(CategoryResponse category) {
        if (category == null) {
            return null;
        }
        CategoryRequest categoryRequest = new CategoryRequest();
        categoryRequest.setId(category.getId());
        categoryRequest.setName(category.getName());
        categoryRequest.setSlug(category.getSlug());
        categoryRequest.setParentId(category.getParentId());
        return categoryRequest;
    }
}

/* ===== blog-service\src\main\java\com\hau\blogService\service\impl\BlogServiceImpl.java ===== */
package com.hau.blogService.service.impl;

import com.hau.blogService.converter.StringConverter;
import com.hau.blogService.dto.request.BlogRequest;
import com.hau.blogService.dto.request.BlogfilterRequest;
import com.hau.blogService.dto.response.ApiResponse;
import com.hau.blogService.dto.response.BlogResponse;
import com.hau.blogService.dto.response.PageResponse;
import com.hau.blogService.entity.Blog;
import com.hau.blogService.entity.Category;
import com.hau.blogService.exception.AppException;
import com.hau.blogService.mapper.BlogMapper;
import com.hau.blogService.repository.BlogRepository;
import com.hau.blogService.repository.CategoryRepository;
import com.hau.blogService.repository.FileServiceClientRepository;
import com.hau.blogService.service.BlogService;
import com.hau.blogService.service.FileUploadService;
import com.hau.blogService.service.SlugService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.time.LocalDateTime;

import java.util.List;


@Service
@RequiredArgsConstructor
public class BlogServiceImpl implements BlogService {
    private final BlogRepository blogRepository;
    private final FileUploadService fileUploadService;
    private final BlogMapper blogMapper;
    private final SlugService slugService;
    private final FileServiceClientRepository fileServiceClientRepository;
    private final CategoryRepository categoryRepository;

    @Value("${app.file.download-prefix}")
    private String fileServiceUrl;

    @Transactional
    @Override
    public ApiResponse<BlogResponse> createBlog(BlogRequest request, MultipartFile thumbnail) {
        if(thumbnail == null || thumbnail.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Thumbnail không được để trống", null);
        }
        Blog blog = blogMapper.toBlog(request);

        Category category = categoryRepository.findById(request.getCategoryId())
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục với id: " + request.getCategoryId(), null));

        blog.setCategory(category);
        String thumbnailUrl = fileUploadService.uploadFileAndGetUrl(thumbnail, "blog/thumbnails");
        blog.setThumbnail(thumbnailUrl);
        blog.setSlug(StringConverter.toSlug(blog.getTitle()));
        Blog savedBlog = blogRepository.save(blog);
        blog.setSlug(slugService.generateUniqueSlug(savedBlog.getTitle(), savedBlog.getId()));
        savedBlog = blogRepository.save(savedBlog);
        BlogResponse response = blogMapper.toBlogResponse(savedBlog);



        return ApiResponse.<BlogResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo blog thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    @Override
    public ApiResponse<BlogResponse> updateBlog(Long id, BlogRequest request, MultipartFile thumbnail) {
        Blog blog = blogRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy blog với id: " + id, null));

        if(thumbnail != null && !thumbnail.isEmpty()) {
            String thumbnailUrl = fileUploadService.uploadFileAndGetUrl(thumbnail, "blog/thumbnails");
            blog.setThumbnail(thumbnailUrl);
        }
        Blog updatedBlog = blogMapper.toBlogUpdateFromRequest(request, blog);
        blog.setSlug(slugService.generateUniqueSlug(updatedBlog.getTitle(), id));
        blogRepository.save(updatedBlog);
        BlogResponse response = blogMapper.toBlogResponse(updatedBlog);

        return ApiResponse.<BlogResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật blog thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    @Override
    public ApiResponse<Void> deleteBlog(Long id) {
        Blog blog = blogRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy blog với id: " + id, null));

        if (blog.getThumbnail() != null) {
            fileServiceClientRepository.deleteFile(blog.getThumbnail());
        } else
            throw new AppException(HttpStatus.NOT_FOUND, "Thumbnail của blog đang là null ", null);
        blogRepository.delete(blog);
        return ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa blog thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Override
    public ApiResponse<BlogResponse> findById(Long id) {
        Blog blog = blogRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy blog với id: " + id, null));
        BlogResponse response = blogMapper.toBlogResponse(blog);
        response.setThumbnail(fileServiceUrl + blog.getThumbnail());
        response.setCategoryId(blog.getCategory().getId());
        return ApiResponse.<BlogResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin blog thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Override
    public ApiResponse<PageResponse<BlogResponse>> getAllBlogs(BlogfilterRequest filterRequest ,Integer pageIndex, Integer pageSize) {
        if(pageIndex <= 0) {
            pageIndex = 0;
        } else {
            pageIndex = pageIndex - 1;
        }
        Sort sort = Sort.by("createdAt");
        if ("desc".equalsIgnoreCase(filterRequest.getSortDirection())) {
            sort = sort.descending();
        } else if ("asc".equalsIgnoreCase(filterRequest.getSortDirection())) {
            sort = sort.ascending();
        }

        Pageable pageable = PageRequest.of(pageIndex, pageSize, sort);

        Long categoryId = null;
        try {
            if (filterRequest.getCategoryId() != null) {
                categoryId = Long.parseLong(filterRequest.getCategoryId());
            }
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid categoryId");
        }

        Page<Blog> blogPage = blogRepository.findByFilters(filterRequest.getTitle(), categoryId, pageable);

        List<BlogResponse> responses = blogPage.getContent().stream()
                .map(blog -> {
                    BlogResponse res = blogMapper.toBlogResponse(blog);
                    res.setThumbnail(fileServiceUrl + res.getThumbnail());
                    return res;
                }).toList();



        PageResponse<BlogResponse> pageResponse = PageResponse.<BlogResponse>builder()
                .data(responses)
                .currentPage(blogPage.getNumber() + 1)
                .pageSize(blogPage.getSize())
                .totalPages(blogPage.getTotalPages())
                .totalElements(blogPage.getTotalElements())
                .build();

        return ApiResponse.<PageResponse<BlogResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách blog thành công")
                .result(pageResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\service\impl\CategoryServiceImpl.java ===== */
package com.hau.blogService.service.impl;

import com.hau.blogService.dto.request.CategoryRequest;
import com.hau.blogService.dto.response.ApiResponse;
import com.hau.blogService.dto.response.CategoryResponse;
import com.hau.blogService.entity.Category;
import com.hau.blogService.exception.AppException;
import com.hau.blogService.mapper.CategoryMapper;
import com.hau.blogService.repository.CategoryRepository;
import com.hau.blogService.service.CategoryService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class CategoryServiceImpl implements CategoryService {
    private final CategoryRepository categoryRepository;
    private final CategoryMapper categoryMapper;

    @Override
    public ApiResponse<List<CategoryResponse>> getAllCategories() {
        List<Category> categories = categoryRepository.findAll();
        List<CategoryResponse> responses = categories.stream()
                        .map(categoryMapper::toCategoryResponse)
                        .toList();

        return ApiResponse.<List<CategoryResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách danh mục thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    @Override
    public void handleCategoryCreated(CategoryRequest request) {
        Category category = categoryMapper.toCategory(request);

        Category savedCategory = categoryRepository.save(category);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    @Override
    public void handleCategoryUpdated(Long id, CategoryRequest request) {
        Category existCategory = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));

        Category updatedCategory = categoryMapper.toCategoryUpdateFromRequest(request, existCategory);

        Category savedCategory = categoryRepository.save(updatedCategory);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    @Override
    public void handleCategoryDeleted(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));

        categoryRepository.deleteByParentId(id);
        categoryRepository.delete(category);

        ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa danh mục thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\service\impl\FileUploadServiceimpl.java ===== */
package com.hau.blogService.service.impl;

import com.hau.blogService.exception.AppException;
import com.hau.blogService.repository.FileServiceClientRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

@Service
@RequiredArgsConstructor
public class FileUploadServiceimpl implements com.hau.blogService.service.FileUploadService {
    private final FileServiceClientRepository fileServiceClientRepository;

    public String uploadFileAndGetUrl(MultipartFile file, String fileTypeDescription) {
        if (file == null || file.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "File " + fileTypeDescription + " không được để trống", null);
        }
        try {
            var fileResponse = fileServiceClientRepository.uploadFile(file);
            if (fileResponse != null && fileResponse.getResult() != null && fileResponse.getResult().getUrl() != null) {
                return fileResponse.getResult().getUrl(); // Return only the relative URL path
            } else {
                throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Không nhận được thông tin hợp lệ từ file-service cho " + fileTypeDescription, null);
            }
        } catch (Exception e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi tải lên file " + fileTypeDescription, e);
        }
    }
}


/* ===== blog-service\src\main\java\com\hau\blogService\service\impl\SlugServiceImpl.java ===== */
package com.hau.blogService.service.impl;

import com.hau.blogService.converter.StringConverter;
import com.hau.blogService.service.SlugService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class SlugServiceImpl implements SlugService {
    @Override
    public String generateUniqueSlug(String title, Long productId) {
        String baseSlug = StringConverter.toSlug(title);
        return baseSlug + "-" + productId;
    }

}


/* ===== blog-service\src\main\java\com\hau\event\dto\CategoryEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;


@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryEvent {
    private String type;
    private Long categoryId;
    private Object data;

    // Enum hoặc Constant cho các loại sự kiện
    public static String TYPE_CREATED = "CATEGORY_CREATED";
    public static String TYPE_UPDATED = "CATEGORY_UPDATED";
    public static String TYPE_DELETED = "CATEGORY_DELETED";
}


/* ===== blog-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8085
  servlet:
    context-path: /blog
spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:postgresql://localhost:5432/blog_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 5MB
      enabled: true
  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: blog-service
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
app:
  file-service:
    url: http://localhost:8087
  file:
    download-prefix: http://localhost:8888/api/v1/file/media/download/

/* ===== blog-service\src\main\resources\application.yml ===== */
server:
  port: 8085
  servlet:
    context-path: /blog
spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:postgresql://localhost:5432/blog_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 5MB
      enabled: true
  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: blog-service
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
app:
  file-service:
    url: http://localhost:8087
  file:
    download-prefix: http://localhost:8888/api/v1/file/media/download/

/* ===== blog-service\src\test\java\com\hau\blogService\BlogServiceApplicationTests.java ===== */
package com.hau.blogService;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class BlogServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}


/* ===== cart-service\src\main\java\com\hau\cartservice\CartServiceApplication.java ===== */
package com.hau.cartservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CartServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(CartServiceApplication.class, args);
	}

}


/* ===== cart-service\src\main\java\com\hau\cartservice\config\CustomJwtDecoder.java ===== */
package com.hau.cartservice.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== cart-service\src\main\java\com\hau\cartservice\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.cartservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.cartservice.dto.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== cart-service\src\main\java\com\hau\cartservice\config\SecurityConfig.java ===== */
package com.hau.cartservice.config;


import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
        "/internal/users",
    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== cart-service\src\main\java\com\hau\cartservice\controller\CartProductController.java ===== */
package com.hau.cartservice.controller;

import com.hau.cartservice.dto.ApiResponse;
import com.hau.cartservice.dto.CartProductRequest;
import com.hau.cartservice.dto.CartProductResponse;
import com.hau.cartservice.service.CartProductService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/cart-products")
@RequiredArgsConstructor
public class CartProductController {
    private final CartProductService cartProductService;

    @PostMapping
    public ResponseEntity<ApiResponse<CartProductResponse>> addProductToCart(@RequestBody CartProductRequest cartProductRequest) {
        ApiResponse<CartProductResponse> apiResponse = cartProductService.addProductToCart(cartProductRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @DeleteMapping
    public ResponseEntity<ApiResponse<String>> removeProductFromCart(@RequestBody List<Integer> cartProductIds) {
        ApiResponse<String> apiResponse = cartProductService.removeProductsFromCart(cartProductIds);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== cart-service\src\main\java\com\hau\cartservice\controller\InternalCartController.java ===== */
package com.hau.cartservice.controller;

import com.hau.cartservice.dto.ApiResponse;
import com.hau.cartservice.dto.CartCreateRequest;
import com.hau.cartservice.dto.CartResponse;
import com.hau.cartservice.service.CartService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
public class InternalCartController {
    private final CartService cartService;

    @PostMapping("/internal/users")
    public ResponseEntity<ApiResponse<CartResponse>> createCart(@RequestBody @Valid CartCreateRequest createCartRequest) {
        ApiResponse<CartResponse> apiResponse = cartService.createCart(createCartRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== cart-service\src\main\java\com\hau\cartservice\dto\ApiResponse.java ===== */
package com.hau.cartservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== cart-service\src\main\java\com\hau\cartservice\dto\CartCreateRequest.java ===== */
package com.hau.cartservice.dto;


import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartCreateRequest {
    @NotNull(message = "Id không được để trống")
    private Integer id;
    @NotNull(message = "User Id không được để trống")
    private Integer userId;
}


/* ===== cart-service\src\main\java\com\hau\cartservice\dto\CartProductRequest.java ===== */
package com.hau.cartservice.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartProductRequest {
    @NotNull(message = "Product Id không được để trống")
    private Integer productId;
    @Min(value = 1, message = "Số lượng sản phẩm phải lớn hơn 0")
    private Integer quantity;
}


/* ===== cart-service\src\main\java\com\hau\cartservice\dto\CartProductResponse.java ===== */
package com.hau.cartservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartProductResponse {
    private Integer id;
    private Integer cartId;
    private Integer productId;
    private Integer quantity;
}


/* ===== cart-service\src\main\java\com\hau\cartservice\dto\CartResponse.java ===== */
package com.hau.cartservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartResponse {
    private Integer id;
    private Integer userId;
}


/* ===== cart-service\src\main\java\com\hau\cartservice\dto\ErrorsResponse.java ===== */
package com.hau.cartservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== cart-service\src\main\java\com\hau\cartservice\entity\Cart.java ===== */
package com.hau.cartservice.entity;


import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Builder
@Table(name = "carts")
public class Cart {
    @Id
    private Integer id;

    private Integer userId;

    @CreationTimestamp
    private LocalDateTime createdAt;
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @OneToMany(mappedBy = "cartId", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    private List<CartProduct> cartProducts;
}


/* ===== cart-service\src\main\java\com\hau\cartservice\entity\CartProduct.java ===== */
package com.hau.cartservice.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Builder
@Table(name = "cart_products")
public class CartProduct {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private Integer cartId;
    private Integer productId;
    private Integer quantity;

    @CreationTimestamp
    private LocalDateTime createdAt;
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}


/* ===== cart-service\src\main\java\com\hau\cartservice\entity\Product.java ===== */
package com.hau.cartservice.entity;

import jakarta.persistence.*;
import lombok.*;

import java.util.List;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Builder
@Table(name = "products")
public class Product {
    @Id
    private Integer id;

    private String title;
    private String author;
    private Integer quantity;
    private Integer discount;
    private Integer price;
    private boolean active;

    @OneToMany(mappedBy = "productId", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    private List<CartProduct> cartProducts;
}


/* ===== cart-service\src\main\java\com\hau\cartservice\exception\AppException.java ===== */
package com.hau.cartservice.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== cart-service\src\main\java\com\hau\cartservice\exception\GlobalExceptionHandler.java ===== */
package com.hau.cartservice.exception;

import com.hau.cartservice.dto.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                ex.getMessage(),
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
//    @ExceptionHandler(Exception.class)
//    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
//    }
}


/* ===== cart-service\src\main\java\com\hau\cartservice\mapper\CartMapper.java ===== */
package com.hau.cartservice.mapper;

import com.hau.cartservice.dto.CartCreateRequest;
import com.hau.cartservice.dto.CartResponse;
import com.hau.cartservice.entity.Cart;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface CartMapper {
    Cart toCart(CartCreateRequest cartCreateRequest);

    CartResponse toCartResponse(Cart cart);
}


/* ===== cart-service\src\main\java\com\hau\cartservice\mapper\CartProductMapper.java ===== */
package com.hau.cartservice.mapper;

import com.hau.cartservice.dto.CartProductRequest;
import com.hau.cartservice.dto.CartProductResponse;
import com.hau.cartservice.entity.CartProduct;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface CartProductMapper {
    CartProduct toCartProduct(CartProductRequest cartProductRequest);

    CartProductResponse toCartProductResponse(CartProduct cartProduct);
}


/* ===== cart-service\src\main\java\com\hau\cartservice\repository\CartProductRepository.java ===== */
package com.hau.cartservice.repository;

import com.hau.cartservice.entity.CartProduct;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface CartProductRepository extends JpaRepository<CartProduct, Integer> {
    Optional<CartProduct> findByCartIdAndProductId(Integer cartId, Integer productId);
}


/* ===== cart-service\src\main\java\com\hau\cartservice\repository\CartRepository.java ===== */
package com.hau.cartservice.repository;

import com.hau.cartservice.entity.Cart;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface CartRepository extends JpaRepository<Cart, Integer> {
}


/* ===== cart-service\src\main\java\com\hau\cartservice\service\CartProductService.java ===== */
package com.hau.cartservice.service;

import com.hau.cartservice.dto.ApiResponse;
import com.hau.cartservice.dto.CartProductRequest;
import com.hau.cartservice.dto.CartProductResponse;
import com.hau.cartservice.entity.CartProduct;
import com.hau.cartservice.exception.AppException;
import com.hau.cartservice.mapper.CartProductMapper;
import com.hau.cartservice.repository.CartProductRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@RequiredArgsConstructor
@Service
@Slf4j
public class CartProductService {
    private final CartProductRepository cartProductRepository;
    private final CartProductMapper cartProductMapper;

    public ApiResponse<CartProductResponse> addProductToCart(CartProductRequest cartProductRequest) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        Integer userId = Integer.valueOf(authentication.getName());

        Optional<CartProduct> existingCartProduct = cartProductRepository.findByCartIdAndProductId(userId, cartProductRequest.getProductId());
        if (existingCartProduct.isPresent()) {
            CartProduct cartProduct = existingCartProduct.get();
            cartProduct.setQuantity(cartProduct.getQuantity() + cartProductRequest.getQuantity());
            cartProductRepository.save(cartProduct);
            return ApiResponse.<CartProductResponse>builder()
                    .status(HttpStatus.CREATED.value())
                    .message("Thêm sản phẩm vào giỏ hàng thành công")
                    .result(cartProductMapper.toCartProductResponse(cartProduct))
                    .timestamp(LocalDateTime.now())
                    .build();
        }
        CartProduct cartProduct = cartProductMapper.toCartProduct(cartProductRequest);
        cartProduct.setCartId(userId);
        cartProductRepository.save(cartProduct);
        return ApiResponse.<CartProductResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Thêm sản phẩm vào giỏ hàng thành công")
                .result(cartProductMapper.toCartProductResponse(cartProduct))
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<String> removeProductsFromCart(List<Integer> cartProductIds) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        Integer userId = Integer.valueOf(authentication.getName());
        List<CartProduct> cartProductsToDelete = cartProductRepository.findAllById(cartProductIds);

        if (cartProductsToDelete.size() != cartProductIds.size()) {
            throw new AppException(HttpStatus.NOT_FOUND, "Một hoặc nhiều sản phẩm trong giỏ hàng không tồn tại", null);
        }
        boolean allOwnedByUser = cartProductsToDelete.stream()
                .allMatch(cartProduct -> cartProduct.getCartId().equals(userId));

        if (!allOwnedByUser) {
            throw new AppException(HttpStatus.FORBIDDEN, "Bạn không có quyền xóa một hoặc nhiều sản phẩm này", null);
        }
        cartProductRepository.deleteAll(cartProductsToDelete);

        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa các sản phẩm khỏi giỏ hàng thành công")
                .build();
    }

}


/* ===== cart-service\src\main\java\com\hau\cartservice\service\CartService.java ===== */
package com.hau.cartservice.service;

import com.hau.cartservice.dto.ApiResponse;
import com.hau.cartservice.dto.CartCreateRequest;
import com.hau.cartservice.dto.CartResponse;
import com.hau.cartservice.entity.Cart;
import com.hau.cartservice.mapper.CartMapper;
import com.hau.cartservice.repository.CartRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class CartService {
    private final CartRepository cartRepository;
    private final CartMapper cartMapper;

    public ApiResponse<CartResponse> createCart(CartCreateRequest cartCreateRequest) {
        Cart cart = cartMapper.toCart(cartCreateRequest);
        cartRepository.save(cart);
        return ApiResponse.<CartResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Thêm giỏ hàng thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== cart-service\src\main\java\com\hau\cartservice\service\ProductService.java ===== */
package com.hau.cartservice.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@RequiredArgsConstructor
@Service
@Slf4j
public class ProductService {
}


/* ===== cart-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8083
  servlet:
    context-path: /cart
spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:postgresql://localhost:5432/cart_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
#  kafka:
#    bootstrap-servers: localhost:9094
#    producer:
#      key-serializer: org.apache.kafka.common.serialization.StringSerializer
#      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer



/* ===== cart-service\src\main\resources\application.yml ===== */
server:
  port: 8083
  servlet:
    context-path: /cart
spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:postgresql://localhost:5432/cart_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
#  kafka:
#    bootstrap-servers: localhost:9094
#    producer:
#      key-serializer: org.apache.kafka.common.serialization.StringSerializer
#      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer



/* ===== cart-service\src\test\java\com\hau\cartservice\CartServiceApplicationTests.java ===== */
package com.hau.cartservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CartServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}


/* ===== category-service\src\main\java\com\hau\categoryservice\CategoryServiceApplication.java ===== */
package com.hau.categoryservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.kafka.annotation.EnableKafka;

@SpringBootApplication
@EnableKafka
public class CategoryServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(CategoryServiceApplication.class, args);
    }

}


/* ===== category-service\src\main\java\com\hau\categoryservice\config\AuthenticationRequestInterceptor.java ===== */
package com.hau.categoryservice.config;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
public class AuthenticationRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes servletRequestAttributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

        assert servletRequestAttributes != null;
        var authHeader = servletRequestAttributes.getRequest().getHeader("Authorization");
        log.info("Auth header: {}", authHeader);
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            requestTemplate.header("Authorization", authHeader);
        } else {
            log.warn("No Authorization header found in the request");
        }
    }
}


/* ===== category-service\src\main\java\com\hau\categoryservice\config\CustomJwtDecoder.java ===== */
package com.hau.categoryservice.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== category-service\src\main\java\com\hau\categoryservice\config\FeignMultipartSupportConfig.java ===== */
package com.hau.categoryservice.config;

import feign.codec.Encoder;
import feign.form.spring.SpringFormEncoder;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringEncoder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class FeignMultipartSupportConfig {
    @Bean
    public Encoder feignFormEncoder() {
        return new SpringFormEncoder(new SpringEncoder(() -> new HttpMessageConverters(new RestTemplate().getMessageConverters())));
    }
}


/* ===== category-service\src\main\java\com\hau\categoryservice\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.categoryservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.categoryservice.dto.response.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== category-service\src\main\java\com\hau\categoryservice\config\SecurityConfig.java ===== */
package com.hau.categoryservice.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
        "/**"
    };


    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.GET, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== category-service\src\main\java\com\hau\categoryservice\controller\CategoryController.java ===== */
package com.hau.categoryservice.controller;

import com.hau.categoryservice.dto.request.CategoryRequest;
import com.hau.categoryservice.dto.response.ApiResponse;
import com.hau.categoryservice.dto.response.CategoryResponse;
import com.hau.categoryservice.dto.response.CategoryTreeResponse;
import com.hau.categoryservice.service.CategoryService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequiredArgsConstructor
@Slf4j
public class CategoryController {
    private final CategoryService categoryService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<CategoryResponse>>> getAllCategories(@RequestParam(required = false) String name,
                                                                                @RequestParam(required = false) Boolean isAsc) {
        // Mock implementation
        ApiResponse<List<CategoryResponse>> response = categoryService.getAll(name, isAsc);

        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<CategoryTreeResponse>> getCategoryById(@PathVariable Long id) {
        // Mock implementation
        ApiResponse<CategoryTreeResponse> response = categoryService.getById(id);

        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @PostMapping
    public ResponseEntity<ApiResponse<CategoryResponse>> createCategory(@RequestBody @Valid CategoryRequest request) {
        // Mock implementation
        ApiResponse<CategoryResponse> response = categoryService.create(request);

        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<CategoryResponse>> updateCategory(@PathVariable Long id, @RequestBody @Valid CategoryRequest request) {
        // Mock implementation
        ApiResponse<CategoryResponse> response = categoryService.update(id, request);

        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteCategory(@PathVariable Long id) {
        // Mock implementation
        ApiResponse<Void> response = categoryService.delete(id);

        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @PostMapping ("/seeding/{numberOfRecords}")
    public ResponseEntity<ApiResponse<String>> seeding(@PathVariable Integer numberOfRecords) {
        ApiResponse<String> response = categoryService.seeding(numberOfRecords);
        return new ResponseEntity<ApiResponse<String>>(response, HttpStatus.CREATED);
    }
}


/* ===== category-service\src\main\java\com\hau\categoryservice\converter\StringConverter.java ===== */
package com.hau.categoryservice.converter;

public class StringConverter {
    public static String toSlug(String str) {
        // Convert to lowercase
        str = str.toLowerCase();

        // Replace spaces with hyphens
        str = str.replaceAll(" ", "-");

        // Remove special characters
        str = str.replaceAll("[^a-z0-9-]", "");

        // Remove consecutive hyphens
        str = str.replaceAll("-+", "-");

        // Trim leading and trailing hyphens
        str = str.replaceAll("^-|-$", "");

        return str;
    }
}


/* ===== category-service\src\main\java\com\hau\categoryservice\dto\request\CategoryRequest.java ===== */
package com.hau.categoryservice.dto.request;

import com.hau.categoryservice.enums.CategoryType;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryRequest {
    @NotNull(message = "Tên danh mục không được để trống")
    private String name;
    @NotNull(message = "Độ ưu tiên không được để trống")
    @Min(value = 1, message = "Mức độ ưu tiên phải lớn hơn 0")
    private Integer priority;
    private Long parentId;
    private CategoryType type;
}


/* ===== category-service\src\main\java\com\hau\categoryservice\dto\response\ApiResponse.java ===== */
package com.hau.categoryservice.dto.response;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== category-service\src\main\java\com\hau\categoryservice\dto\response\CategoryResponse.java ===== */
package com.hau.categoryservice.dto.response;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CategoryResponse {
    private Long id;
    private String name;
    private Long priority;
    private String slug;
    private String type;
    private Long parentId;
    private List<CategoryResponse> children;
}


/* ===== category-service\src\main\java\com\hau\categoryservice\dto\response\CategoryTreeResponse.java ===== */
package com.hau.categoryservice.dto.response;

import lombok.Data;
import java.util.List;

@Data
public class CategoryTreeResponse {
    private CategoryResponse parent;             // danh mục cha
    private List<CategoryResponse> children;     // danh sách con
}



/* ===== category-service\src\main\java\com\hau\categoryservice\dto\response\ErrorsResponse.java ===== */
package com.hau.categoryservice.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== category-service\src\main\java\com\hau\categoryservice\entity\Category.java ===== */
package com.hau.categoryservice.entity;

import com.hau.categoryservice.enums.CategoryType;
import jakarta.persistence.*;
import lombok.Data;



@Table(name = "categories")
@Entity
@Data
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String slug;
    private int priority;
    private Long parentId;
    @Enumerated(EnumType.STRING)
    private CategoryType type;
}


/* ===== category-service\src\main\java\com\hau\categoryservice\enums\CategoryType.java ===== */
package com.hau.categoryservice.enums;

public enum CategoryType {
    PRODUCT,
    BLOG,
    SERVICE
}


/* ===== category-service\src\main\java\com\hau\categoryservice\exception\AppException.java ===== */
package com.hau.categoryservice.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== category-service\src\main\java\com\hau\categoryservice\exception\GlobalExceptionHandler.java ===== */
package com.hau.categoryservice.exception;

import com.hau.categoryservice.dto.response.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.multipart.support.MissingServletRequestPartException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    @ExceptionHandler(MissingServletRequestPartException.class)
    public ResponseEntity<ErrorsResponse> handleMissingServletRequestPartException(MissingServletRequestPartException ex) {
        String errorMessage = getString(ex);

        // Tạo đối tượng ErrorsResponse với status 400 và thông báo lỗi tùy chỉnh
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), // Status luôn là 400 cho loại lỗi này
                errorMessage,
                // Bạn có thể đưa tên part bị thiếu vào trường 'error' nếu muốn chi tiết hơn
                // hoặc để null như AppException mặc định nếu error không có thông tin cụ thể
                null, // Hoặc partName
                LocalDateTime.now()
        );

        // Trả về ResponseEntity với status 400
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    private static String getString(MissingServletRequestPartException ex) {
        String partName = ex.getRequestPartName();
        String errorMessage;
        // Tạo thông báo lỗi thân thiện dựa trên tên part bị thiếu
        if ("thumbnail".equals(partName)) {
            errorMessage = "Ảnh thumbnail không được để trống";
        } else if ("images".equals(partName)) {
            errorMessage = "Danh sách ảnh sản phẩm không được để trống";
        }
        else {
            // Trường hợp thiếu part khác không phải thumbnail hoặc images
            errorMessage = "Thiếu phần yêu cầu trong request: " + partName;
        }
        return errorMessage;
    }

    // Xử lý lỗi không có quyền truy cập
//    @ExceptionHandler(AuthorizationDeniedException.class)
//    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
//    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
//    @ExceptionHandler(Exception.class)
//    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
//    }

}


/* ===== category-service\src\main\java\com\hau\categoryservice\mapper\CategoryMapper.java ===== */
package com.hau.categoryservice.mapper;

import com.hau.categoryservice.dto.request.CategoryRequest;
import com.hau.categoryservice.dto.response.CategoryResponse;
import com.hau.categoryservice.entity.Category;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;
import java.util.List;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring")
public interface CategoryMapper {
    @Mapping(source = "type", target = "type")
    CategoryResponse toCategoryResponse(Category category);

    @Mapping(source = "type", target = "type")
    Category toCategory(CategoryRequest categoryRequest);

    @Mapping(source = "type", target = "type")
    Category toCategoryUpdateFromRequest(CategoryRequest categoryRequest, @MappingTarget Category category);
}


/* ===== category-service\src\main\java\com\hau\categoryservice\repository\CategoryRepository.java ===== */
package com.hau.categoryservice.repository;


import com.hau.categoryservice.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    List<Category> findByNameContainingIgnoreCase(String name);
    List<Category> findByParentId(Long parentId);

    void deleteByParentId(Long id);
}


/* ===== category-service\src\main\java\com\hau\categoryservice\service\CategoryService.java ===== */
package com.hau.categoryservice.service;

import com.hau.categoryservice.dto.request.CategoryRequest;
import com.hau.categoryservice.dto.response.ApiResponse;
import com.hau.categoryservice.dto.response.CategoryResponse;
import com.hau.categoryservice.dto.response.CategoryTreeResponse;

import java.util.List;

public interface CategoryService {
    ApiResponse<List<CategoryResponse>> getAll(String name, Boolean isAsc);
    ApiResponse<CategoryTreeResponse> getById(Long id);
    ApiResponse<CategoryResponse> create(CategoryRequest request);
    ApiResponse<CategoryResponse> update(Long id, CategoryRequest request);
    ApiResponse<Void> delete(Long id);
    ApiResponse<String> seeding(Integer numberOfRecords);
}


/* ===== category-service\src\main\java\com\hau\categoryservice\service\SlugService.java ===== */
package com.hau.categoryservice.service;

public interface SlugService {
    String generateUniqueSlug(String title, Long productId);
}


/* ===== category-service\src\main\java\com\hau\categoryservice\service\eventProducer\CategoryEventProducer.java ===== */
package com.hau.categoryservice.service.eventProducer;


import com.hau.categoryservice.dto.response.CategoryResponse;
import com.hau.event.dto.CategoryEvent; // Import DTO sự kiện

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class CategoryEventProducer {

    private static final Logger LOGGER = LoggerFactory.getLogger(CategoryEventProducer.class);
//    private static final String TOPIC_CATEGORY_EVENTS = "category-event"; // Tên Topic Kafka
    private static final String TOPIC_CATEGORY_BLOG_EVENT = "category-blog-event";
    private static final String TOPIC_CATEGORY_PRODUCT_EVENT = "category-product-event";
    private final KafkaTemplate<String, CategoryEvent> kafkaTemplate;

    public void sendCategoryEvent(CategoryEvent event) {
        CategoryResponse response = (CategoryResponse) event.getData();
        if(response.getType().equals("PRODUCT")){
            kafkaTemplate.send(TOPIC_CATEGORY_PRODUCT_EVENT, event);
        } else {
            kafkaTemplate.send(TOPIC_CATEGORY_BLOG_EVENT, event);
        }
    }

    public void sendCategoryCreatedEvent(CategoryEvent event) {
        LOGGER.info("Sending Category Created Event for ID: {} with data:{}", event.getCategoryId(), event.getData());
        sendCategoryEvent(event);
    }

    public void sendCategoryUpdatedEvent(CategoryEvent event) {
        LOGGER.info("Sending Category Updated Event for ID: {} with data:{}", event.getCategoryId(), event.getData());
        sendCategoryEvent(event);
    }

    public void sendCategoryDeletedEvent(CategoryEvent event) {
        LOGGER.info("Sending Category Deleted Event for ID: {}", event.getCategoryId());
        sendCategoryEvent(event);
    }
}


/* ===== category-service\src\main\java\com\hau\categoryservice\service\helper\CategoryHelper.java ===== */
package com.hau.categoryservice.service.helper;

import com.hau.categoryservice.dto.response.CategoryResponse;
import lombok.RequiredArgsConstructor;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class CategoryHelper {
    public static List<CategoryResponse> buildCategoryTree(List<CategoryResponse> categories, Boolean isAsc) {
        categories.sort(Comparator.comparing(CategoryResponse::getId));

        Map<Long, CategoryResponse> categoryMap = categories.stream()
                .collect(Collectors.toMap(CategoryResponse::getId, category -> category));

        List<CategoryResponse> roots = new ArrayList<>();

        for (CategoryResponse category : categories) {
            if (category.getParentId() == null) {
                roots.add(category);
            } else {
                CategoryResponse parent = categoryMap.get(category.getParentId());
                if (parent != null) {
                    if (parent.getChildren() == null) {
                        parent.setChildren(new ArrayList<>());
                    }
                    parent.getChildren().add(category);

                    parent.getChildren().sort(Comparator.comparing(CategoryResponse::getId));
                } else
                    throw new RuntimeException("Parent category not found for id: " + category.getParentId());
            }
        }

        // Sau cùng, sắp xếp luôn root theo id
        if(isAsc == null)
        roots.sort(Comparator.comparing(CategoryResponse::getId));
        else {
            if(isAsc) {
                roots.sort(Comparator.comparing(CategoryResponse::getPriority));
            } else {
                roots.sort(Comparator.comparing(CategoryResponse::getPriority).reversed());
            }
        }
        return roots;
    }

}

/* ===== category-service\src\main\java\com\hau\categoryservice\service\impl\CategoryServiceImpl.java ===== */
package com.hau.categoryservice.service.impl;

import com.github.javafaker.Faker;
import com.hau.categoryservice.enums.CategoryType;
import com.hau.event.dto.CategoryEvent;
import com.hau.categoryservice.dto.request.CategoryRequest;
import com.hau.categoryservice.dto.response.ApiResponse;
import com.hau.categoryservice.dto.response.CategoryResponse;
import com.hau.categoryservice.dto.response.CategoryTreeResponse;

import com.hau.categoryservice.entity.Category;
import com.hau.categoryservice.exception.AppException;
import com.hau.categoryservice.mapper.CategoryMapper;
import com.hau.categoryservice.repository.CategoryRepository;
import com.hau.categoryservice.service.CategoryService;
import com.hau.categoryservice.service.SlugService;
import com.hau.categoryservice.service.eventProducer.CategoryEventProducer;
import com.hau.categoryservice.service.helper.CategoryHelper;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;

import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Random;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class CategoryServiceImpl implements CategoryService {
    private final CategoryRepository categoryRepository;
    private final CategoryMapper categoryMapper;
    private final SlugService slugService;
    private final CategoryEventProducer categoryEventProducer;
    private final Faker faker = new Faker(Locale.of("vi", "VN"));

    public ApiResponse<List<CategoryResponse>> getAll(String name, Boolean isAsc) {
        List<Category> categories;

        if(name != null && !name.trim().isEmpty()) {
            categories = categoryRepository.findByNameContainingIgnoreCase(name);

            if (categories.isEmpty()) {
                throw new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục nào với tên: " + name, null);
            }

        } else {
            categories = categoryRepository.findAll();
        }

        List<CategoryResponse> flatList = categories.stream() // Stream directly from the List
                .map(categoryMapper::toCategoryResponse)
                .collect(Collectors.toList());

        List<CategoryResponse> categoryTree = CategoryHelper.buildCategoryTree(flatList, isAsc);


        return ApiResponse.<List<CategoryResponse>>builder()
                .status(200)
                .message("Lấy danh sách danh mục thành công")
                .result(categoryTree)
                .timestamp(LocalDateTime.now())
                .build();
    }


    @Override
    public ApiResponse<CategoryTreeResponse> getById(Long parentId) {
        Category parent = categoryRepository.findById(parentId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục cha", null));

        List<Category> categories = categoryRepository.findByParentId(parentId);
        List<CategoryResponse> children = categories.stream()
                .map(categoryMapper::toCategoryResponse)
                .toList();

        CategoryTreeResponse data = new CategoryTreeResponse();
        data.setParent(categoryMapper.toCategoryResponse(parent));
        data.setChildren(children);

        return ApiResponse.<CategoryTreeResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách danh mục con thành công")
                .result(data)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    @Override
    public ApiResponse<CategoryResponse> create(CategoryRequest request) {
        Category category = categoryMapper.toCategory(request);
        if(request.getParentId() != null) {
            categoryRepository.findById(request.getParentId())
                    .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục cha", null));
        }

        if(request.getType() == null) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Type không được để trống", null);
        }

        Category savedCategory = categoryRepository.save(category);
        String slug = slugService.generateUniqueSlug(savedCategory.getName(), savedCategory.getId());
        savedCategory.setSlug(slug);
        savedCategory = categoryRepository.save(savedCategory);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        CategoryEvent createdEvent = CategoryEvent.builder()
                .type(CategoryEvent.TYPE_CREATED)
                .categoryId(savedCategory.getId())
                .data(response)
                .build();
        categoryEventProducer.sendCategoryCreatedEvent(createdEvent);

        return ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    @Override
    public ApiResponse<CategoryResponse> update(Long id, CategoryRequest request) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));

        Category updatedCategory = categoryMapper.toCategoryUpdateFromRequest(request, category);

        Category savedCategory = categoryRepository.save(updatedCategory);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        CategoryEvent updatedEvent = CategoryEvent.builder()
                .type(CategoryEvent.TYPE_UPDATED)
                .categoryId(savedCategory.getId())
                .data(response)
                .build();
        categoryEventProducer.sendCategoryUpdatedEvent(updatedEvent);

        return ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    @Override
    public ApiResponse<Void> delete(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));

        CategoryEvent deletedEvent = CategoryEvent.builder()
                .type(CategoryEvent.TYPE_DELETED)
                .categoryId(id)
                .data(categoryMapper.toCategoryResponse(category))
                .build();
        categoryEventProducer.sendCategoryDeletedEvent(deletedEvent);

        categoryRepository.deleteByParentId(id);
        categoryRepository.delete(category);

        return ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa danh mục thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Override
    public ApiResponse<String> seeding(Integer numberOfRecords) {
        List<Category> savedCategories = new ArrayList<>();
        Random rd = new Random();
        String[] categoryTypes = {"BLOG", "PRODUCT"};

        for (int i = 0; i < numberOfRecords; i++) {
            String name = faker.book().title();
            String type = categoryTypes[rd.nextInt(categoryTypes.length)];

            Category category = new Category();
            category.setName(name);
            category.setType(CategoryType.valueOf(type));
            category.setPriority(faker.number().numberBetween(1, 20));

            if (!savedCategories.isEmpty() && rd.nextDouble() < 0.3) {
                Category parent = savedCategories.get(rd.nextInt(savedCategories.size()));
                category.setParentId(parent.getId());
            } else {
                category.setParentId(null); // Root category
            }


            // Generate slug (giả sử slugService nhận parentId)
            category.setSlug(slugService.generateUniqueSlug(category.getName(), category.getParentId()));

            // Save từng category (vì cần ID ngay để làm parent cho cái sau)
            Category savedCategory = categoryRepository.save(category);
            CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);
            CategoryEvent createdEvent = CategoryEvent.builder()
                    .type(CategoryEvent.TYPE_CREATED)
                    .categoryId(savedCategory.getId())
                    .data(response)
                    .build();
            categoryEventProducer.sendCategoryCreatedEvent(createdEvent);
            savedCategories.add(category);
        }
        return ApiResponse.<String>builder()
                .status(200)
                .message("Tạo dữ liệu thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== category-service\src\main\java\com\hau\categoryservice\service\impl\SlugServiceImpl.java ===== */
package com.hau.categoryservice.service.impl;

import com.hau.categoryservice.converter.StringConverter;
import com.hau.categoryservice.service.SlugService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class SlugServiceImpl implements SlugService {
    @Override
    public String generateUniqueSlug(String title, Long productId) {
        String baseSlug = StringConverter.toSlug(title);
        return baseSlug + "-" + productId;
    }

}


/* ===== category-service\src\main\java\com\hau\event\dto\CategoryEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryEvent {
    private String type;
    private Long categoryId;
    private Object data;

    public static String TYPE_CREATED = "CATEGORY_CREATED";
    public static String TYPE_UPDATED = "CATEGORY_UPDATED";
    public static String TYPE_DELETED = "CATEGORY_DELETED";
}


/* ===== category-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8084
  servlet:
    context-path: /category

spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:postgresql://localhost:5432/category_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

/* ===== category-service\src\main\resources\application.yml ===== */
server:
  port: 8084
  servlet:
    context-path: /category

spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:postgresql://localhost:5432/category_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

/* ===== category-service\src\test\java\com\hau\categoryservice\CategoryServiceApplicationTests.java ===== */
package com.hau.categoryservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CategoryServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


/* ===== customer-service\src\main\java\com\hau\customerService\CustomerServiceApplication.java ===== */
package com.hau.customerService;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CustomerServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(CustomerServiceApplication.class, args);
	}

}


/* ===== customer-service\src\main\java\com\hau\customerService\config\AuthenticationRequestInterceptor.java ===== */
package com.hau.customerService.config;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
public class AuthenticationRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes servletRequestAttributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

        assert servletRequestAttributes != null;
        var authHeader = servletRequestAttributes.getRequest().getHeader("Authorization");
        log.info("Auth header: {}", authHeader);
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            requestTemplate.header("Authorization", authHeader);
        } else {
            log.warn("No Authorization header found in the request");
        }
    }
}


/* ===== customer-service\src\main\java\com\hau\customerService\config\CustomJwtDecoder.java ===== */
package com.hau.customerService.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== customer-service\src\main\java\com\hau\customerService\config\FeignMultipartSupportConfig.java ===== */
package com.hau.customerService.config;

import feign.codec.Encoder;
import feign.form.spring.SpringFormEncoder;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringEncoder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class FeignMultipartSupportConfig {
    @Bean
    public Encoder feignFormEncoder() {
        return new SpringFormEncoder(new SpringEncoder(() -> new HttpMessageConverters(new RestTemplate().getMessageConverters())));
    }
}


/* ===== customer-service\src\main\java\com\hau\customerService\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.customerService.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.customerService.dto.response.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== customer-service\src\main\java\com\hau\customerService\config\SecurityConfig.java ===== */
package com.hau.customerService.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
        "/**"
    };


    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== customer-service\src\main\java\com\hau\customerService\controller\CustomerCareController.java ===== */
package com.hau.customerService.controller;

import com.hau.customerService.dto.request.CustomerCareRequest;
import com.hau.customerService.dto.response.CustomerCareResponse;
import com.hau.customerService.dto.response.PageResponse;
import com.hau.customerService.service.CustomerCareService;
import com.hau.customerService.dto.response.ApiResponse;
import jakarta.validation.Valid;
import lombok.Builder;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
@Builder
public class CustomerCareController {
    private final CustomerCareService customerCareService;

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @GetMapping
    public ResponseEntity<ApiResponse<PageResponse<CustomerCareResponse>>> findAll(@RequestParam(required = false, defaultValue = "1") Integer pageIndex,
                                                                                 @RequestParam(required = false, defaultValue = "10") Integer pageSize,
                                                                                 @RequestParam(required = false) String sortDir) {
        ApiResponse<PageResponse<CustomerCareResponse>> result = customerCareService.findAll(pageIndex, pageSize, sortDir);
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<CustomerCareResponse>> findById(@PathVariable Long id) {
        ApiResponse<CustomerCareResponse> result = customerCareService.findById(id);
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    @PostMapping
    public ResponseEntity<ApiResponse<CustomerCareResponse>> createContact(@RequestBody @Valid CustomerCareRequest request) {
        ApiResponse<CustomerCareResponse> result = customerCareService.createContact(request);
        return new ResponseEntity<>(result, HttpStatus.CREATED);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @PostMapping("/seeding/{numberOfRecords}")
    public ResponseEntity<ApiResponse<String>> seeding(@PathVariable Integer numberOfRecords) {
        ApiResponse<String> response = customerCareService.seeding(numberOfRecords);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<Void>> deleteContact(@PathVariable Long id) {
        ApiResponse<Void> result = customerCareService.deleteContact(id);
        return new ResponseEntity<>(result, HttpStatus.OK);
    }
}


/* ===== customer-service\src\main\java\com\hau\customerService\dto\request\CustomerCareRequest.java ===== */
package com.hau.customerService.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CustomerCareRequest {
    @NotNull(message = "Tên không được để trống")
    @NotBlank(message = "Tên không được để trống")
    private String name;
    @NotNull(message = "Số điện thoại không được để trống")
    @NotBlank(message = "Số điện thoại không được để trống")
    private String phone;

    @NotNull(message = "Email không được để trống")
    @NotBlank(message = "Email không được để trống")
    private String email;

    @NotNull(message = "Địa chỉ không được để trống")
    @NotBlank(message = "Địa chỉ không được để trống")
    private String address;

    @NotNull(message = "Nội dung không được để trống")
    @NotBlank(message = "Nội dung không được để trống")
    private String content;
}


/* ===== customer-service\src\main\java\com\hau\customerService\dto\response\ApiResponse.java ===== */
package com.hau.customerService.dto.response;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== customer-service\src\main\java\com\hau\customerService\dto\response\CustomerCareResponse.java ===== */
package com.hau.customerService.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CustomerCareResponse {
    private Long id;
    private String name;
    private String phone;
    private String email;
    private String address;
    private String content;
    private String createdAt;
}


/* ===== customer-service\src\main\java\com\hau\customerService\dto\response\ErrorsResponse.java ===== */
package com.hau.customerService.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== customer-service\src\main\java\com\hau\customerService\dto\response\PageResponse.java ===== */
package com.hau.customerService.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}

/* ===== customer-service\src\main\java\com\hau\customerService\dto\response\PageResult.java ===== */
package com.hau.customerService.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult<T> {
    private List<T> data;
    private int pageIndex;
    private int pageSize;
    private int totalPages;
    private long totalItems;
    private boolean hasNext;
    private boolean hasPrevious;
}



/* ===== customer-service\src\main\java\com\hau\customerService\entity\CustomerCare.java ===== */
package com.hau.customerService.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Table(name = "customer_care")
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CustomerCare {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String phone;
    private String email;
    private String address;
    private String content;
    @CreationTimestamp
    LocalDateTime createdAt;

}


/* ===== customer-service\src\main\java\com\hau\customerService\entity\HomePage.java ===== */
package com.hau.customerService.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@Table(name = "home_page")
@NoArgsConstructor
@AllArgsConstructor
public class HomePage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;
}


/* ===== customer-service\src\main\java\com\hau\customerService\exception\AppException.java ===== */
package com.hau.customerService.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== customer-service\src\main\java\com\hau\customerService\exception\GlobalExceptionHandler.java ===== */
package com.hau.customerService.exception;

import com.hau.customerService.dto.response.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.multipart.support.MissingServletRequestPartException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    @ExceptionHandler(MissingServletRequestPartException.class)
    public ResponseEntity<ErrorsResponse> handleMissingServletRequestPartException(MissingServletRequestPartException ex) {
        String errorMessage = getString(ex);

        // Tạo đối tượng ErrorsResponse với status 400 và thông báo lỗi tùy chỉnh
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), // Status luôn là 400 cho loại lỗi này
                errorMessage,
                // Bạn có thể đưa tên part bị thiếu vào trường 'error' nếu muốn chi tiết hơn
                // hoặc để null như AppException mặc định nếu error không có thông tin cụ thể
                null, // Hoặc partName
                LocalDateTime.now()
        );

        // Trả về ResponseEntity với status 400
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    private static String getString(MissingServletRequestPartException ex) {
        String partName = ex.getRequestPartName();
        String errorMessage;
        // Tạo thông báo lỗi thân thiện dựa trên tên part bị thiếu
        if ("thumbnail".equals(partName)) {
            errorMessage = "Ảnh thumbnail không được để trống";
        } else if ("images".equals(partName)) {
            errorMessage = "Danh sách ảnh sản phẩm không được để trống";
        }
        else {
            // Trường hợp thiếu part khác không phải thumbnail hoặc images
            errorMessage = "Thiếu phần yêu cầu trong request: " + partName;
        }
        return errorMessage;
    }

    // Xử lý lỗi không có quyền truy cập
//    @ExceptionHandler(AuthorizationDeniedException.class)
//    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
//    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
//    @ExceptionHandler(Exception.class)
//    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
//    }

}


/* ===== customer-service\src\main\java\com\hau\customerService\mapper\CustomerCareMapper.java ===== */
package com.hau.customerService.mapper;

import com.hau.customerService.dto.request.CustomerCareRequest;
import com.hau.customerService.dto.response.CustomerCareResponse;
import com.hau.customerService.entity.CustomerCare;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface CustomerCareMapper {
    CustomerCareResponse toCustomerCareResponse(CustomerCare customerCare);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    CustomerCare toCustomerCare(CustomerCareRequest request);
}


/* ===== customer-service\src\main\java\com\hau\customerService\repository\CustomerCareRepository.java ===== */
package com.hau.customerService.repository;

import com.hau.customerService.entity.CustomerCare;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface CustomerCareRepository extends JpaRepository<CustomerCare, Long> {
}


/* ===== customer-service\src\main\java\com\hau\customerService\repository\HomePageRepository.java ===== */
package com.hau.customerService.repository;

import com.hau.customerService.entity.HomePage;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface HomePageRepository extends JpaRepository<HomePage, Long> {
}


/* ===== customer-service\src\main\java\com\hau\customerService\service\CustomerCareService.java ===== */
package com.hau.customerService.service;

import com.github.javafaker.Faker;
import com.hau.customerService.dto.request.CustomerCareRequest;
import com.hau.customerService.dto.response.CustomerCareResponse;
import com.hau.customerService.dto.response.PageResponse;

import com.hau.customerService.entity.CustomerCare;
import com.hau.customerService.exception.AppException;
import com.hau.customerService.mapper.CustomerCareMapper;
import com.hau.customerService.repository.CustomerCareRepository;
import com.hau.customerService.dto.response.ApiResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;


@Service
@RequiredArgsConstructor
public class CustomerCareService {
    private final CustomerCareRepository customerCareRepository;
    private final CustomerCareMapper customerCareMapper;

    public ApiResponse<PageResponse<CustomerCareResponse>> findAll(Integer pageIndex, Integer pageSize, String sortDir) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;

        Sort sort;
        if (sortDir != null && !sortDir.isEmpty()) {
            Sort.Direction direction = "asc".equalsIgnoreCase(sortDir) ? Sort.Direction.ASC : Sort.Direction.DESC;
            sort = Sort.by(direction, "createdAt");
        } else {
            sort = Sort.by(Sort.Direction.DESC, "createdAt");
        }

        Pageable pageable = PageRequest.of(page, pageSize, sort);

        Page<CustomerCare> customerCarePage = customerCareRepository.findAll(pageable);
        List<CustomerCareResponse> responses = customerCarePage.getContent().stream()
                .map(customerCareMapper::toCustomerCareResponse)
                .toList();

        PageResponse<CustomerCareResponse> result = PageResponse.<CustomerCareResponse>builder()
                .data(responses)
                .currentPage(customerCarePage.getNumber() + 1)
                .pageSize(customerCarePage.getSize())
                .totalPages(customerCarePage.getTotalPages())
                .totalElements(customerCarePage.getTotalElements())
                .build();

        return ApiResponse.<PageResponse<CustomerCareResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách liên hệ thành công")
                .result(result)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<CustomerCareResponse> findById(Long id) {
        CustomerCare customerCare = customerCareRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy liên hệ", "id = " + id));
        CustomerCareResponse response = customerCareMapper.toCustomerCareResponse(customerCare);
        return ApiResponse.<CustomerCareResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin liên hệ thành công")
                .result(response)
                .build();
    }

    public ApiResponse<CustomerCareResponse> createContact(CustomerCareRequest request) {
        CustomerCare customerCare = customerCareMapper.toCustomerCare(request);
        customerCareRepository.save(customerCare);
        CustomerCareResponse response = customerCareMapper.toCustomerCareResponse(customerCare);
        return ApiResponse.<CustomerCareResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo liên hệ thành công")
                .result(response)
                .build();
    }

    public ApiResponse<Void> deleteContact(Long id) {
        customerCareRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy liên hệ", "id = " + id));
        customerCareRepository.deleteById(id);
        return ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa liên hệ thành công")
                .build();
    }

    public ApiResponse<String> seeding(Integer numberOfRecords) {
        Faker faker = new com.github.javafaker.Faker();
        for (int i = 0; i < numberOfRecords; i++) {
            CustomerCare customerCare = new CustomerCare();
            customerCare.setName(faker.name().fullName());
            customerCare.setPhone(faker.phoneNumber().cellPhone());
            customerCare.setEmail(faker.internet().emailAddress());
            customerCare.setAddress(faker.address().fullAddress());
            customerCare.setContent(faker.lorem().sentence());
            customerCareRepository.save(customerCare);
        }
        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Seeding thành công " + numberOfRecords + " bản ghi!")
                .result("OK")
                .build();
    }
}


/* ===== customer-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8086
  servlet:
    context-path: /customer

spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:postgresql://localhost:5432/customer_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect


/* ===== customer-service\src\main\resources\application.yml ===== */
server:
  port: 8086
  servlet:
    context-path: /customer

spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:postgresql://localhost:5432/customer_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect


/* ===== customer-service\src\test\java\com\hau\customerService\CustomerServiceApplicationTests.java ===== */
package com.hau.customerService;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CustomerServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}


/* ===== file-service\src\main\java\com\hau\fileservice\FileServiceApplication.java ===== */
package com.hau.fileservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FileServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(FileServiceApplication.class, args);
    }

}


/* ===== file-service\src\main\java\com\hau\fileservice\config\CustomJwtDecoder.java ===== */
package com.hau.fileservice.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== file-service\src\main\java\com\hau\fileservice\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.fileservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.fileservice.dto.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== file-service\src\main\java\com\hau\fileservice\config\SecurityConfig.java ===== */
package com.hau.fileservice.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicGetEndpoint = {
        "/media/download/**",
    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.GET, publicGetEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== file-service\src\main\java\com\hau\fileservice\controller\FileController.java ===== */
package com.hau.fileservice.controller;

import com.hau.fileservice.dto.ApiResponse;
import com.hau.fileservice.dto.FileResponse;
import com.hau.fileservice.service.FileService;
import lombok.RequiredArgsConstructor;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

@RestController
@RequiredArgsConstructor
public class FileController {
    private final FileService fileService;

    @PostMapping("/media")
    public ResponseEntity<ApiResponse<FileResponse>> uploadFile(@RequestPart("file") MultipartFile file) throws IOException {
        ApiResponse<FileResponse> apiResponse = fileService.uploadFile(file);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @GetMapping("/media/download/{fileName}")
    public ResponseEntity<Resource> downloadFile(@PathVariable String fileName) throws IOException {
        var fileData = fileService.downloadFile(fileName);
        var fileManagement = fileService.getFileManagement(fileName);

        String originalFileName = fileManagement.getId();
        String contentType = fileData.contentType();
        if (contentType == null) contentType = "application/octet-stream";

        // Các loại content type cho phép hiển thị trên browser
        boolean isInlineDisplay =
                contentType.startsWith("image/")
                        || contentType.startsWith("video/");

        ResponseEntity.BodyBuilder responseBuilder = ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_TYPE, contentType);

        if (!isInlineDisplay) {
            // Các loại file khác sẽ ép tải về
            responseBuilder.header(HttpHeaders.CONTENT_DISPOSITION,
                    "attachment; filename=\"" + originalFileName + "\"");
        }
        return responseBuilder.body(fileData.resource());
    }

    @DeleteMapping("/media/{fileName}")
    public void deleteFile(@PathVariable String fileName) throws IOException {
        fileService.deleteFile(fileName);
    }
}


/* ===== file-service\src\main\java\com\hau\fileservice\dto\ApiResponse.java ===== */
package com.hau.fileservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== file-service\src\main\java\com\hau\fileservice\dto\ErrorsResponse.java ===== */
package com.hau.fileservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    int status;
    String message;
    Object error;
    LocalDateTime timestamp;
}


/* ===== file-service\src\main\java\com\hau\fileservice\dto\FileData.java ===== */
package com.hau.fileservice.dto;

import org.springframework.core.io.Resource;

public record FileData(String contentType, Resource resource) {

}


/* ===== file-service\src\main\java\com\hau\fileservice\dto\FileInfo.java ===== */
package com.hau.fileservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FileInfo {
    private String fileName;
    private String contentType;
    private long size;
    private String md5Checksum;
    private String filePath;
    private String fileUrl;
}


/* ===== file-service\src\main\java\com\hau\fileservice\dto\FileResponse.java ===== */
package com.hau.fileservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FileResponse {
    private String originalFileName;
    private String url;
}


/* ===== file-service\src\main\java\com\hau\fileservice\dto\PageResponse.java ===== */
package com.hau.fileservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}


/* ===== file-service\src\main\java\com\hau\fileservice\entity\FileManagement.java ===== */
package com.hau.fileservice.entity;

import lombok.*;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.MongoId;

import java.time.LocalDateTime;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Document(collection = "file_management")
public class FileManagement {
    @MongoId
    private String id;
    private String ownerId;
    private String contentType;
    private long size;
    private String md5Checksum;
    private String filePath;

    private LocalDateTime createdAt;
}


/* ===== file-service\src\main\java\com\hau\fileservice\exception\AppException.java ===== */
package com.hau.fileservice.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== file-service\src\main\java\com\hau\fileservice\exception\GlobalExceptionHandler.java ===== */
package com.hau.fileservice.exception;

import com.hau.fileservice.dto.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions(AppException e) {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra", e.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== file-service\src\main\java\com\hau\fileservice\mapper\FileManagementMapper.java ===== */
package com.hau.fileservice.mapper;

import com.hau.fileservice.dto.FileInfo;
import com.hau.fileservice.dto.FileResponse;
import com.hau.fileservice.entity.FileManagement;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface FileManagementMapper {
    @Mapping(target = "id", source = "fileName")
    FileManagement toFileManagement(FileInfo fileInfo);

}


/* ===== file-service\src\main\java\com\hau\fileservice\repository\FileManagementRepository.java ===== */
package com.hau.fileservice.repository;

import com.hau.fileservice.entity.FileManagement;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface FileManagementRepository extends MongoRepository<FileManagement, String> {

}


/* ===== file-service\src\main\java\com\hau\fileservice\repository\FileRepository.java ===== */
package com.hau.fileservice.repository;

import com.hau.fileservice.dto.FileInfo;
import com.hau.fileservice.entity.FileManagement;
import com.hau.fileservice.exception.AppException;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Repository;
import org.springframework.util.DigestUtils;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.UUID;

@Repository
@RequiredArgsConstructor
public class FileRepository {
    @Value("${app.file.storage-dir}")
    private String storageDir;
    private final FileManagementRepository fileManagementRepository;
    public FileInfo uploadFile(MultipartFile file) throws IOException {
        Path path = Paths.get(storageDir);
        String originalFileName = file.getOriginalFilename();
        String fileName = UUID.randomUUID() + "_" + file.getOriginalFilename();

        Path filePath = path.resolve(fileName).normalize().toAbsolutePath();
        Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);
        String contentType = file.getContentType();
        if (originalFileName != null && originalFileName.toLowerCase().endsWith(".jfif")) {
            // Ghi đè Content-Type thành image/jpeg chỉ cho file .jfif
            contentType = MediaType.IMAGE_JPEG_VALUE;
        }
        return FileInfo.builder()
                .fileName(fileName)
                .size(file.getSize())
                .contentType(contentType)
                .md5Checksum(DigestUtils.md5DigestAsHex(file.getInputStream()))
                .filePath(filePath.toString())
                .fileUrl(fileName)
                .build();
    }

    public Resource read(FileManagement fileManagement) throws IOException {
        var data = Files.readAllBytes(Path.of(fileManagement.getFilePath()));
        return new ByteArrayResource(data);
    }

    public void delete(String filename) throws IOException {
        Path filePath = Path.of(storageDir, filename); // Cách tốt hơn để kết hợp đường dẫn
        boolean isDeleted = Files.deleteIfExists(filePath);
        if(!isDeleted) {
            throw new AppException(HttpStatus.NOT_FOUND, "Xóa thất bại", filePath);
        }
        fileManagementRepository.deleteById(filename);

    }
}


/* ===== file-service\src\main\java\com\hau\fileservice\service\FileService.java ===== */
package com.hau.fileservice.service;

import com.hau.fileservice.dto.ApiResponse;
import com.hau.fileservice.dto.FileData;
import com.hau.fileservice.dto.FileResponse;
import com.hau.fileservice.entity.FileManagement;
import com.hau.fileservice.exception.AppException;
import com.hau.fileservice.mapper.FileManagementMapper;
import com.hau.fileservice.repository.FileManagementRepository;
import com.hau.fileservice.repository.FileRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.time.LocalDateTime;

@Service
@Slf4j
@RequiredArgsConstructor
public class FileService {
    private final FileRepository fileRepository;
    private final FileManagementRepository fileManagementRepository;
    private final FileManagementMapper fileManagementMapper;

    public ApiResponse<FileResponse> uploadFile(MultipartFile file) throws IOException {
        var fileInfo = fileRepository.uploadFile(file);
        var fileManagement = fileManagementMapper.toFileManagement(fileInfo);
        String userId = SecurityContextHolder.getContext().getAuthentication().getName();
        fileManagement.setOwnerId(userId);
        fileManagement.setCreatedAt(LocalDateTime.now());
        fileManagementRepository.save(fileManagement);
        return ApiResponse.<FileResponse>builder()
                .status(201)
                .message("Thêm mới file thành công")
                .result(FileResponse.builder()
                        .originalFileName(file.getOriginalFilename())
                        .url(fileInfo.getFileUrl())
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }

    public FileData downloadFile(String fileName) throws IOException {
        var fileManagement = fileManagementRepository.findById(fileName).orElseThrow(
                () -> new AppException(HttpStatus.NOT_FOUND, "File không tồn tại", null)
        );

        return new FileData(fileManagement.getContentType(), fileRepository.read(fileManagement));
    }

    public void deleteFile(String fileName) throws IOException {
        fileRepository.delete(fileName);
    }

    public FileManagement getFileManagement(String fileName) {
        return fileManagementRepository.findById(fileName)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "File không tồn tại", null));
    }
}

// new branch


/* ===== file-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8087
  servlet:
    context-path: /file
spring:
  application:
    name: file-service
  data:
    mongodb:
      uri: mongodb://root:123456789@localhost:27017/file_db?authSource=admin
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 5MB
app:
  file:
    storage-dir: D:/Uploads

/* ===== file-service\src\main\resources\application.yml ===== */
server:
  port: 8087
  servlet:
    context-path: /file
spring:
  application:
    name: file-service
  data:
    mongodb:
      uri: mongodb://root:123456789@localhost:27017/file_db?authSource=admin
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 5MB
app:
  file:
    storage-dir: D:/Uploads

/* ===== file-service\src\test\java\com\hau\fileservice\FileServiceApplicationTests.java ===== */
package com.hau.fileservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class FileServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


/* ===== identity-service\doc.txt ===== */
/* ===== identity_service/config/ApplicationInitConfig.java ===== */
package com.hau.identity_service.config;

import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

import com.hau.identity_service.entity.Role;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.repository.RoleRepository;
import com.hau.identity_service.repository.UserRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
@Configuration
@Slf4j
public class ApplicationInitConfig {

    private final PasswordEncoder passwordEncoder;

    @Value("${admin.username}")
    private String adminUsername;

    @Value("${admin.password}")
    private String adminPassword;

    @Value("${admin.role}")
    private String adminRole;

    @Bean
    ApplicationRunner applicationRunner(UserRepository userRepository, RoleRepository roleRepository) {
        return args -> {
            if (roleRepository.findByName(adminRole).isEmpty()) {
                Role role = Role.builder()
                        .name(adminRole)
                        .description("Quyền quản trị viên")
                        .build();
                roleRepository.save(role);
                log.info("Role ADMIN đã được tạo.");
            }

            if (roleRepository.findByName("USER").isEmpty()) {
                Role userRole = Role.builder()
                        .name("USER")
                        .description("Quyền người dùng thông thường")
                        .build();
                roleRepository.save(userRole);
                log.info("Role USER đã được tạo.");
            }

            if (userRepository.findByUsername(adminUsername).isEmpty()) {

                User user = User.builder()
                        .username(adminUsername)
                        .password(passwordEncoder.encode(adminPassword))
                        .email("datdnk3@gmail.com")
                        .build();
                var roles = roleRepository.findAllById(Set.of(adminRole));
                if (roles.isEmpty()) {
                    log.error("Không tìm thấy role ADMIN");
                    return;
                }
                user.setRoles(new HashSet<>(roles));
                userRepository.save(user);
                log.warn(
                        "Người dùng admin đã được tạo với mật khẩu là admin, hãy thay đổi mật khẩu ngay sau khi đăng nhập lần đầu tiên");
            }
        };
    }
}


/* ===== identity_service/config/CustomJwtDecoder.java ===== */
package com.hau.identity_service.config;

import java.util.Objects;
import javax.crypto.spec.SecretKeySpec;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.oauth2.jose.jws.MacAlgorithm;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.stereotype.Component;

import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.service.TokenService;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Value("${jwt.signerKey}")
    private String singerKey;

    private final TokenService tokenService;

    private NimbusJwtDecoder nimbusJwtDecoder = null;

    @Override
    public Jwt decode(String token) throws JwtException {
        if (token == null || token.isEmpty()) {
            throw new JwtException("Token không được cung cấp");
        }

        try {
            IntrospectResponse response = tokenService.validateToken(token);

            if (!response.isValid()) {
                throw new JwtException("Token không hợp lệ");
            }

            if (Objects.isNull(nimbusJwtDecoder)) {
                SecretKeySpec secretKeySpec = new SecretKeySpec(singerKey.getBytes(), "HS512");
                nimbusJwtDecoder = NimbusJwtDecoder.withSecretKey(secretKeySpec)
                        .macAlgorithm(MacAlgorithm.HS512)
                        .build();
            }

            return nimbusJwtDecoder.decode(token);
        } catch (Exception e) {
            throw new JwtException(e.getMessage());
        }
    }
}


/* ===== identity_service/config/JwtAuthenticationEntryPoint.java ===== */
package com.hau.identity_service.config;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.identity_service.dto.response.ApiResponse;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập: Token không hợp lệ hoặc hết hạn")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== identity_service/config/SecurityConfig.java ===== */
package com.hau.identity_service.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

import lombok.RequiredArgsConstructor;
import org.springframework.web.cors.CorsConfiguration;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
            "/api/v1/users",
            "/api/v1/auth/introspect",
            "/api/v1/auth/login",
            "/api/v1/auth/logout",
            "/api/v1/auth/refresh-token",
            "/api/v1/auth/password-recovery/otp",
            "/api/v1/auth/password-recovery/otp/verify",
            "/api/v1/auth/password-recovery/reset",
    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.cors(cors -> cors.configurationSource(request -> {
            CorsConfiguration config = new CorsConfiguration();
            config.addAllowedOrigin("*");
            config.addAllowedMethod("*");
            config.addAllowedHeader("*");
            config.setAllowCredentials(false);
            config.setMaxAge(3600L);
            return config;
        }));

        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(10);
    }
}

/* ===== identity_service/controller/AuthenticationController.java ===== */
package com.hau.identity_service.controller;

import java.text.ParseException;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.*;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.AuthenticationResponse;
import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.dto.response.VerifyOtpResponse;
import com.hau.identity_service.service.AuthenticationService;
import com.hau.identity_service.service.ForgotPasswordService;
import com.hau.identity_service.service.TokenService;
import com.nimbusds.jose.JOSEException;

import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class AuthenticationController {
    private final AuthenticationService authenticationService;
    private final ForgotPasswordService forgotPasswordService;
    private final TokenService tokenService;

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<AuthenticationResponse>> authenticate(
            @RequestBody @Valid AuthenticationRequest authenticationRequest) {
        ApiResponse<AuthenticationResponse> apiResponse = authenticationService.authenticate(authenticationRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/logout")
    public ResponseEntity<ApiResponse<Void>> logout(@RequestBody LogoutRequest logoutRequest) throws ParseException {
        ApiResponse<Void> apiResponse = authenticationService.logout(logoutRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<ApiResponse<AuthenticationResponse>> refreshToken(
            @RequestBody RefreshTokenRequest refreshTokenRequest) throws ParseException, JOSEException {
        ApiResponse<AuthenticationResponse> apiResponse = tokenService.refreshToken(refreshTokenRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/introspect")
    public ResponseEntity<ApiResponse<IntrospectResponse>> introspect(@RequestBody IntrospectRequest request) {
        ApiResponse<IntrospectResponse> apiResponse = authenticationService.introspect(request);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/password-recovery/otp")
    public ResponseEntity<ApiResponse<String>> sendOtpForgotPassword(
            @RequestBody @Valid ForgotPasswordRequest forgotPasswordRequest) {
        ApiResponse<String> apiResponse = forgotPasswordService.sendOtp(forgotPasswordRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/password-recovery/otp/verify")
    public ResponseEntity<ApiResponse<VerifyOtpResponse>> verifyOtpForgotPassword(
            @Valid @RequestBody VerifyOtpRequest verifyOtpRequest) {
        ApiResponse<VerifyOtpResponse> apiResponse = forgotPasswordService.verifyOtp(verifyOtpRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/password-recovery/reset")
    public ResponseEntity<ApiResponse<String>> resetPassword(
            @Valid @RequestBody ResetPasswordWithTokenRequest resetPasswordWithTokenRequest) {
        ApiResponse<String> apiResponse = forgotPasswordService.resetPassword(resetPasswordWithTokenRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== identity_service/controller/PermissionController.java ===== */
package com.hau.identity_service.controller;

import java.util.List;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.PermissionCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.PermissionResponse;
import com.hau.identity_service.service.PermissionService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/permissions")
@RequiredArgsConstructor
public class PermissionController {
    private final PermissionService permissionService;

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public ResponseEntity<ApiResponse<PermissionResponse>> createPermission(
            @RequestBody @Valid PermissionCreationRequest permissionCreationRequest) {
        ApiResponse<PermissionResponse> apiResponse = permissionService.createPermission(permissionCreationRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping
    public ResponseEntity<ApiResponse<List<PermissionResponse>>> getAllPermissions() {
        ApiResponse<List<PermissionResponse>> apiResponse = permissionService.getAllPermissions();
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{name}")
    public ResponseEntity<ApiResponse<PermissionResponse>> deletePermission(@PathVariable String name) {
        ApiResponse<PermissionResponse> apiResponse = permissionService.deletePermission(name);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== identity_service/controller/RoleController.java ===== */
package com.hau.identity_service.controller;

import java.util.List;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.RoleCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.RoleResponse;
import com.hau.identity_service.service.RoleService;

import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@RequestMapping("/roles")
public class RoleController {
    private final RoleService roleService;

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public ResponseEntity<ApiResponse<RoleResponse>> createRole(@RequestBody @Valid RoleCreationRequest roleRequest) {
        ApiResponse<RoleResponse> apiResponse = roleService.createRole(roleRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping
    public ResponseEntity<ApiResponse<List<RoleResponse>>> getAllRoles() {
        ApiResponse<List<RoleResponse>> apiResponse = roleService.getAllRoles();
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{name}")
    public ResponseEntity<ApiResponse<RoleResponse>> deleteRole(@PathVariable String name) {
        ApiResponse<RoleResponse> apiResponse = roleService.deleteRole(name);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== identity_service/controller/UserController.java ===== */
package com.hau.identity_service.controller;

import jakarta.validation.Valid;

import org.springframework.data.domain.Page;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.ChangePasswordRequest;
import com.hau.identity_service.dto.request.UserCreateRequest;
import com.hau.identity_service.dto.request.UserUpdateInfoRequest;
import com.hau.identity_service.dto.request.UserUpdateRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.UserResponse;
import com.hau.identity_service.service.UserService;

import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@RequestMapping("/users")
public class UserController {
    private final UserService userService;

    @PostMapping
    public ResponseEntity<ApiResponse<UserResponse>> createUser(
            @Valid @RequestBody UserCreateRequest userCreateRequest) {
        ApiResponse<UserResponse> userResponse = userService.createUser(userCreateRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.CREATED);
    }

    @PreAuthorize("hasRole('ADMIN') or @userService.isOwnerOfUser(#userId, authentication)")
    @GetMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> getUserById(@PathVariable Long userId) {
        ApiResponse<UserResponse> userResponse = userService.getUserById(userId);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @GetMapping("/info")
    public ResponseEntity<ApiResponse<UserResponse>> myInfo() {
        ApiResponse<UserResponse> userResponse = userService.myInfo();
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @PutMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> updateUser(
            @PathVariable Long userId, @Valid @RequestBody UserUpdateRequest userUpdateRequest) {
        ApiResponse<UserResponse> userResponse = userService.updateUser(userId, userUpdateRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or @userService.isOwnerOfUser(#userId, authentication)")
    @PutMapping("/{userId}/info")
    public ResponseEntity<ApiResponse<UserResponse>> updateUserInfo(
            @PathVariable Long userId, @Valid @RequestBody UserUpdateInfoRequest userUpdateInfoRequest) {
        ApiResponse<UserResponse> userResponse = userService.updateUserInfo(userId, userUpdateInfoRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or @userService.isOwnerOfUser(#userId, authentication)")
    @PatchMapping("/{userId}/password")
    public ResponseEntity<ApiResponse<UserResponse>> updatePassword(
            @PathVariable Long userId, @RequestBody @Valid ChangePasswordRequest changePasswordRequest) {
        ApiResponse<UserResponse> userResponse = userService.changePassword(userId, changePasswordRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Page<UserResponse>> getAllUsers(
            @RequestParam(required = false, defaultValue = "0") int pageIndex,
            @RequestParam(required = false, defaultValue = "10") int pageSize,
            @RequestParam(required = false) String username,
            @RequestParam(required = false) Integer gender) {
        Page<UserResponse> userPage = userService.getAllUsers(pageIndex, pageSize, username, gender);
        return new ResponseEntity<>(userPage, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> deleteUser(@PathVariable Long userId) {
        ApiResponse<UserResponse> userResponse = userService.deleteUser(userId);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }
}


/* ===== identity_service/dto/request/AuthenticationRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthenticationRequest {
    @NotBlank(message = "Tên đăng nhập không được để trống")
    private String username;

    @NotBlank(message = "Mật khẩu không được để trống")
    private String password;
}


/* ===== identity_service/dto/request/CartCreateRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartCreateRequest {
    private Integer userId;
}


/* ===== identity_service/dto/request/ChangePasswordRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ChangePasswordRequest {
    @NotBlank(message = "Mật khẩu cũ không được để trống")
    private String oldPassword;

    @NotBlank(message = "Mật khẩu mới không được để trống")
    private String newPassword;
}


/* ===== identity_service/dto/request/ForgotPasswordRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ForgotPasswordRequest {
    @NotBlank(message = "Tên đăng nhập không được để trống")
    private String username;
}


/* ===== identity_service/dto/request/IntrospectRequest.java ===== */
package com.hau.identity_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IntrospectRequest {
    private String token;
}


/* ===== identity_service/dto/request/LogoutRequest.java ===== */
package com.hau.identity_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LogoutRequest {
    private String token;
}


/* ===== identity_service/dto/request/PermissionCreationRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PermissionCreationRequest {
    @NotBlank(message = "Tên quyền không được để trống")
    private String name;

    private String description;
}


/* ===== identity_service/dto/request/RefreshTokenRequest.java ===== */
package com.hau.identity_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RefreshTokenRequest {
    private String token;
}


/* ===== identity_service/dto/request/ResetPasswordWithTokenRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ResetPasswordWithTokenRequest {
    @NotBlank(message = "Mật khẩu không được để trống")
    @Size(min = 6, message = "Mật khẩu phải có ít nhất 6 ký tự")
    private String newPassword;

    @NotBlank(message = "Mã xác nhận không được để trống")
    private String verificationToken;
}


/* ===== identity_service/dto/request/RoleCreationRequest.java ===== */
package com.hau.identity_service.dto.request;

import java.util.Set;

import jakarta.validation.constraints.NotBlank;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleCreationRequest {
    @NotBlank(message = "Tên vai trò không được để trống")
    private String name;

    private String description;
    private Set<String> permissions;
}


/* ===== identity_service/dto/request/UserCreateRequest.java ===== */
package com.hau.identity_service.dto.request;

import java.util.Set;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserCreateRequest {
    @NotBlank(message = "Username không được để trống")
    @Pattern(regexp = "^[a-z0-9]+$", message = "Username chỉ được chứa chữ cái thường và không có ký tự đặc biệt")
    private String username;

    @Size(min = 6, message = "Password phải có ít nhất 6 ký tự")
    private String password;

    @Email(message = "Email không đúng định dạng")
    @NotBlank(message = "Email không được để trống")
    private String email;
    private String profileImage;
    private Integer userId;
    private Set<String> roles;
}


/* ===== identity_service/dto/request/UserUpdateInfoRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserUpdateInfoRequest {
    @NotBlank(message = "Email không được để trống")
    @Email(message = "Email không đúng định dạng")
    private String email;

    @Pattern(regexp = "^[0-9]{10}$", message = "Số điện thoại phải có 10 chữ số")
    private String phone;

    private String address;
    private String profileImage;
    private Integer gender;
}


/* ===== identity_service/dto/request/UserUpdateRequest.java ===== */
package com.hau.identity_service.dto.request;

import java.util.Set;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserUpdateRequest {
    @Size(min = 6, message = "Password phải có ít nhất 6 ký tự")
    private String password;

    @NotBlank(message = "Email không được để trống")
    @Email(message = "Email không đúng định dạng")
    private String email;

    private String profileImage;
    private Set<String> roles;
}


/* ===== identity_service/dto/request/VerifyOtpRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class VerifyOtpRequest {
    @NotBlank(message = "Username không được để trống")
    private String username;

    private int otp;
}


/* ===== identity_service/dto/response/ApiResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== identity_service/dto/response/AuthenticationResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthenticationResponse {
    private boolean authenticated;
    private String token;
}


/* ===== identity_service/dto/response/CartResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartResponse {
    private Integer userId;
}


/* ===== identity_service/dto/response/ErrorsResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== identity_service/dto/response/IntrospectResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IntrospectResponse {
    private boolean valid;
    private String username;
}


/* ===== identity_service/dto/response/PermissionResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PermissionResponse {
    private String name;
    private String description;
}


/* ===== identity_service/dto/response/RoleResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.util.Set;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleResponse {
    private String name;
    private String description;
    private Set<PermissionResponse> permissions;
}


/* ===== identity_service/dto/response/UserResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.util.Set;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponse {
    private String id;
    private String username;
    private String email;
    private String phone;
    private String address;
    private String profileImage;
    private Integer gender;
    private Set<RoleResponse> roles;
}


/* ===== identity_service/dto/response/VerifyOtpResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class VerifyOtpResponse {
    private String verificationToken;
}


/* ===== identity_service/entity/InvalidatedToken.java ===== */
package com.hau.identity_service.entity;

import java.util.Date;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

import lombok.*;

@Builder
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "invalidated_token")
public class InvalidatedToken {
    @Id
    private String id;

    private Date expiryDate;
}


/* ===== identity_service/entity/Permission.java ===== */
package com.hau.identity_service.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "permissions")
public class Permission {
    @Id
    private String name;

    private String description;
}


/* ===== identity_service/entity/Role.java ===== */
package com.hau.identity_service.entity;

import java.util.Set;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;

import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "roles")
public class Role {
    @Id
    private String name;

    private String description;

    @ManyToMany
    Set<Permission> permissions;
}


/* ===== identity_service/entity/User.java ===== */
package com.hau.identity_service.entity;

import java.time.LocalDateTime;
import java.util.Set;

import jakarta.persistence.*;

import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(unique = true, length = 50)
    private String username;
    private String password;
    private String email;
    private String profileImage;

    @ManyToMany
    private Set<Role> roles;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @UpdateTimestamp
    private LocalDateTime updatedAt;
}


/* ===== identity_service/exception/AppException.java ===== */
package com.hau.identity_service.exception;

import java.time.LocalDateTime;

import org.springframework.http.HttpStatus;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== identity_service/exception/GlobalExceptionHandler.java ===== */
package com.hau.identity_service.exception;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import com.hau.identity_service.dto.response.ErrorsResponse;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== identity_service/IdentityServiceApplication.java ===== */
package com.hau.identity_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableAsync
@EnableScheduling
@EnableFeignClients
public class IdentityServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(IdentityServiceApplication.class, args);
    }
}


/* ===== identity_service/mapper/CartMapper.java ===== */
package com.hau.identity_service.mapper;

import com.hau.identity_service.dto.request.CartCreateRequest;
import com.hau.identity_service.dto.request.UserCreateRequest;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface CartMapper {
    CartCreateRequest toCartCreateRequest(UserCreateRequest userCreateRequest);
}


/* ===== identity_service/mapper/PermissionMapper.java ===== */
package com.hau.identity_service.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.NullValuePropertyMappingStrategy;

import com.hau.identity_service.dto.request.PermissionCreationRequest;
import com.hau.identity_service.dto.response.PermissionResponse;
import com.hau.identity_service.entity.Permission;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface PermissionMapper {
    Permission toPermission(PermissionCreationRequest permissionCreationRequest);

    PermissionResponse toPermissionResponse(Permission permission);
}


/* ===== identity_service/mapper/RoleMapper.java ===== */
package com.hau.identity_service.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.NullValuePropertyMappingStrategy;

import com.hau.identity_service.dto.request.RoleCreationRequest;
import com.hau.identity_service.dto.response.RoleResponse;
import com.hau.identity_service.entity.Role;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface RoleMapper {
    @Mapping(target = "permissions", ignore = true)
    Role toRole(RoleCreationRequest roleCreationRequest);

    RoleResponse toRoleResponse(Role role);
}


/* ===== identity_service/mapper/UserMapper.java ===== */
package com.hau.identity_service.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;

import com.hau.identity_service.dto.request.UserCreateRequest;
import com.hau.identity_service.dto.request.UserUpdateInfoRequest;
import com.hau.identity_service.dto.request.UserUpdateRequest;
import com.hau.identity_service.dto.response.UserResponse;
import com.hau.identity_service.entity.User;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface UserMapper {
    @Mapping(target = "roles", ignore = true)
    User toUser(UserCreateRequest userCreateRequest);

    @Mapping(target = "roles", ignore = true)
    void toUserUpdateRequest(@MappingTarget User user, UserUpdateRequest userUpdateRequest);

    void toUserUpdateInfoRequest(@MappingTarget User user, UserUpdateInfoRequest userUpdateInfoRequest);

    UserResponse toUserResponse(User user);
}


/* ===== identity_service/repository/CartServiceClient.java ===== */
package com.hau.identity_service.repository;

import com.hau.identity_service.dto.request.CartCreateRequest;
import com.hau.identity_service.dto.response.CartResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "cart-service", url = "${app.cart-service.url}")
public interface CartServiceClient {
    @PostMapping(value = "/internal/cart",produces = MediaType.APPLICATION_JSON_VALUE)
    CartResponse createCart(@RequestBody CartCreateRequest cartCreateRequest);
}


/* ===== identity_service/repository/InvalidatedTokenRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.hau.identity_service.entity.InvalidatedToken;

public interface InvalidatedTokenRepository extends JpaRepository<InvalidatedToken, String> {
    List<InvalidatedToken> findByExpiryDateLessThanEqual(Date expiryDate);
}


/* ===== identity_service/repository/PermissionRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import com.hau.identity_service.entity.Permission;

@Repository
public interface PermissionRepository extends JpaRepository<Permission, String>, JpaSpecificationExecutor<Permission> {
    Optional<Permission> findByName(String name);
}


/* ===== identity_service/repository/RoleRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import com.hau.identity_service.entity.Role;

@Repository
public interface RoleRepository extends JpaRepository<Role, String>, JpaSpecificationExecutor<Role> {
    Optional<Role> findByName(String name);
}


/* ===== identity_service/repository/UserRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import com.hau.identity_service.entity.User;

@Repository
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
    Optional<User> findByUsername(String username);
}


/* ===== identity_service/service/AuthenticationService.java ===== */
package com.hau.identity_service.service;

import java.text.ParseException;
import java.time.LocalDateTime;
import java.util.Date;

import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.request.AuthenticationRequest;
import com.hau.identity_service.dto.request.IntrospectRequest;
import com.hau.identity_service.dto.request.LogoutRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.AuthenticationResponse;
import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.entity.InvalidatedToken;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.repository.InvalidatedTokenRepository;
import com.hau.identity_service.repository.UserRepository;
import com.nimbusds.jose.*;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
@Service
@Slf4j
public class AuthenticationService {
    private final UserRepository userRepository;
    private final InvalidatedTokenRepository invalidatedTokenRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenService tokenService;


    public ApiResponse<AuthenticationResponse> authenticate(AuthenticationRequest authenticationRequest) {
        User user = userRepository
                .findByUsername(authenticationRequest.getUsername())
                .orElse(null);

        if (user == null || !passwordEncoder.matches(authenticationRequest.getPassword(), user.getPassword())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Tên đăng nhập hoặc mật khẩu không chính xác", null);
        }

        String token;
        try {
            token = tokenService.generateToken(user);
        } catch (JOSEException e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi tạo token", e);
        }

        return ApiResponse.<AuthenticationResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Đăng nhập thành công")
                .result(AuthenticationResponse.builder()
                        .authenticated(true)
                        .token(token)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<Void> logout(LogoutRequest logoutRequest) throws ParseException {
        var signToken = tokenService.verifyToken(logoutRequest.getToken(), true);
        String jit = signToken.getJWTClaimsSet().getJWTID();
        Date expiryTime = signToken.getJWTClaimsSet().getExpirationTime();

        InvalidatedToken invalidatedToken =
                InvalidatedToken.builder().id(jit).expiryDate(expiryTime).build();
        invalidatedTokenRepository.save(invalidatedToken);
        return ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Đăng xuất thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<IntrospectResponse> introspect(IntrospectRequest introspectRequest) {
        String token = introspectRequest.getToken();

        if (token == null || token.isEmpty()) {
            return buildErrorResponse("Token không được cung cấp");
        }

        try {
            // Sử dụng TokenService thay vì logic tại chỗ
            IntrospectResponse result = tokenService.validateToken(token);

            if (result.isValid()) {
                return ApiResponse.<IntrospectResponse>builder()
                        .status(HttpStatus.OK.value())
                        .message("Token hợp lệ")
                        .result(result)
                        .timestamp(LocalDateTime.now())
                        .build();
            } else {
                return buildErrorResponse("Token không hợp lệ");
            }
        } catch (Exception e) {
            return buildErrorResponse(e.getMessage());
        }
    }

    private ApiResponse<IntrospectResponse> buildErrorResponse(String message) {
        return ApiResponse.<IntrospectResponse>builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .message(message)
                .result(IntrospectResponse.builder().valid(false).build())
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity_service/service/EmailService.java ===== */
package com.hau.identity_service.service;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;

import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailService {

    private final JavaMailSender javaMailSender;
    private final TemplateEngine templateEngine;

    @Async
    public void sendHtmlEmail(String to, String subject, String templateName, Context context) {
        log.info("Đang gửi email tới {}", to);
        MimeMessage mimeMessage = javaMailSender.createMimeMessage();
        try {
            MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, "UTF-8");
            helper.setTo(to);
            helper.setSubject(subject);
            String htmlContent = templateEngine.process(templateName, context);
            helper.setText(htmlContent, true);
            javaMailSender.send(mimeMessage);
            log.info("Async Email '{}' gửi thành công tới {}", subject, to);
        } catch (MessagingException e) {
            log.error("Async Email gửi không thành công từ '{}' đến {}: {}", subject, to, e.getMessage(), e);
        } catch (Exception e) {
            log.error("Đã xảy ra lỗi khi gửi email từ '{}' đến {}: {}", subject, to, e.getMessage(), e);
        }
    }
}


/* ===== identity_service/service/ForgotPasswordService.java ===== */
package com.hau.identity_service.service;

import java.text.ParseException;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.thymeleaf.context.Context;

import com.hau.identity_service.dto.request.ForgotPasswordRequest;
import com.hau.identity_service.dto.request.ResetPasswordWithTokenRequest;
import com.hau.identity_service.dto.request.VerifyOtpRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.VerifyOtpResponse;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.repository.UserRepository;
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class ForgotPasswordService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final EmailService emailService;

    @Value("${jwt.signerKey}")
    private String signerKey;

    @Value("${jwt.issuer}")
    private String issuer;

    @Value("${jwt.passwordResetTokenExpiryMinutes}")
    private long passwordResetTokenExpiryMinutes;

    @Value("${jwt.otpExpiryMinutes}")
    private long otpExpiryMinutes;

    @Value("${jwt.otpRequestCooldownMinutes}")
    private long otpRequestCooldownMinutes;

    private static final Random random = new Random();
    private static final String PURPOSE_CLAIM = "purpose";
    private static final String PURPOSE_VALUE = "PASSWORD_RESET";

    private final Map<String, String> otpCache = new ConcurrentHashMap<>();
    private final Map<String, LocalDateTime> otpExpiryCache = new ConcurrentHashMap<>();

    private final Map<String, LocalDateTime> otpRequestTimestamps = new ConcurrentHashMap<>();

    private final Map<String, LocalDateTime> usedResetTokens = new ConcurrentHashMap<>();

    public ApiResponse<String> sendOtp(ForgotPasswordRequest forgotPasswordRequest) {
        String username = forgotPasswordRequest.getUsername();

        // --- Rate Limiting Check ---
        LocalDateTime lastRequestTime = otpRequestTimestamps.get(username);
        LocalDateTime now = LocalDateTime.now();
        if (lastRequestTime != null) {
            Duration timeSinceLastRequest = Duration.between(lastRequestTime, now);
            if (timeSinceLastRequest.toMinutes() < otpRequestCooldownMinutes) {
                long waitMinutes = otpRequestCooldownMinutes - timeSinceLastRequest.toMinutes();
                log.warn("Rate limit hit for OTP request by user: {}. Wait {} more minute(s).", username, waitMinutes);
                return ApiResponse.<String>builder()
                        .status(HttpStatus.TOO_MANY_REQUESTS.value())
                        .message("Bạn vừa yêu cầu OTP gần đây. Vui lòng đợi " + waitMinutes
                                + " phút nữa trước khi thử lại.")
                        .result(null)
                        .timestamp(now)
                        .build();
            }
        }
        // --- End Rate Limiting Check ---

        User user = userRepository
                .findByUsername(username)
                .orElseThrow(() -> new AppException(
                        HttpStatus.NOT_FOUND, "Không tìm thấy người dùng với username: " + username, null));

        String otp = generateOtp();
        otpCache.put(username, otp);
        otpExpiryCache.put(username, now.plusMinutes(otpExpiryMinutes));

        log.info("Generated OTP for user {}. Triggering async email.", username);

        Context context = new Context();
        context.setVariable("username", username);
        context.setVariable("otp", otp);
        context.setVariable("expiryMinutes", otpExpiryMinutes);

        String emailSubject = "Mã OTP xác thực quên mật khẩu";
        String templateName = "otp-email-template";

        emailService.sendHtmlEmail(user.getEmail(), emailSubject, templateName, context);

        // Update the timestamp *after* successfully processing the request
        otpRequestTimestamps.put(username, now);

        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Yêu cầu gửi OTP đã được xử lý. Vui lòng kiểm tra email của bạn.")
                .result(null)
                .timestamp(now)
                .build();
    }

    public ApiResponse<VerifyOtpResponse> verifyOtp(VerifyOtpRequest verifyOtpRequest) {
        // Extract username from the request body DTO
        String username = verifyOtpRequest.getUsername();
        int otp = verifyOtpRequest.getOtp(); // Get OTP from request

        String cachedOtp = otpCache.get(username);
        LocalDateTime expiryTime = otpExpiryCache.get(username);
        LocalDateTime now = LocalDateTime.now();

        // --- Logic using the extracted username ---
        if (cachedOtp == null) {
            log.warn("Verify OTP attempt for user '{}' failed: No OTP found in cache.", username);
            return buildVerifyOtpErrorResponse("OTP không hợp lệ hoặc chưa được yêu cầu. Vui lòng thử lại.");
        }

        if (expiryTime != null && now.isAfter(expiryTime)) {
            log.warn("Verify OTP attempt for user '{}' failed: OTP expired.", username);
            otpCache.remove(username);
            otpExpiryCache.remove(username);
            return buildVerifyOtpErrorResponse("OTP đã hết hạn. Vui lòng yêu cầu OTP mới.");
        }

        if (!cachedOtp.equals(String.valueOf(otp))) {
            log.warn("Verify OTP attempt for user '{}' failed: Incorrect OTP.", username);
            // Consider adding rate limiting for failed attempts here
            return buildVerifyOtpErrorResponse("OTP không chính xác. Vui lòng thử lại.");
        }
        // --- End Logic ---

        // OTP is correct, remove it from cache
        otpCache.remove(username);
        otpExpiryCache.remove(username);
        log.info("OTP successfully verified for user '{}'.", username);

        // Generate Password Reset JWT
        String passwordResetToken;
        try {
            passwordResetToken = generatePasswordResetToken(username); // Pass username to token generation
            log.info("Generated password reset JWT for user {}", username);
        } catch (JOSEException e) {
            log.error("Error generating password reset JWT for user {}: {}", username, e.getMessage());
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi tạo mã xác nhận đặt lại mật khẩu", e);
        }

        return ApiResponse.<VerifyOtpResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xác thực OTP thành công. Mã xác nhận đặt lại mật khẩu đã được tạo.")
                .result(VerifyOtpResponse.builder()
                        .verificationToken(passwordResetToken)
                        .build())
                .timestamp(now)
                .build();
    }

    public ApiResponse<String> resetPassword(ResetPasswordWithTokenRequest resetPasswordWithTokenRequest) {
        String verificationToken = resetPasswordWithTokenRequest.getVerificationToken();
        String username;
        String jti; // JWT ID
        Date tokenExpiry;

        JWTClaimsSet claimsSet;
        try {
            claimsSet = validatePasswordResetToken(verificationToken); // Validation now includes blacklist check
            username = claimsSet.getSubject();
            jti = claimsSet.getJWTID(); // Get JTI
            tokenExpiry = claimsSet.getExpirationTime(); // Get expiry for blacklist

            if (username == null || username.trim().isEmpty() || jti == null || tokenExpiry == null) {
                log.error("Validated password reset token is missing critical claims (sub, jti, or exp).");
                throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi xử lý mã xác nhận.", null);
            }
        } catch (AppException e) {
            return ApiResponse.<String>builder()
                    .status(e.getHttpStatus().value())
                    .message(e.getMessage())
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        } catch (Exception e) {
            log.error("Unexpected error processing password reset token: {}", e.getMessage(), e);
            return ApiResponse.<String>builder()
                    .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                    .message("Lỗi không xác định khi xử lý mã đặt lại mật khẩu.")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        }

        User user = userRepository.findByUsername(username).orElseThrow(() -> {
            log.error("User '{}' not found after successful token validation (JTI: {}).", username, jti);
            return new AppException(
                    HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi không mong đợi: Không tìm thấy người dùng.", null);
        });

        user.setPassword(passwordEncoder.encode(resetPasswordWithTokenRequest.getNewPassword()));
        userRepository.save(user);

        // --- Add token JTI to blacklist after successful password reset ---
        // Store with original expiry time to allow potential cleanup later
        usedResetTokens.put(
                jti,
                tokenExpiry.toInstant().atZone(java.time.ZoneId.systemDefault()).toLocalDateTime());
        log.info("Password successfully reset for user {}. Token JTI {} blacklisted.", username, jti);
        // Note: In a production/scaled environment, consider a more robust blacklist (e.g., Redis with TTL)
        // and a cleanup mechanism for the in-memory map if used long-term.
        // --- End blacklist update ---

        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Mật khẩu đã được đặt lại thành công.")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    // --- Helper Methods ---

    private String generatePasswordResetToken(String username) throws JOSEException {
        JWSHeader jwsHeader = new JWSHeader(JWSAlgorithm.HS512);
        JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder()
                .subject(username)
                .issuer(issuer)
                .issueTime(new Date())
                .expirationTime(new Date(Instant.now()
                        .plus(passwordResetTokenExpiryMinutes, ChronoUnit.MINUTES)
                        .toEpochMilli()))
                .claim(PURPOSE_CLAIM, PURPOSE_VALUE)
                .jwtID(UUID.randomUUID().toString()) // Ensure unique JTI is generated
                .build();

        Payload payload = new Payload(jwtClaimsSet.toJSONObject());
        JWSObject jwsObject = new JWSObject(jwsHeader, payload);
        jwsObject.sign(new MACSigner(signerKey.getBytes()));
        return jwsObject.serialize();
    }

    private JWTClaimsSet validatePasswordResetToken(String token) throws ParseException, JOSEException, AppException {
        SignedJWT signedJWT = SignedJWT.parse(token);
        JWSVerifier verifier = new MACVerifier(signerKey.getBytes());

        boolean signatureValid = signedJWT.verify(verifier);
        if (!signatureValid) {
            log.warn("Invalid password reset token signature received.");
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (chữ ký sai).", null);
        }

        JWTClaimsSet claimsSet = signedJWT.getJWTClaimsSet();
        String jti = claimsSet.getJWTID();
        String tokenUsername = claimsSet.getSubject(); // Get username for logging context

        // --- Check Blacklist (Single-Use) ---
        if (jti != null && usedResetTokens.containsKey(jti)) {
            log.warn("Attempt to reuse already used password reset token. User: {}, JTI: {}", tokenUsername, jti);
            // Consider 409 Conflict, but 400 is also common.
            throw new AppException(
                    HttpStatus.BAD_REQUEST,
                    "Mã xác nhận đã được sử dụng. Vui lòng thực hiện lại quy trình quên mật khẩu.",
                    null);
        }
        // --- End Blacklist Check ---

        Date expirationTime = claimsSet.getExpirationTime();
        if (expirationTime == null || expirationTime.before(new Date())) {
            log.info("Expired password reset token used (User: {}, JTI: {}).", tokenUsername, jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận đã hết hạn.", null);
        }

        String tokenIssuer = claimsSet.getIssuer();
        if (tokenIssuer == null || !tokenIssuer.equals(issuer)) {
            log.warn(
                    "Invalid issuer in password reset token. User: {}, Expected: {}, Found: {}. JTI: {}",
                    tokenUsername,
                    issuer,
                    tokenIssuer,
                    jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (issuer sai).", null);
        }

        String purpose = claimsSet.getStringClaim(PURPOSE_CLAIM);
        if (!PURPOSE_VALUE.equals(purpose)) {
            log.warn(
                    "Incorrect purpose claim in token. User: {}, Expected: {}, Found: {}. JTI: {}",
                    tokenUsername,
                    PURPOSE_VALUE,
                    purpose,
                    jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (mục đích sai).", null);
        }

        if (tokenUsername == null || tokenUsername.trim().isEmpty()) {
            log.warn("Password reset token is missing the subject (username) claim. JTI: {}", jti);
            throw new AppException(
                    HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (thiếu thông tin người dùng).", null);
        }

        Date issueTime = claimsSet.getIssueTime();
        if (issueTime != null && issueTime.after(new Date())) {
            log.warn("Password reset token used before issue time for user {}. JTI: {}", tokenUsername, jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận chưa có hiệu lực.", null);
        }

        if (jti == null) {
            // Should not happen if generation includes it, but check defensively.
            log.error("Password reset token is missing the JTI claim. User: {}", tokenUsername);
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi xử lý mã xác nhận (thiếu JTI).", null);
        }

        log.info("Password reset token successfully validated for user {}", tokenUsername);
        return claimsSet;
    }

    private String generateOtp() {
        int otpValue = 100000 + random.nextInt(900000);
        return String.valueOf(otpValue);
    }

    private ApiResponse<VerifyOtpResponse> buildVerifyOtpErrorResponse(String message) {
        return ApiResponse.<VerifyOtpResponse>builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .message(message)
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity_service/service/PermissionService.java ===== */
package com.hau.identity_service.service;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.request.PermissionCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.PermissionResponse;
import com.hau.identity_service.entity.Permission;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.mapper.PermissionMapper;
import com.hau.identity_service.repository.PermissionRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class PermissionService {

    private final PermissionRepository permissionRepository;
    private final PermissionMapper permissionMapper;

    public ApiResponse<PermissionResponse> createPermission(PermissionCreationRequest permissionCreationRequest) {
        Permission permission = permissionMapper.toPermission(permissionCreationRequest);
        permissionRepository.save(permission);
        return ApiResponse.<PermissionResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo mới quyền thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<PermissionResponse>> getAllPermissions() {
        List<Permission> permissions = permissionRepository.findAll();
        List<PermissionResponse> permissionResponses =
                permissions.stream().map(permissionMapper::toPermissionResponse).toList();
        return ApiResponse.<List<PermissionResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách quyền thành công")
                .result(permissionResponses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<PermissionResponse> deletePermission(String name) {
        Permission permission = permissionRepository
                .findByName(name)
                .orElseThrow(
                        () -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy quyền với tên: " + name, null));
        permissionRepository.delete(permission);
        return ApiResponse.<PermissionResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa quyền thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity_service/service/RoleService.java ===== */
package com.hau.identity_service.service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.hau.identity_service.dto.request.RoleCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.RoleResponse;
import com.hau.identity_service.entity.Role;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.mapper.RoleMapper;
import com.hau.identity_service.repository.PermissionRepository;
import com.hau.identity_service.repository.RoleRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class RoleService {
    private final RoleRepository roleRepository;
    private final PermissionRepository permissionRepository;
    private final RoleMapper roleMapper;

    public ApiResponse<RoleResponse> createRole(RoleCreationRequest request) {
        var role = roleMapper.toRole(request);
        var permissionIds = request.getPermissions();
        var permissions = permissionRepository.findAllById(permissionIds);
        if (CollectionUtils.isEmpty(permissions)) {
            return ApiResponse.<RoleResponse>builder()
                    .status(HttpStatus.BAD_REQUEST.value())
                    .message("Không tìm thấy permission nào")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        }
        role.setPermissions(new HashSet<>(permissions));
        roleRepository.save(role);
        return ApiResponse.<RoleResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo role thành công")
                .result(roleMapper.toRoleResponse(role))
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<RoleResponse>> getAllRoles() {
        List<Role> roles = roleRepository.findAll();
        List<RoleResponse> roleResponses =
                roles.stream().map(roleMapper::toRoleResponse).toList();
        return ApiResponse.<List<RoleResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách role thành công")
                .result(roleResponses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<RoleResponse> deleteRole(String name) {
        Role role = roleRepository
                .findByName(name)
                .orElseThrow(
                        () -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy role với tên: " + name, null));
        roleRepository.delete(role);
        return ApiResponse.<RoleResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa role thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity_service/service/TokenService.java ===== */
package com.hau.identity_service.service;

import java.text.ParseException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;
import java.util.StringJoiner;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.hau.identity_service.dto.request.RefreshTokenRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.AuthenticationResponse;
import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.entity.InvalidatedToken;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.repository.InvalidatedTokenRepository;
import com.hau.identity_service.repository.UserRepository;
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class TokenService {

    @Value("${jwt.signerKey}")
    private String signerKey;

    @Value("${jwt.issuer}")
    private String issuer;

    @Value("${jwt.expirationMinutes}")
    private Long expiration;

    @Value("${jwt.expirationRefreshMinutes}")
    private Long expirationRefresh;

    private final InvalidatedTokenRepository invalidatedTokenRepository;
    private final UserRepository userRepository;

    private JWTClaimsSet validateTokenClaims(String token, boolean isRefresh) throws AppException {
        try {
            JWSVerifier verifier = new MACVerifier(signerKey.getBytes());
            SignedJWT signedJWT = SignedJWT.parse(token);
            JWTClaimsSet claimsSet = signedJWT.getJWTClaimsSet();

            if (!signedJWT.verify(verifier)) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Chữ ký token không hợp lệ", null);
            }

            Date expirationTime = (isRefresh)
                    ? new Date(claimsSet
                            .getIssueTime()
                            .toInstant()
                            .plus(expirationRefresh, ChronoUnit.MINUTES)
                            .toEpochMilli())
                    : claimsSet.getExpirationTime();

            if (expirationTime == null || expirationTime.before(new Date())) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token đã hết hạn", null);
            }

            if (claimsSet.getIssuer() == null || !claimsSet.getIssuer().equals(issuer)) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token issuer không hợp lệ", null);
            }

            if (claimsSet.getIssueTime() != null && claimsSet.getIssueTime().after(new Date())) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token chưa có hiệu lực", null);
            }

            if (invalidatedTokenRepository.existsById(claimsSet.getJWTID())) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token đã hết hiệu lực", null);
            }

            return claimsSet;

        } catch (ParseException | JOSEException e) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Token không hợp lệ", null);
        }
    }

    public SignedJWT verifyToken(String token, boolean isRefresh) throws AppException {
        try {
            validateTokenClaims(token, isRefresh);
            return SignedJWT.parse(token);
        } catch (ParseException e) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Token không hợp lệ", null);
        }
    }

    public IntrospectResponse validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return IntrospectResponse.builder().valid(false).build(); // Use the builder directly
        }
        try {
            JWTClaimsSet claimsSet = validateTokenClaims(token, false);
            return IntrospectResponse.builder()
                    .valid(true)
                    .username(claimsSet.getSubject())
                    .build();
        } catch (AppException e) {
            return IntrospectResponse.builder().valid(false).build(); // Consistent error handling
        }
    }

    public String generateToken(User user) throws JOSEException {
        JWSHeader jwsHeader = new JWSHeader(JWSAlgorithm.HS512);
        JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder()
                .subject(user.getUsername())
                .issuer(issuer)
                .issueTime(new Date())
                .expirationTime(new Date(
                        Instant.now().plus(expiration, ChronoUnit.MINUTES).toEpochMilli()))
                .claim("scope", buildScope(user))
                .jwtID(UUID.randomUUID().toString())
                .build();

        Payload payload = new Payload(jwtClaimsSet.toJSONObject());
        JWSObject jwsObject = new JWSObject(jwsHeader, payload);
        jwsObject.sign(new MACSigner(signerKey.getBytes()));
        return jwsObject.serialize();
    }

    public ApiResponse<AuthenticationResponse> refreshToken(RefreshTokenRequest refreshTokenRequest)
            throws JOSEException, ParseException {
        SignedJWT signedJWT = verifyToken(refreshTokenRequest.getToken(), true);

        String jwtId = signedJWT.getJWTClaimsSet().getJWTID();
        Date expiryTime = signedJWT.getJWTClaimsSet().getExpirationTime();

        invalidatedTokenRepository.save(
                InvalidatedToken.builder().id(jwtId).expiryDate(expiryTime).build());

        String username = signedJWT.getJWTClaimsSet().getSubject();
        log.info("Refresh token for user: {}", username);
        User user = userRepository
                .findByUsername(username)
                .orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Người dùng không tồn tại", null));

        String token = generateToken(user);
        log.info("Refresh token: {}", token);

        return ApiResponse.<AuthenticationResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Làm mới token thành công")
                .result(AuthenticationResponse.builder()
                        .authenticated(true)
                        .token(token)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }

    private String buildScope(User user) {
        StringJoiner stringJoiner = new StringJoiner(" ");
        if (!CollectionUtils.isEmpty(user.getRoles())) {
            user.getRoles().forEach(role -> {
                stringJoiner.add("ROLE_" + role.getName());
                if (!CollectionUtils.isEmpty(role.getPermissions())) {
                    role.getPermissions().forEach(permission -> stringJoiner.add(permission.getName()));
                }
            });
        }
        return stringJoiner.toString();
    }

    @Scheduled(fixedRate = 1440, timeUnit = TimeUnit.MINUTES)
    public void cleanupExpiredTokens() {
        LocalDateTime now = LocalDateTime.now();
        Date date = Date.from(now.atZone(ZoneId.systemDefault()).toInstant());
        List<InvalidatedToken> expiredTokens = invalidatedTokenRepository.findByExpiryDateLessThanEqual(date);
        invalidatedTokenRepository.deleteAll(expiredTokens);
        log.info("Cleaned up {} expired tokens.", expiredTokens.size()); // Use SLF4J
    }
}


/* ===== identity_service/service/UserService.java ===== */
package com.hau.identity_service.service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

import com.hau.identity_service.mapper.CartMapper;
import com.hau.identity_service.repository.CartServiceClient;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.request.ChangePasswordRequest;
import com.hau.identity_service.dto.request.UserCreateRequest;
import com.hau.identity_service.dto.request.UserUpdateInfoRequest;
import com.hau.identity_service.dto.request.UserUpdateRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.UserResponse;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.mapper.UserMapper;
import com.hau.identity_service.repository.RoleRepository;
import com.hau.identity_service.repository.UserRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
@Service
@Slf4j
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final UserMapper userMapper;
    private final CartMapper cartMapper;
    private final PasswordEncoder passwordEncoder;
    private final CartServiceClient cartServiceClient;

    public ApiResponse<UserResponse> createUser(UserCreateRequest userCreateRequest) {
        User user = userMapper.toUser(userCreateRequest);
        var roles = roleRepository.findAllById(Set.of("USER"));
        user.setRoles(new HashSet<>(roles));
        user.setPassword(passwordEncoder.encode(userCreateRequest.getPassword()));
        try {
            userRepository.save(user);
            var cartRequest = cartMapper.toCartCreateRequest(userCreateRequest);
            cartRequest.setUserId(user.getId());
            cartServiceClient.createCart(cartRequest);
            return ApiResponse.<UserResponse>builder()
                    .status(HttpStatus.CREATED.value())
                    .message("Tạo mới user thành công")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        } catch (DataIntegrityViolationException ex) {
            throw new AppException(HttpStatus.BAD_REQUEST, "username đã tồn tại", null);
        } catch (Exception feignException) {
            log.error("Lỗi khi tạo giỏ hàng cho user {}: {}", user.getUsername(), feignException.getMessage(), feignException);
        }
        return null;
    }

    public Page<UserResponse> getAllUsers(int pageIndex, int pageSize, String username, Integer gender) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();

        log.info("Username : {}", authentication.getName());
        authentication.getAuthorities().forEach(grantedAuthority -> log.info(grantedAuthority.getAuthority()));

        Specification<User> spec = Specification.where(null);

        if (username != null) {
            spec = spec.and(
                    (root, query, cb) -> cb.like(cb.lower(root.get("username")), "%" + username.toLowerCase() + "%"));
        }

        if (gender != null) {
            spec = spec.and((root, query, cb) -> cb.equal(root.get("gender"), gender));
        }

        Pageable pageable = PageRequest.of(pageIndex, pageSize);
        Page<User> userPage = userRepository.findAll(spec, pageable);

        return userPage.map(userMapper::toUserResponse);
    }

    public ApiResponse<UserResponse> myInfo() {
        var context = SecurityContextHolder.getContext();
        String username = context.getAuthentication().getName();

        User user = userRepository
                .findByUsername(username)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy user", null));
        UserResponse userResponse = userMapper.toUserResponse(user);

        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin user thành công")
                .result(userResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> getUserById(Long id) {
        User user = findUserById(id);
        UserResponse userResponse = userMapper.toUserResponse(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin user thành công")
                .result(userResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> updateUser(Long id, UserUpdateRequest userUpdateRequest) {
        User user = findUserById(id);
        userMapper.toUserUpdateRequest(user, userUpdateRequest);
        var roles = roleRepository.findAllById(userUpdateRequest.getRoles());
        user.setRoles(new HashSet<>(roles));
        user.setPassword(passwordEncoder.encode(userUpdateRequest.getPassword()));

        userRepository.save(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật thông tin user thành công")
                .result(userMapper.toUserResponse(user))
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> updateUserInfo(Long id, UserUpdateInfoRequest userUpdateInfoRequest) {
        User user = findUserById(id);
        userMapper.toUserUpdateInfoRequest(user, userUpdateInfoRequest);
        userRepository.save(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật thông tin user thành công")
                .result(userMapper.toUserResponse(user))
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> changePassword(Long id, ChangePasswordRequest changePasswordRequest) {
        User user = findUserById(id);
        if (!passwordEncoder.matches(changePasswordRequest.getOldPassword(), user.getPassword())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Mật khẩu cũ không đúng", null);
        }

        user.setPassword(passwordEncoder.encode(changePasswordRequest.getNewPassword()));
        userRepository.save(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Đổi mật khẩu thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> deleteUser(Long id) {
        User user = findUserById(id);
        userRepository.delete(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa user thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public User findUserById(Long id) {
        return userRepository
                .findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy user có id: " + id, null));
    }

    public boolean isOwnerOfUser(Long requestedUserId, Authentication authentication) {
        if (authentication == null || !authentication.isAuthenticated()) {
            return false;
        }
        String authenticatedUsername = authentication.getName();
        try {
            User requestedUser = findUserById(requestedUserId);
            return requestedUser.getUsername().equals(authenticatedUsername);
        } catch (AppException e) {
            log.warn("Không tìm thấy người dùng với ID: {}", requestedUserId);
            return false;
        }
    }
}




/* ===== identity-service\public\permissions.sql ===== */
create table permissions
(
    name        varchar(255) not null
        primary key,
    description varchar(255)
);

alter table permissions
    owner to postgres;



/* ===== identity-service\public\roles.sql ===== */
create table roles
(
    name        varchar(255) not null
        primary key,
    description varchar(255)
);

alter table roles
    owner to postgres;



/* ===== identity-service\public\roles_permissions.sql ===== */
create table roles_permissions
(
    role_name        varchar(255) not null
        constraint fk6nw4jrj1tuu04j9rk7xwfssd6
            references roles,
    permissions_name varchar(255) not null
        constraint fk9u1xpvjxbdnkca024o6fyr7uu
            references permissions,
    primary key (role_name, permissions_name)
);

alter table roles_permissions
    owner to postgres;



/* ===== identity-service\public\users.sql ===== */
create table users
(
    id            integer generated by default as identity
        primary key,
    address       varchar(255),
    created_at    varchar(255),
    email         varchar(255),
    gender        integer,
    password      varchar(255),
    phone         varchar(255),
    profile_image varchar(255),
    updated_at    varchar(255),
    username      varchar(255)
);

alter table users
    owner to postgres;



/* ===== identity-service\public\users_roles.sql ===== */
create table users_roles
(
    user_id    integer      not null
        constraint fk2o0jvgh89lemvvo17cbqvdxaa
            references users,
    roles_name varchar(255) not null
        constraint fkmi9sfx618v14gm89cyw408hqu
            references roles,
    primary key (user_id, roles_name)
);

alter table users_roles
    owner to postgres;



/* ===== identity-service\src\main\java\com\hau\event\dto\NotificationEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationEvent {
    private String channel;
    private String recipient;
    private String templateCode;
    private Map<String, Object> params;
}


/* ===== identity-service\src\main\java\com\hau\event\dto\UserCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCreateEvent {
    private Integer id;
    private String email;
    private String username;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\IdentityServiceApplication.java ===== */
package com.hau.identity_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
@EnableFeignClients
public class IdentityServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(IdentityServiceApplication.class, args);
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\config\ApplicationInitConfig.java ===== */
package com.hau.identity_service.config;

import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

import com.hau.identity_service.entity.Role;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.repository.RoleRepository;
import com.hau.identity_service.repository.UserRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
@Configuration
@Slf4j
public class ApplicationInitConfig {

    private final PasswordEncoder passwordEncoder;

    @Value("${admin.username}")
    private String adminUsername;

    @Value("${admin.password}")
    private String adminPassword;

    @Value("${admin.role}")
    private String adminRole;

    @Bean
    ApplicationRunner applicationRunner(UserRepository userRepository, RoleRepository roleRepository) {
        return args -> {
            if (roleRepository.findByName(adminRole).isEmpty()) {
                Role role = Role.builder()
                        .name(adminRole)
                        .description("Quyền quản trị viên")
                        .build();
                roleRepository.save(role);
                log.info("Role ADMIN đã được tạo.");
            }

            if (roleRepository.findByName("USER").isEmpty()) {
                Role userRole = Role.builder()
                        .name("USER")
                        .description("Quyền người dùng")
                        .build();
                roleRepository.save(userRole);
                log.info("Role USER đã được tạo.");
            }

            if (roleRepository.findByName("STAFF").isEmpty()) {
                Role userRole = Role.builder()
                        .name("STAFF")
                        .description("Quyền nhân viên")
                        .build();
                roleRepository.save(userRole);
                log.info("Role STAFF đã được tạo.");
            }

            if (userRepository.findByUsername(adminUsername).isEmpty()) {

                User user = User.builder()
                        .username(adminUsername)
                        .password(passwordEncoder.encode(adminPassword))
                        .email("datdnk3@gmail.com")
                        .build();
                var roles = roleRepository.findAllById(Set.of(adminRole));
                if (roles.isEmpty()) {
                    log.error("Không tìm thấy role ADMIN");
                    return;
                }
                user.setRoles(new HashSet<>(roles));
                userRepository.save(user);
                log.warn(
                        "Người dùng admin đã được tạo với mật khẩu là admin, hãy thay đổi mật khẩu ngay sau khi đăng nhập lần đầu tiên");
            }
        };
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\config\AuthenticationRequestInterceptor.java ===== */
package com.hau.identity_service.config;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
public class AuthenticationRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes servletRequestAttributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

        assert servletRequestAttributes != null;
        var authHeader = servletRequestAttributes.getRequest().getHeader("Authorization");
        log.info("Auth header: {}", authHeader);
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            requestTemplate.header("Authorization", authHeader);
        } else {
            log.warn("No Authorization header found in the request");
        }
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\config\CustomJwtDecoder.java ===== */
package com.hau.identity_service.config;

import java.text.ParseException;

import com.nimbusds.jwt.SignedJWT;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\config\FeignMultipartSupportConfig.java ===== */
package com.hau.identity_service.config;

import feign.codec.Encoder;
import feign.form.spring.SpringFormEncoder;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringEncoder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class FeignMultipartSupportConfig {
    @Bean
    public Encoder feignFormEncoder() {
        return new SpringFormEncoder(new SpringEncoder(() -> new HttpMessageConverters(new RestTemplate().getMessageConverters())));
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.identity_service.config;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.identity_service.dto.response.ApiResponse;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\config\SecurityConfig.java ===== */
package com.hau.identity_service.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
            "/users/register",
            "/auth/**",
    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
//        http.cors(cors -> cors.configurationSource(request -> {
//            CorsConfiguration config = new CorsConfiguration();
//            config.addAllowedOrigin("*");
//            config.addAllowedMethod("*");
//            config.addAllowedHeader("*");
//            config.setAllowCredentials(false);
//            config.setMaxAge(3600L);
//            return config;
//        }));

        http.authorizeHttpRequests(request -> request
                .requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(10);
    }
}

/* ===== identity-service\src\main\java\com\hau\identity_service\controller\AuthenticationController.java ===== */
package com.hau.identity_service.controller;

import java.text.ParseException;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.*;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.AuthenticationResponse;
import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.dto.response.VerifyOtpResponse;
import com.hau.identity_service.service.AuthenticationService;
import com.hau.identity_service.service.ForgotPasswordService;
import com.hau.identity_service.service.TokenService;
import com.nimbusds.jose.JOSEException;

import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class AuthenticationController {
    private final AuthenticationService authenticationService;
    private final ForgotPasswordService forgotPasswordService;
    private final TokenService tokenService;

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<AuthenticationResponse>> authenticate(
            @RequestBody @Valid AuthenticationRequest authenticationRequest) {
        ApiResponse<AuthenticationResponse> apiResponse = authenticationService.authenticate(authenticationRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/logout")
    public ResponseEntity<ApiResponse<Void>> logout(@RequestBody LogoutRequest logoutRequest) throws ParseException {
        ApiResponse<Void> apiResponse = authenticationService.logout(logoutRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<ApiResponse<AuthenticationResponse>> refreshToken(
            @RequestBody RefreshTokenRequest refreshTokenRequest) throws ParseException, JOSEException {
        ApiResponse<AuthenticationResponse> apiResponse = tokenService.refreshToken(refreshTokenRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/introspect")
    public ResponseEntity<ApiResponse<IntrospectResponse>> introspect(@RequestBody IntrospectRequest request) {
        ApiResponse<IntrospectResponse> apiResponse = authenticationService.introspect(request);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/password-recovery/otp")
    public ResponseEntity<ApiResponse<String>> sendOtpForgotPassword(
            @RequestBody @Valid ForgotPasswordRequest forgotPasswordRequest) {
        ApiResponse<String> apiResponse = forgotPasswordService.sendOtp(forgotPasswordRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/password-recovery/otp/verify")
    public ResponseEntity<ApiResponse<VerifyOtpResponse>> verifyOtpForgotPassword(
            @Valid @RequestBody VerifyOtpRequest verifyOtpRequest) {
        ApiResponse<VerifyOtpResponse> apiResponse = forgotPasswordService.verifyOtp(verifyOtpRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/password-recovery/reset")
    public ResponseEntity<ApiResponse<String>> resetPassword(
            @Valid @RequestBody ResetPasswordWithTokenRequest resetPasswordWithTokenRequest) {
        ApiResponse<String> apiResponse = forgotPasswordService.resetPassword(resetPasswordWithTokenRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\controller\PermissionController.java ===== */
package com.hau.identity_service.controller;

import java.util.List;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.PermissionCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.PermissionResponse;
import com.hau.identity_service.service.PermissionService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/permissions")
@RequiredArgsConstructor
public class PermissionController {
    private final PermissionService permissionService;

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public ResponseEntity<ApiResponse<PermissionResponse>> createPermission(
            @RequestBody @Valid PermissionCreationRequest permissionCreationRequest) {
        ApiResponse<PermissionResponse> apiResponse = permissionService.createPermission(permissionCreationRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping
    public ResponseEntity<ApiResponse<List<PermissionResponse>>> getAllPermissions() {
        ApiResponse<List<PermissionResponse>> apiResponse = permissionService.getAllPermissions();
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{name}")
    public ResponseEntity<ApiResponse<PermissionResponse>> deletePermission(@PathVariable String name) {
        ApiResponse<PermissionResponse> apiResponse = permissionService.deletePermission(name);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\controller\RoleController.java ===== */
package com.hau.identity_service.controller;

import java.util.List;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.RoleCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.RoleResponse;
import com.hau.identity_service.service.RoleService;

import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@RequestMapping("/roles")
public class RoleController {
    private final RoleService roleService;

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public ResponseEntity<ApiResponse<RoleResponse>> createRole(@RequestBody @Valid RoleCreationRequest roleRequest) {
        ApiResponse<RoleResponse> apiResponse = roleService.createRole(roleRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping
    public ResponseEntity<ApiResponse<List<RoleResponse>>> getAllRoles() {
        ApiResponse<List<RoleResponse>> apiResponse = roleService.getAllRoles();
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{name}")
    public ResponseEntity<ApiResponse<RoleResponse>> deleteRole(@PathVariable String name) {
        ApiResponse<RoleResponse> apiResponse = roleService.deleteRole(name);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\controller\UserController.java ===== */
package com.hau.identity_service.controller;

import com.hau.identity_service.dto.response.PageResponse;
import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.ChangePasswordRequest;
import com.hau.identity_service.dto.request.UserCreateRequest;
import com.hau.identity_service.dto.request.UserUpdateInfoRequest;
import com.hau.identity_service.dto.request.UserUpdateRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.UserResponse;
import com.hau.identity_service.service.UserService;

import lombok.RequiredArgsConstructor;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequiredArgsConstructor
@RequestMapping("/users")
public class UserController {
    private final UserService userService;

    @PostMapping("/register")
    public ResponseEntity<ApiResponse<UserResponse>> createUser(
            @Valid @RequestBody UserCreateRequest userCreateRequest) {
        ApiResponse<UserResponse> userResponse = userService.createUser(userCreateRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.CREATED);
    }

    @PutMapping("/profile-image")
    public ResponseEntity<ApiResponse<UserResponse>> updateUserProfileImage(
            @RequestParam("profileImage") MultipartFile profileImage) {
        ApiResponse<UserResponse> userResponse = userService.updateUserProfileImage(profileImage);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF') or @userService.isOwnerOfUser(#userId, authentication)")
    @GetMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> getUserById(@PathVariable Long userId) {
        ApiResponse<UserResponse> userResponse = userService.getUserById(userId);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @GetMapping("/info")
    public ResponseEntity<ApiResponse<UserResponse>> myInfo() {
        ApiResponse<UserResponse> userResponse = userService.myInfo();
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @PutMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> updateUser(
            @PathVariable Long userId, @Valid @RequestBody UserUpdateRequest userUpdateRequest) {
        ApiResponse<UserResponse> userResponse = userService.updateUser(userId, userUpdateRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PutMapping("/info")
    public ResponseEntity<ApiResponse<UserResponse>> updateUserInfo(@Valid @RequestBody UserUpdateInfoRequest userUpdateInfoRequest) {
        ApiResponse<UserResponse> userResponse = userService.updateUserInfo(userUpdateInfoRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF') or @userService.isOwnerOfUser(#userId, authentication)")
    @PatchMapping("/{userId}/password")
    public ResponseEntity<ApiResponse<UserResponse>> updatePassword(
            @PathVariable Long userId, @RequestBody @Valid ChangePasswordRequest changePasswordRequest) {
        ApiResponse<UserResponse> userResponse = userService.changePassword(userId, changePasswordRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @GetMapping
    public ResponseEntity<ApiResponse<PageResponse<UserResponse>>> getAllUsers(
            @RequestParam(required = false, defaultValue = "1") int pageIndex,
            @RequestParam(required = false, defaultValue = "10") int pageSize
    ) {
        ApiResponse<PageResponse<UserResponse>> userPage = userService.getAllUsers(pageIndex, pageSize);
        return new ResponseEntity<>(userPage, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @DeleteMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> deleteUser(@PathVariable Long userId) {
        ApiResponse<UserResponse> userResponse = userService.deleteUser(userId);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping("/seeding/{numberOfRecords}")
    public ResponseEntity<ApiResponse<String>> seeding(@PathVariable int numberOfRecords) {
        ApiResponse<String> response = userService.seeding(numberOfRecords);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\AuthenticationRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthenticationRequest {
    @NotBlank(message = "Tên đăng nhập không được để trống")
    private String username;

    @NotBlank(message = "Mật khẩu không được để trống")
    private String password;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\CartCreateRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartCreateRequest {
    private Integer id;
    private Integer userId;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\ChangePasswordRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ChangePasswordRequest {
    @NotBlank(message = "Mật khẩu cũ không được để trống")
    private String oldPassword;

    @NotBlank(message = "Mật khẩu mới không được để trống")
    private String newPassword;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\ForgotPasswordRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ForgotPasswordRequest {
    @NotBlank(message = "Tên đăng nhập không được để trống")
    private String username;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\IntrospectRequest.java ===== */
package com.hau.identity_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IntrospectRequest {
    private String token;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\LogoutRequest.java ===== */
package com.hau.identity_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LogoutRequest {
    private String token;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\PermissionCreationRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PermissionCreationRequest {
    @NotBlank(message = "Tên quyền không được để trống")
    private String name;

    private String description;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\RefreshTokenRequest.java ===== */
package com.hau.identity_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RefreshTokenRequest {
    private String token;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\ResetPasswordWithTokenRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ResetPasswordWithTokenRequest {
    @NotBlank(message = "Mật khẩu không được để trống")
    @Size(min = 6, message = "Mật khẩu phải có ít nhất 6 ký tự")
    private String newPassword;

    @NotBlank(message = "Mã xác nhận không được để trống")
    private String verificationToken;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\RoleCreationRequest.java ===== */
package com.hau.identity_service.dto.request;

import java.util.Set;

import jakarta.validation.constraints.NotBlank;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleCreationRequest {
    @NotBlank(message = "Tên vai trò không được để trống")
    private String name;

    private String description;
    private Set<String> permissions;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\UserCreateRequest.java ===== */
package com.hau.identity_service.dto.request;

import java.util.Set;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserCreateRequest {
    @NotBlank(message = "Username không được để trống")
    @Pattern(regexp = "^[a-z0-9]+$", message = "Username chỉ được chứa chữ cái thường và không có ký tự đặc biệt")
    private String username;

    @Size(min = 6, message = "Password phải có ít nhất 6 ký tự")
    private String password;

    @Email(message = "Email không đúng định dạng")
    @NotBlank(message = "Email không được để trống")
    private String email;
    private Set<String> roles;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\UserUpdateImageRequest.java ===== */
package com.hau.identity_service.dto.request;

public class UserUpdateImageRequest {
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\UserUpdateInfoRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserUpdateInfoRequest {
    @NotBlank(message = "Email không được để trống")
    @Email(message = "Email không đúng định dạng")
    private String email;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\UserUpdateRequest.java ===== */
package com.hau.identity_service.dto.request;

import java.util.Set;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserUpdateRequest {
    @Size(min = 6, message = "Password phải có ít nhất 6 ký tự")
    private String password;

    @NotBlank(message = "Email không được để trống")
    @Email(message = "Email không đúng định dạng")
    private String email;

    private Set<String> roles;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\request\VerifyOtpRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class VerifyOtpRequest {
    @NotBlank(message = "Username không được để trống")
    private String username;

    private int otp;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\ApiResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\AuthenticationResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthenticationResponse {
    private boolean authenticated;
    private String token;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\CartResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartResponse {
    private Integer id;
    private Integer userId;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\ErrorsResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\FileResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FileResponse {
    private String originalFileName;
    private String url;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\IntrospectResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IntrospectResponse {
    private boolean valid;
    private String username;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\PageResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\PermissionResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PermissionResponse {
    private String name;
    private String description;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\RoleResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.util.Set;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleResponse {
    private String name;
    private String description;
    private Set<PermissionResponse> permissions;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\UserResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.util.Set;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.beans.factory.annotation.Value;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponse {
    private String id;
    private String username;
    private String email;
    private String profileImage;
    private Set<RoleResponse> roles;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\dto\response\VerifyOtpResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class VerifyOtpResponse {
    private String verificationToken;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\entity\InvalidatedToken.java ===== */
package com.hau.identity_service.entity;

import java.util.Date;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

import lombok.*;

@Builder
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "invalidated_token")
public class InvalidatedToken {
    @Id
    private String id;

    private Date expiryDate;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\entity\Permission.java ===== */
package com.hau.identity_service.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "permissions")
public class Permission {
    @Id
    private String name;

    private String description;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\entity\Role.java ===== */
package com.hau.identity_service.entity;

import java.util.Set;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;

import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "roles")
public class Role {
    @Id
    private String name;

    private String description;

    @ManyToMany
    Set<Permission> permissions;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\entity\User.java ===== */
package com.hau.identity_service.entity;

import java.time.LocalDateTime;
import java.util.Set;

import jakarta.persistence.*;

import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(unique = true, length = 50)
    private String username;
    private String password;
    private String email;
    private String profileImage;

    @ManyToMany(fetch = FetchType.LAZY)
    private Set<Role> roles;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @UpdateTimestamp
    private LocalDateTime updatedAt;
}


/* ===== identity-service\src\main\java\com\hau\identity_service\exception\AppException.java ===== */
package com.hau.identity_service.exception;

import java.time.LocalDateTime;

import org.springframework.http.HttpStatus;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\exception\GlobalExceptionHandler.java ===== */
package com.hau.identity_service.exception;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import com.hau.identity_service.dto.response.ErrorsResponse;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
//    @ExceptionHandler(Exception.class)
//    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
//    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\mapper\PermissionMapper.java ===== */
package com.hau.identity_service.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.NullValuePropertyMappingStrategy;

import com.hau.identity_service.dto.request.PermissionCreationRequest;
import com.hau.identity_service.dto.response.PermissionResponse;
import com.hau.identity_service.entity.Permission;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface PermissionMapper {
    Permission toPermission(PermissionCreationRequest permissionCreationRequest);

    PermissionResponse toPermissionResponse(Permission permission);
}


/* ===== identity-service\src\main\java\com\hau\identity_service\mapper\RoleMapper.java ===== */
package com.hau.identity_service.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.NullValuePropertyMappingStrategy;

import com.hau.identity_service.dto.request.RoleCreationRequest;
import com.hau.identity_service.dto.response.RoleResponse;
import com.hau.identity_service.entity.Role;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface RoleMapper {
    @Mapping(target = "permissions", ignore = true)
    Role toRole(RoleCreationRequest roleCreationRequest);

    RoleResponse toRoleResponse(Role role);
}


/* ===== identity-service\src\main\java\com\hau\identity_service\mapper\UserMapper.java ===== */
package com.hau.identity_service.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;

import com.hau.identity_service.dto.request.UserCreateRequest;
import com.hau.identity_service.dto.request.UserUpdateInfoRequest;
import com.hau.identity_service.dto.request.UserUpdateRequest;
import com.hau.identity_service.dto.response.UserResponse;
import com.hau.identity_service.entity.User;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface UserMapper {
    @Mapping(target = "roles", ignore = true)
    User toUser(UserCreateRequest userCreateRequest);

    @Mapping(target = "roles", ignore = true)
    void toUserUpdateRequest(@MappingTarget User user, UserUpdateRequest userUpdateRequest);

    UserResponse toUserResponse(User user);
}


/* ===== identity-service\src\main\java\com\hau\identity_service\repository\CartServiceClient.java ===== */
package com.hau.identity_service.repository;

import com.hau.identity_service.config.AuthenticationRequestInterceptor;
import com.hau.identity_service.dto.request.CartCreateRequest;
import com.hau.identity_service.dto.response.CartResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "cart-service", url = "${app.cart-service.url}",
        configuration = {AuthenticationRequestInterceptor.class})
public interface CartServiceClient {
    @PostMapping(value = "/cart/internal/users", produces = MediaType.APPLICATION_JSON_VALUE)
    CartResponse createCart(@RequestBody CartCreateRequest cartCreateRequest);
}


/* ===== identity-service\src\main\java\com\hau\identity_service\repository\FileServiceClient.java ===== */
package com.hau.identity_service.repository;

import com.hau.identity_service.config.AuthenticationRequestInterceptor;
import com.hau.identity_service.config.FeignMultipartSupportConfig;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.FileResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

@FeignClient(name = "file-service", url = "${app.file-service.url}",
        configuration = {AuthenticationRequestInterceptor.class, FeignMultipartSupportConfig.class})
public interface FileServiceClient {
    @PostMapping(value = "/file/media", consumes = MediaType.MULTIPART_FORM_DATA_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    ApiResponse<FileResponse> uploadFile(@RequestPart("file") MultipartFile file);

    @DeleteMapping
    ApiResponse<FileResponse> deleteFile(@RequestPart("fileUrl") String fileUrl);
}


/* ===== identity-service\src\main\java\com\hau\identity_service\repository\InvalidatedTokenRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.hau.identity_service.entity.InvalidatedToken;

public interface InvalidatedTokenRepository extends JpaRepository<InvalidatedToken, String> {
    List<InvalidatedToken> findByExpiryDateLessThanEqual(Date expiryDate);
}


/* ===== identity-service\src\main\java\com\hau\identity_service\repository\PermissionRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import com.hau.identity_service.entity.Permission;

@Repository
public interface PermissionRepository extends JpaRepository<Permission, String>, JpaSpecificationExecutor<Permission> {
    Optional<Permission> findByName(String name);
}


/* ===== identity-service\src\main\java\com\hau\identity_service\repository\RoleRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import com.hau.identity_service.entity.Role;

@Repository
public interface RoleRepository extends JpaRepository<Role, String>, JpaSpecificationExecutor<Role> {
    Optional<Role> findByName(String name);
}


/* ===== identity-service\src\main\java\com\hau\identity_service\repository\UserRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import com.hau.identity_service.entity.User;

@Repository
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
    Optional<User> findByUsername(String username);
}


/* ===== identity-service\src\main\java\com\hau\identity_service\service\AuthenticationService.java ===== */
package com.hau.identity_service.service;

import java.text.ParseException;
import java.time.LocalDateTime;
import java.util.Date;

import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.request.AuthenticationRequest;
import com.hau.identity_service.dto.request.IntrospectRequest;
import com.hau.identity_service.dto.request.LogoutRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.AuthenticationResponse;
import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.entity.InvalidatedToken;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.repository.InvalidatedTokenRepository;
import com.hau.identity_service.repository.UserRepository;
import com.nimbusds.jose.*;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
@Service
@Slf4j
public class AuthenticationService {
    private final UserRepository userRepository;
    private final InvalidatedTokenRepository invalidatedTokenRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenService tokenService;


    public ApiResponse<AuthenticationResponse> authenticate(AuthenticationRequest authenticationRequest) {
        User user = userRepository
                .findByUsername(authenticationRequest.getUsername())
                .orElse(null);

        if (user == null || !passwordEncoder.matches(authenticationRequest.getPassword(), user.getPassword())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Tên đăng nhập hoặc mật khẩu không chính xác", null);
        }

        String token;
        try {
            token = tokenService.generateToken(user);
        } catch (JOSEException e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi tạo token", e);
        }

        return ApiResponse.<AuthenticationResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Đăng nhập thành công")
                .result(AuthenticationResponse.builder()
                        .authenticated(true)
                        .token(token)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<Void> logout(LogoutRequest logoutRequest) throws ParseException {
        var signToken = tokenService.verifyToken(logoutRequest.getToken(), true);
        String jit = signToken.getJWTClaimsSet().getJWTID();
        Date expiryTime = signToken.getJWTClaimsSet().getExpirationTime();

        InvalidatedToken invalidatedToken =
                InvalidatedToken.builder().id(jit).expiryDate(expiryTime).build();
        invalidatedTokenRepository.save(invalidatedToken);
        return ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Đăng xuất thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<IntrospectResponse> introspect(IntrospectRequest introspectRequest) {
        String token = introspectRequest.getToken();

        if (token == null || token.isEmpty()) {
            return buildErrorResponse("Token không được cung cấp");
        }

        try {
            // Sử dụng TokenService thay vì logic tại chỗ
            IntrospectResponse result = tokenService.validateToken(token);

            if (result.isValid()) {
                return ApiResponse.<IntrospectResponse>builder()
                        .status(HttpStatus.OK.value())
                        .message("Token hợp lệ")
                        .result(result)
                        .timestamp(LocalDateTime.now())
                        .build();
            } else {
                return buildErrorResponse("Token không hợp lệ");
            }
        } catch (Exception e) {
            return buildErrorResponse(e.getMessage());
        }
    }

    private ApiResponse<IntrospectResponse> buildErrorResponse(String message) {
        return ApiResponse.<IntrospectResponse>builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .message(message)
                .result(IntrospectResponse.builder().valid(false).build())
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\service\ForgotPasswordService.java ===== */
package com.hau.identity_service.service;

import java.text.ParseException;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import com.hau.event.dto.NotificationEvent;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.request.ForgotPasswordRequest;
import com.hau.identity_service.dto.request.ResetPasswordWithTokenRequest;
import com.hau.identity_service.dto.request.VerifyOtpRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.VerifyOtpResponse;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.repository.UserRepository;
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class ForgotPasswordService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @Value("${jwt.signerKey}")
    private String signerKey;

    @Value("${jwt.issuer}")
    private String issuer;

    @Value("${jwt.passwordResetTokenExpiryMinutes}")
    private long passwordResetTokenExpiryMinutes;

    @Value("${jwt.otpExpiryMinutes}")
    private long otpExpiryMinutes;

    @Value("${jwt.otpRequestCooldownMinutes}")
    private long otpRequestCooldownMinutes;

    private static final Random random = new Random();
    private static final String PURPOSE_CLAIM = "purpose";
    private static final String PURPOSE_VALUE = "PASSWORD_RESET";

    private final Map<String, String> otpCache = new ConcurrentHashMap<>();
    private final Map<String, LocalDateTime> otpExpiryCache = new ConcurrentHashMap<>();

    private final Map<String, LocalDateTime> otpRequestTimestamps = new ConcurrentHashMap<>();

    private final Map<String, LocalDateTime> usedResetTokens = new ConcurrentHashMap<>();

    public ApiResponse<String> sendOtp(ForgotPasswordRequest forgotPasswordRequest) {
        String username = forgotPasswordRequest.getUsername();

        // --- Rate Limiting Check ---
        LocalDateTime lastRequestTime = otpRequestTimestamps.get(username);
        LocalDateTime now = LocalDateTime.now();
        if (lastRequestTime != null) {
            Duration timeSinceLastRequest = Duration.between(lastRequestTime, now);
            if (timeSinceLastRequest.toMinutes() < otpRequestCooldownMinutes) {
                long waitMinutes = otpRequestCooldownMinutes - timeSinceLastRequest.toMinutes();
                log.warn("Rate limit hit for OTP request by user: {}. Wait {} more minute(s).", username, waitMinutes);
                return ApiResponse.<String>builder()
                        .status(HttpStatus.TOO_MANY_REQUESTS.value())
                        .message("Bạn vừa yêu cầu OTP gần đây. Vui lòng đợi " + waitMinutes
                                + " phút nữa trước khi thử lại.")
                        .result(null)
                        .timestamp(now)
                        .build();
            }
        }
        // --- End Rate Limiting Check ---

        User user = userRepository
                .findByUsername(username)
                .orElseThrow(() -> new AppException(
                        HttpStatus.NOT_FOUND, "Không tìm thấy người dùng với username: " + username, null));

        String otp = generateOtp();
        otpCache.put(username, otp);
        otpExpiryCache.put(username, now.plusMinutes(otpExpiryMinutes));

        log.info("Generated OTP for user {}. Triggering async email.", username);

        NotificationEvent notificationEvent = NotificationEvent.builder()
                .channel("EMAIL")
                .recipient(user.getEmail())
                .templateCode("otp-email-template")
                .params(Map.of(
                        "username", username,
                        "otp", otp,
                        "expiryMinutes", otpExpiryMinutes
                ))
                .build();
        kafkaTemplate.send("forgot-password-topic", notificationEvent);

        // Update the timestamp *after* successfully processing the request
        otpRequestTimestamps.put(username, now);

        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Yêu cầu gửi OTP đã được xử lý. Vui lòng kiểm tra email của bạn.")
                .result(null)
                .timestamp(now)
                .build();
    }

    public ApiResponse<VerifyOtpResponse> verifyOtp(VerifyOtpRequest verifyOtpRequest) {
        // Extract username from the request body DTO
        String username = verifyOtpRequest.getUsername();
        int otp = verifyOtpRequest.getOtp(); // Get OTP from request

        String cachedOtp = otpCache.get(username);
        LocalDateTime expiryTime = otpExpiryCache.get(username);
        LocalDateTime now = LocalDateTime.now();

        // --- Logic using the extracted username ---
        if (cachedOtp == null) {
            log.warn("Verify OTP attempt for user '{}' failed: No OTP found in cache.", username);
            return buildVerifyOtpErrorResponse("OTP không hợp lệ hoặc chưa được yêu cầu. Vui lòng thử lại.");
        }

        if (expiryTime != null && now.isAfter(expiryTime)) {
            log.warn("Verify OTP attempt for user '{}' failed: OTP expired.", username);
            otpCache.remove(username);
            otpExpiryCache.remove(username);
            return buildVerifyOtpErrorResponse("OTP đã hết hạn. Vui lòng yêu cầu OTP mới.");
        }

        if (!cachedOtp.equals(String.valueOf(otp))) {
            log.warn("Verify OTP attempt for user '{}' failed: Incorrect OTP.", username);
            // Consider adding rate limiting for failed attempts here
            return buildVerifyOtpErrorResponse("OTP không chính xác. Vui lòng thử lại.");
        }
        // --- End Logic ---

        // OTP is correct, remove it from cache
        otpCache.remove(username);
        otpExpiryCache.remove(username);
        log.info("OTP successfully verified for user '{}'.", username);

        // Generate Password Reset JWT
        String passwordResetToken;
        try {
            passwordResetToken = generatePasswordResetToken(username); // Pass username to token generation
            log.info("Generated password reset JWT for user {}", username);
        } catch (JOSEException e) {
            log.error("Error generating password reset JWT for user {}: {}", username, e.getMessage());
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi tạo mã xác nhận đặt lại mật khẩu", e);
        }

        return ApiResponse.<VerifyOtpResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xác thực OTP thành công. Mã xác nhận đặt lại mật khẩu đã được tạo.")
                .result(VerifyOtpResponse.builder()
                        .verificationToken(passwordResetToken)
                        .build())
                .timestamp(now)
                .build();
    }

    public ApiResponse<String> resetPassword(ResetPasswordWithTokenRequest resetPasswordWithTokenRequest) {
        String verificationToken = resetPasswordWithTokenRequest.getVerificationToken();
        String username;
        String jti; // JWT ID
        Date tokenExpiry;

        JWTClaimsSet claimsSet;
        try {
            claimsSet = validatePasswordResetToken(verificationToken); // Validation now includes blacklist check
            username = claimsSet.getSubject();
            jti = claimsSet.getJWTID(); // Get JTI
            tokenExpiry = claimsSet.getExpirationTime(); // Get expiry for blacklist

            if (username == null || username.trim().isEmpty() || jti == null || tokenExpiry == null) {
                log.error("Validated password reset token is missing critical claims (sub, jti, or exp).");
                throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi xử lý mã xác nhận.", null);
            }
        } catch (AppException e) {
            return ApiResponse.<String>builder()
                    .status(e.getHttpStatus().value())
                    .message(e.getMessage())
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        } catch (Exception e) {
            log.error("Unexpected error processing password reset token: {}", e.getMessage(), e);
            return ApiResponse.<String>builder()
                    .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                    .message("Lỗi không xác định khi xử lý mã đặt lại mật khẩu.")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        }

        User user = userRepository.findByUsername(username).orElseThrow(() -> {
            log.error("User '{}' not found after successful token validation (JTI: {}).", username, jti);
            return new AppException(
                    HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi không mong đợi: Không tìm thấy người dùng.", null);
        });

        user.setPassword(passwordEncoder.encode(resetPasswordWithTokenRequest.getNewPassword()));
        userRepository.save(user);

        // --- Add token JTI to blacklist after successful password reset ---
        // Store with original expiry time to allow potential cleanup later
        usedResetTokens.put(
                jti,
                tokenExpiry.toInstant().atZone(java.time.ZoneId.systemDefault()).toLocalDateTime());
        log.info("Password successfully reset for user {}. Token JTI {} blacklisted.", username, jti);
        // Note: In a production/scaled environment, consider a more robust blacklist (e.g., Redis with TTL)
        // and a cleanup mechanism for the in-memory map if used long-term.
        // --- End blacklist update ---

        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Mật khẩu đã được đặt lại thành công.")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    // --- Helper Methods ---

    private String generatePasswordResetToken(String username) throws JOSEException {
        JWSHeader jwsHeader = new JWSHeader(JWSAlgorithm.HS512);
        JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder()
                .subject(username)
                .issuer(issuer)
                .issueTime(new Date())
                .expirationTime(new Date(Instant.now()
                        .plus(passwordResetTokenExpiryMinutes, ChronoUnit.MINUTES)
                        .toEpochMilli()))
                .claim(PURPOSE_CLAIM, PURPOSE_VALUE)
                .jwtID(UUID.randomUUID().toString()) // Ensure unique JTI is generated
                .build();

        Payload payload = new Payload(jwtClaimsSet.toJSONObject());
        JWSObject jwsObject = new JWSObject(jwsHeader, payload);
        jwsObject.sign(new MACSigner(signerKey.getBytes()));
        return jwsObject.serialize();
    }

    private JWTClaimsSet validatePasswordResetToken(String token) throws ParseException, JOSEException, AppException {
        SignedJWT signedJWT = SignedJWT.parse(token);
        JWSVerifier verifier = new MACVerifier(signerKey.getBytes());

        boolean signatureValid = signedJWT.verify(verifier);
        if (!signatureValid) {
            log.warn("Invalid password reset token signature received.");
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (chữ ký sai).", null);
        }

        JWTClaimsSet claimsSet = signedJWT.getJWTClaimsSet();
        String jti = claimsSet.getJWTID();
        String tokenUsername = claimsSet.getSubject(); // Get username for logging context

        // --- Check Blacklist (Single-Use) ---
        if (jti != null && usedResetTokens.containsKey(jti)) {
            log.warn("Attempt to reuse already used password reset token. User: {}, JTI: {}", tokenUsername, jti);
            // Consider 409 Conflict, but 400 is also common.
            throw new AppException(
                    HttpStatus.BAD_REQUEST,
                    "Mã xác nhận đã được sử dụng. Vui lòng thực hiện lại quy trình quên mật khẩu.",
                    null);
        }
        // --- End Blacklist Check ---

        Date expirationTime = claimsSet.getExpirationTime();
        if (expirationTime == null || expirationTime.before(new Date())) {
            log.info("Expired password reset token used (User: {}, JTI: {}).", tokenUsername, jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận đã hết hạn.", null);
        }

        String tokenIssuer = claimsSet.getIssuer();
        if (tokenIssuer == null || !tokenIssuer.equals(issuer)) {
            log.warn(
                    "Invalid issuer in password reset token. User: {}, Expected: {}, Found: {}. JTI: {}",
                    tokenUsername,
                    issuer,
                    tokenIssuer,
                    jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (issuer sai).", null);
        }

        String purpose = claimsSet.getStringClaim(PURPOSE_CLAIM);
        if (!PURPOSE_VALUE.equals(purpose)) {
            log.warn(
                    "Incorrect purpose claim in token. User: {}, Expected: {}, Found: {}. JTI: {}",
                    tokenUsername,
                    PURPOSE_VALUE,
                    purpose,
                    jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (mục đích sai).", null);
        }

        if (tokenUsername == null || tokenUsername.trim().isEmpty()) {
            log.warn("Password reset token is missing the subject (username) claim. JTI: {}", jti);
            throw new AppException(
                    HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (thiếu thông tin người dùng).", null);
        }

        Date issueTime = claimsSet.getIssueTime();
        if (issueTime != null && issueTime.after(new Date())) {
            log.warn("Password reset token used before issue time for user {}. JTI: {}", tokenUsername, jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận chưa có hiệu lực.", null);
        }

        if (jti == null) {
            // Should not happen if generation includes it, but check defensively.
            log.error("Password reset token is missing the JTI claim. User: {}", tokenUsername);
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi xử lý mã xác nhận (thiếu JTI).", null);
        }

        log.info("Password reset token successfully validated for user {}", tokenUsername);
        return claimsSet;
    }

    private String generateOtp() {
        int otpValue = 100000 + random.nextInt(900000);
        return String.valueOf(otpValue);
    }

    private ApiResponse<VerifyOtpResponse> buildVerifyOtpErrorResponse(String message) {
        return ApiResponse.<VerifyOtpResponse>builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .message(message)
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\service\PermissionService.java ===== */
package com.hau.identity_service.service;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.request.PermissionCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.PermissionResponse;
import com.hau.identity_service.entity.Permission;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.mapper.PermissionMapper;
import com.hau.identity_service.repository.PermissionRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class PermissionService {

    private final PermissionRepository permissionRepository;
    private final PermissionMapper permissionMapper;

    public ApiResponse<PermissionResponse> createPermission(PermissionCreationRequest permissionCreationRequest) {
        Permission permission = permissionMapper.toPermission(permissionCreationRequest);
        permissionRepository.save(permission);
        return ApiResponse.<PermissionResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo mới quyền thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<PermissionResponse>> getAllPermissions() {
        List<Permission> permissions = permissionRepository.findAll();
        List<PermissionResponse> permissionResponses =
                permissions.stream().map(permissionMapper::toPermissionResponse).toList();
        return ApiResponse.<List<PermissionResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách quyền thành công")
                .result(permissionResponses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<PermissionResponse> deletePermission(String name) {
        Permission permission = permissionRepository
                .findByName(name)
                .orElseThrow(
                        () -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy quyền với tên: " + name, null));
        permissionRepository.delete(permission);
        return ApiResponse.<PermissionResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa quyền thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\service\RoleService.java ===== */
package com.hau.identity_service.service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.hau.identity_service.dto.request.RoleCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.RoleResponse;
import com.hau.identity_service.entity.Role;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.mapper.RoleMapper;
import com.hau.identity_service.repository.PermissionRepository;
import com.hau.identity_service.repository.RoleRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class RoleService {
    private final RoleRepository roleRepository;
    private final PermissionRepository permissionRepository;
    private final RoleMapper roleMapper;

    public ApiResponse<RoleResponse> createRole(RoleCreationRequest request) {
        var role = roleMapper.toRole(request);
        var permissionIds = request.getPermissions();
        var permissions = permissionRepository.findAllById(permissionIds);
        if (CollectionUtils.isEmpty(permissions)) {
            return ApiResponse.<RoleResponse>builder()
                    .status(HttpStatus.BAD_REQUEST.value())
                    .message("Không tìm thấy permission nào")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        }
        role.setPermissions(new HashSet<>(permissions));
        roleRepository.save(role);
        return ApiResponse.<RoleResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo role thành công")
                .result(roleMapper.toRoleResponse(role))
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<RoleResponse>> getAllRoles() {
        List<Role> roles = roleRepository.findAll();
        List<RoleResponse> roleResponses =
                roles.stream().map(roleMapper::toRoleResponse).toList();
        return ApiResponse.<List<RoleResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách role thành công")
                .result(roleResponses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<RoleResponse> deleteRole(String name) {
        Role role = roleRepository
                .findByName(name)
                .orElseThrow(
                        () -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy role với tên: " + name, null));
        roleRepository.delete(role);
        return ApiResponse.<RoleResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa role thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\service\TokenService.java ===== */
package com.hau.identity_service.service;

import java.text.ParseException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;
import java.util.StringJoiner;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.hau.identity_service.dto.request.RefreshTokenRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.AuthenticationResponse;
import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.entity.InvalidatedToken;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.repository.InvalidatedTokenRepository;
import com.hau.identity_service.repository.UserRepository;
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class TokenService {

    @Value("${jwt.signerKey}")
    private String signerKey;

    @Value("${jwt.issuer}")
    private String issuer;

    @Value("${jwt.expirationMinutes}")
    private Long expiration;

    @Value("${jwt.expirationRefreshMinutes}")
    private Long expirationRefresh;

    private final InvalidatedTokenRepository invalidatedTokenRepository;
    private final UserRepository userRepository;

    private JWTClaimsSet validateTokenClaims(String token, boolean isRefresh) throws AppException {
        try {
            JWSVerifier verifier = new MACVerifier(signerKey.getBytes());
            SignedJWT signedJWT = SignedJWT.parse(token);
            JWTClaimsSet claimsSet = signedJWT.getJWTClaimsSet();

            if (!signedJWT.verify(verifier)) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Chữ ký token không hợp lệ", null);
            }

            Date expirationTime = (isRefresh)
                    ? new Date(claimsSet
                            .getIssueTime()
                            .toInstant()
                            .plus(expirationRefresh, ChronoUnit.MINUTES)
                            .toEpochMilli())
                    : claimsSet.getExpirationTime();

            if (expirationTime == null || expirationTime.before(new Date())) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token đã hết hạn", null);
            }

            if (claimsSet.getIssuer() == null || !claimsSet.getIssuer().equals(issuer)) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token issuer không hợp lệ", null);
            }

            if (claimsSet.getIssueTime() != null && claimsSet.getIssueTime().after(new Date())) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token chưa có hiệu lực", null);
            }

            if (invalidatedTokenRepository.existsById(claimsSet.getJWTID())) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token đã hết hiệu lực", null);
            }

            return claimsSet;

        } catch (ParseException | JOSEException e) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Token không hợp lệ", null);
        }
    }

    public SignedJWT verifyToken(String token, boolean isRefresh) throws AppException {
        try {
            validateTokenClaims(token, isRefresh);
            return SignedJWT.parse(token);
        } catch (ParseException e) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Token không hợp lệ", null);
        }
    }

    public IntrospectResponse validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return IntrospectResponse.builder().valid(false).build(); // Use the builder directly
        }
        try {
            JWTClaimsSet claimsSet = validateTokenClaims(token, false);
            return IntrospectResponse.builder()
                    .valid(true)
                    .username(claimsSet.getSubject())
                    .build();
        } catch (AppException e) {
            return IntrospectResponse.builder().valid(false).build(); // Consistent error handling
        }
    }

    public String generateToken(User user) throws JOSEException {
        JWSHeader jwsHeader = new JWSHeader(JWSAlgorithm.HS512);
        JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder()
                .issuer(issuer)
                .subject(user.getId().toString())
                .claim("username", user.getUsername())
                .issueTime(new Date())
                .expirationTime(new Date(
                        Instant.now().plus(expiration, ChronoUnit.MINUTES).toEpochMilli()))
                .claim("scope", buildScope(user))
                .jwtID(UUID.randomUUID().toString())
                .build();

        Payload payload = new Payload(jwtClaimsSet.toJSONObject());
        JWSObject jwsObject = new JWSObject(jwsHeader, payload);
        jwsObject.sign(new MACSigner(signerKey.getBytes()));
        return jwsObject.serialize();
    }

    public ApiResponse<AuthenticationResponse> refreshToken(RefreshTokenRequest refreshTokenRequest)
            throws JOSEException, ParseException {
        SignedJWT signedJWT = verifyToken(refreshTokenRequest.getToken(), true);

        String jwtId = signedJWT.getJWTClaimsSet().getJWTID();
        Date expiryTime = signedJWT.getJWTClaimsSet().getExpirationTime();

        invalidatedTokenRepository.save(
                InvalidatedToken.builder().id(jwtId).expiryDate(expiryTime).build());

        String username = signedJWT.getJWTClaimsSet().getSubject();
        log.info("Refresh token for user: {}", username);
        User user = userRepository
                .findByUsername(username)
                .orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Người dùng không tồn tại", null));

        String token = generateToken(user);
        log.info("Refresh token: {}", token);

        return ApiResponse.<AuthenticationResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Làm mới token thành công")
                .result(AuthenticationResponse.builder()
                        .authenticated(true)
                        .token(token)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }

    private String buildScope(User user) {
        StringJoiner stringJoiner = new StringJoiner(" ");
        if (!CollectionUtils.isEmpty(user.getRoles())) {
            user.getRoles().forEach(role -> {
                stringJoiner.add("ROLE_" + role.getName());
                if (!CollectionUtils.isEmpty(role.getPermissions())) {
                    role.getPermissions().forEach(permission -> stringJoiner.add(permission.getName()));
                }
            });
        }
        return stringJoiner.toString();
    }

    @Scheduled(fixedRate = 1440, timeUnit = TimeUnit.MINUTES)
    public void cleanupExpiredTokens() {
        LocalDateTime now = LocalDateTime.now();
        Date date = Date.from(now.atZone(ZoneId.systemDefault()).toInstant());
        List<InvalidatedToken> expiredTokens = invalidatedTokenRepository.findByExpiryDateLessThanEqual(date);
        invalidatedTokenRepository.deleteAll(expiredTokens);
        log.info("Cleaned up {} expired tokens.", expiredTokens.size()); // Use SLF4J
    }
}


/* ===== identity-service\src\main\java\com\hau\identity_service\service\UserService.java ===== */
package com.hau.identity_service.service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.hau.event.dto.UserCreateEvent;
import com.hau.identity_service.dto.request.*;
import com.hau.identity_service.dto.response.PageResponse;
import com.hau.identity_service.repository.CartServiceClient;
import com.hau.identity_service.repository.FileServiceClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.UserResponse;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.mapper.UserMapper;
import com.hau.identity_service.repository.RoleRepository;
import com.hau.identity_service.repository.UserRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.multipart.MultipartFile;

@RequiredArgsConstructor
@Service
@Slf4j
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final UserMapper userMapper;
    private final PasswordEncoder passwordEncoder;
    private final CartServiceClient cartServiceClient;
    private final FileServiceClient fileServiceClient;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @Value("${app.file.download-prefix}")
    private String fileDownloadPrefix;

    @Value("${app.file.default-image}")
    private String defaultImage;

    public ApiResponse<UserResponse> createUser(UserCreateRequest userCreateRequest) {
        User user = userMapper.toUser(userCreateRequest);
        var roles = roleRepository.findAllById(Set.of("USER"));
        user.setRoles(new HashSet<>(roles));
        user.setPassword(passwordEncoder.encode(userCreateRequest.getPassword()));
        user.setProfileImage(defaultImage);
        try {
            userRepository.save(user);
            UserCreateEvent userCreateEvent = UserCreateEvent.builder()
                    .id(user.getId())
                    .email(user.getEmail())
                    .username(user.getUsername())
                    .build();
            kafkaTemplate.send("user-created-topic", userCreateEvent);
            CartCreateRequest cartRequest = CartCreateRequest.builder()
                    .userId(user.getId())
                    .id(user.getId())
                    .build();
            cartServiceClient.createCart(cartRequest);
            return ApiResponse.<UserResponse>builder()
                    .status(HttpStatus.CREATED.value())
                    .message("Tạo mới user thành công")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        } catch (DataIntegrityViolationException ex) {
            throw new AppException(HttpStatus.BAD_REQUEST, "username đã tồn tại", null);
        } catch (Exception feignException) {
            log.error("Lỗi khi tạo giỏ hàng cho user {}: {}", user.getUsername(), feignException.getMessage(), feignException);
        }
        return null;
    }

    public ApiResponse<UserResponse> updateUserProfileImage(MultipartFile profileImage) {
        if (profileImage == null || profileImage.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Vui lòng chọn ảnh để tải lên", null);
        }
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        User user = findUserById(Long.valueOf(authentication.getName()));
        try {
            var fileResponse = fileServiceClient.uploadFile(profileImage);
            if (fileResponse != null && fileResponse.getResult() != null) {
                user.setProfileImage(fileResponse.getResult().getUrl());
            } else {
                throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Không nhận được thông tin từ file-service", null);
            }

            userRepository.save(user);
            return ApiResponse.<UserResponse>builder()
                    .status(HttpStatus.OK.value())
                    .message("Cập nhật ảnh đại diện thành công")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();

        } catch (Exception e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi tải ảnh profile lên dịch vụ file", e);
        }
    }


    public ApiResponse<PageResponse<UserResponse>> getAllUsers(int page, int size) {
        Sort sort = Sort.by("createdAt").descending();

        Pageable pageable = PageRequest.of(page - 1, size, sort);
        Page<User> userPage = userRepository.findAll(pageable);

        List<UserResponse> userResponseList = userPage.map(userMapper::toUserResponse).toList();
        userResponseList.forEach(userResponse -> userResponse.setProfileImage(fileDownloadPrefix + userResponse.getProfileImage()));
        return ApiResponse.<PageResponse<UserResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách user thành công")
                .result(PageResponse.<UserResponse>builder()
                        .currentPage(page)
                        .totalPages(userPage.getTotalPages())
                        .totalElements(userPage.getTotalElements())
                        .pageSize(userPage.getSize())
                        .data(userResponseList)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> myInfo() {
        var context = SecurityContextHolder.getContext();
        String id = context.getAuthentication().getName();

        User user = findUserById(Long.valueOf(id));
        UserResponse userResponse = userMapper.toUserResponse(user);
        userResponse.setProfileImage(fileDownloadPrefix + user.getProfileImage());
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin user thành công")
                .result(userResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> getUserById(Long id) {
        User user = findUserById(id);
        UserResponse userResponse = userMapper.toUserResponse(user);
        userResponse.setProfileImage(fileDownloadPrefix + user.getProfileImage());
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin user thành công")
                .result(userResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> updateUser(Long id, UserUpdateRequest userUpdateRequest) {
        User user = findUserById(id);
        userMapper.toUserUpdateRequest(user, userUpdateRequest);
        var roles = roleRepository.findAllById(userUpdateRequest.getRoles());
        user.setRoles(new HashSet<>(roles));
        user.setPassword(passwordEncoder.encode(userUpdateRequest.getPassword()));

        userRepository.save(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật thông tin user thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> updateUserInfo(UserUpdateInfoRequest userUpdateInfoRequest) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        User user = findUserById(Long.valueOf(authentication.getName()));
        user.setEmail(userUpdateInfoRequest.getEmail());
        userRepository.save(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật thông tin user thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> changePassword(Long id, ChangePasswordRequest changePasswordRequest) {
        User user = findUserById(id);
        if (!passwordEncoder.matches(changePasswordRequest.getOldPassword(), user.getPassword())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Mật khẩu cũ không đúng", null);
        }

        user.setPassword(passwordEncoder.encode(changePasswordRequest.getNewPassword()));
        userRepository.save(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Đổi mật khẩu thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> deleteUser(Long id) {
        User user = findUserById(id);
        userRepository.delete(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa user thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public User findUserById(Long id) {
        return userRepository
                .findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy user có id: " + id, null));
    }

    public boolean isOwnerOfUser(Long requestedUserId, Authentication authentication) {
        if (authentication == null || !authentication.isAuthenticated()) {
            return false;
        }
        String authenticatedUserId = authentication.getName();
        try {
            User requestedUser = findUserById(requestedUserId);
            return requestedUser.getId().toString().equals(authenticatedUserId);
        } catch (AppException e) {
            log.warn("Không tìm thấy người dùng với ID: {}", requestedUserId);
            return false;
        }
    }

    public ApiResponse<String> seeding(int numberOfRecords) {
        com.github.javafaker .Faker faker = new com.github.javafaker.Faker();
        var userRole = roleRepository.findById("USER").orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Role USER not found", "USER"));
        var staffRole = roleRepository.findById("STAFF").orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Role STAFF not found", "STAFF"));

        int usersCreated = 0;
        int staffUsersCreated = 0;

        // Create users with only USER role (first half)
        for (int i = 0; i < numberOfRecords / 2; i++) {
            String username = faker.name().username() + "_user_" + i;
            String email = username + "@example.com";
            User user = User.builder()
                    .username(username)
                    .email(email)
                    .password(passwordEncoder.encode("12345"))
                    .profileImage(defaultImage)
                    .createdAt(LocalDateTime.now())
                    .roles(Set.of(userRole))
                    .build();
            try {
                userRepository.save(user);
                usersCreated++;
            } catch (Exception e) {
                log.warn("Could not save user {}: {}", username, e.getMessage());
            }
        }

        // Create users with both USER and STAFF roles (second half)
        for (int i = 0; i < numberOfRecords / 2; i++) {
            String username = faker.name().username() + "_staff_" + i;
            String email = username + "@example.com";
            Set<com.hau.identity_service.entity.Role> roles = new HashSet<>();
            roles.add(userRole);
            roles.add(staffRole);

            User user = User.builder()
                    .username(username)
                    .email(email)
                    .password(passwordEncoder.encode("12345"))
                    .profileImage(defaultImage)
                    .createdAt(LocalDateTime.now())
                    .roles(roles)
                    .build();
            try {
                userRepository.save(user);
                staffUsersCreated++;
            } catch (Exception e) {
                log.warn("Could not save user with staff role {}: {}", username, e.getMessage());
            }
        }

        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Seeding thành công " + usersCreated + " user và " + staffUsersCreated + " user có quyền staff!")
                .result("OK")
                .build();
    }
}


/* ===== identity-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8080
  servlet:
    context-path: /identity
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/identity_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 5MB
  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
jwt:
  signerKey: "qxNOdgKfw1UmyuQ68SKM+tmEVoeAUqgvr1/eg50ufWkQTizklguIDWNP3oOGv8bS"
  expirationMinutes: 1440
  expirationRefreshMinutes: 7200
  issuer: identity-service
  passwordResetTokenExpiryMinutes: 15
  otpExpiryMinutes: 5
  otpRequestCooldownMinutes: 5

app:
  cart-service:
    url: http://localhost:8083
  file-service:
    url: http://localhost:8087
  file:
    download-prefix: http://localhost:8888/api/v1/file/media/download/
    default-image: default-avatar

admin:
  username: admin
  password: admin
  role: ADMIN

/* ===== identity-service\src\main\resources\application.yml ===== */
server:
  port: 8080
  servlet:
    context-path: /identity
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/identity_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 5MB
  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
jwt:
  signerKey: "qxNOdgKfw1UmyuQ68SKM+tmEVoeAUqgvr1/eg50ufWkQTizklguIDWNP3oOGv8bS"
  expirationMinutes: 1440
  expirationRefreshMinutes: 7200
  issuer: identity-service
  passwordResetTokenExpiryMinutes: 15
  otpExpiryMinutes: 5
  otpRequestCooldownMinutes: 5

app:
  cart-service:
    url: http://localhost:8083
  file-service:
    url: http://localhost:8087
  file:
    download-prefix: http://localhost:8888/api/v1/file/media/download/
    default-image: 6b1cb0f1-8bb4-4c15-a71e-937f588abca3_avatar.jpg

admin:
  username: admin
  password: admin
  role: ADMIN

/* ===== identity-service\src\test\java\com\hau\identity_service\GenerateKey.java ===== */
package com.hau.identity_service;

import java.security.SecureRandom;
import java.util.Base64;

public class GenerateKey {
    public static void main(String[] args) {
        SecureRandom random = new SecureRandom();
        byte[] key = new byte[64];
        random.nextBytes(key);
        String base64Key = Base64.getEncoder().encodeToString(key);
        System.out.println("Generated Signer Key: " + base64Key);
    }
}


/* ===== identity-service\src\test\java\com\hau\identity_service\IdentityServiceApplicationTests.java ===== */
package com.hau.identity_service;

import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class IdentityServiceApplicationTests {
}

/* ===== identity-service\src\test\java\com\hau\identity_service\JwtValidator.java ===== */
package com.hau.identity_service;

import java.util.Base64;

import com.nimbusds.jose.JWSObject;
import com.nimbusds.jose.crypto.MACVerifier;

public class JwtValidator {
    public static boolean isTokenValid(String token, String signerKey) {
        try {
            // Giải mã Base64 signerKey
            byte[] keyBytes = Base64.getDecoder().decode(signerKey);

            // Giải mã token
            JWSObject jwsObject = JWSObject.parse(token);

            // Tạo verifier với signerKey
            MACVerifier verifier = new MACVerifier(keyBytes);

            // Kiểm tra chữ ký
            return jwsObject.verify(verifier);
        } catch (Exception e) {
            e.printStackTrace();
            return false; // Nếu có lỗi thì token không hợp lệ
        }
    }

    public static void main(String[] args) {
        String token =
                "eyJhbGciOiJIUzUxMiJ9.eyJpc3MiOiJpZGVudGl0eS1zZXJ2aWNlIiwic3ViIjoiZHV5ZGF0MTIzIiwiZXhwIjoxNzQzMTMzNTM0LCJpYXQiOjE3NDMwNDcxMzQsImp0aSI6ImRlZGM1NTFkLWZkNTYtNDk3Yi1hY2E2LWJiYjgxMDExYjhiMSJ9.zecGF6tgXbgAvIBG17iRDxEDhNj-euzcDXGDmZq3YQsHFzlt2k-Bp-2CctBW6BVExEVXbMSNLqR45Fmc_dM7MA";
        String signerKey = "1Z2nJb9mkRfQQ42ikhS4z/klBS9/sAh8R68Tesh2hItthNNjOr9tbrYhyHLxJ7EtWmaGmdKbwdGnTPMGPk2YrQ==";

        boolean isValid = isTokenValid(token, signerKey);
        System.out.println("Token hợp lệ? " + isValid);
    }
}


/* ===== notification-service\src\main\java\com\hau\event\dto\NotificationEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationEvent {
    private String channel;
    private String recipient;
    private String templateCode;
    private Map<String, Object> params;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\NotificationServiceApplication.java ===== */
package com.hau.notificationservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class NotificationServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(NotificationServiceApplication.class, args);
    }

}


/* ===== notification-service\src\main\java\com\hau\notificationservice\config\CustomJwtDecoder.java ===== */
package com.hau.notificationservice.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.notificationservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.notificationservice.dto.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\config\SecurityConfig.java ===== */
package com.hau.notificationservice.config;


import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== notification-service\src\main\java\com\hau\notificationservice\controller\EmailController.java ===== */
package com.hau.notificationservice.controller;

import com.hau.notificationservice.dto.ApiResponse;
import com.hau.notificationservice.dto.EmailResponse;
import com.hau.notificationservice.dto.SendEmailRequest;
import com.hau.notificationservice.service.EmailService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;

@RestController
@RequiredArgsConstructor
@Slf4j
public class EmailController {
    private final EmailService emailService;

    @PostMapping("/email")
    ApiResponse<EmailResponse> sendEmail(@RequestBody SendEmailRequest sendEmailRequest) {
        return ApiResponse.<EmailResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Gửi email thành công")
                .result(emailService.sendEmail(sendEmailRequest))
                .timestamp(LocalDateTime.now())
                .build();
    }

}


/* ===== notification-service\src\main\java\com\hau\notificationservice\controller\FcmTokenController.java ===== */
package com.hau.notificationservice.controller;

import com.hau.notificationservice.dto.ApiResponse;
import com.hau.notificationservice.dto.FcmTokenCreateRequest;
import com.hau.notificationservice.dto.FcmTokenResponse;
import com.hau.notificationservice.service.FcmTokenService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping("/fcm-token")
public class FcmTokenController {
    private final FcmTokenService fcmTokenService;

    @PostMapping
    public ResponseEntity<ApiResponse<FcmTokenResponse>> fcmTokenResponse(@RequestBody FcmTokenCreateRequest fcmTokenCreateRequest) {
        ApiResponse<FcmTokenResponse> fcmTokenResponse = fcmTokenService.fcmTokenResponseApiResponse(fcmTokenCreateRequest);
        return new ResponseEntity<>(fcmTokenResponse, HttpStatus.CREATED);
    }
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\controller\NotificationController.java ===== */
package com.hau.notificationservice.controller;

import com.hau.event.dto.NotificationEvent;
import com.hau.notificationservice.service.NotificationProcessingService;
import com.hau.notificationservice.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

@RequiredArgsConstructor
@Slf4j
@Component
public class NotificationController {

    private final NotificationService notificationService;
    private final NotificationProcessingService notificationProcessingService;

    @KafkaListener(topics = "forgot-password-topic")
    public void listenOtpTopic(NotificationEvent notificationEvent) {
        notificationService.handleNotification(notificationEvent);
    }

    @KafkaListener(topics = "order-create-notification-topic")
    public void listenOrderCreateTopic(NotificationEvent notificationEvent) {
        notificationService.handleNotification(notificationEvent);
        notificationProcessingService.processOrderCreateNotification(notificationEvent);
    }

    @KafkaListener(topics = "order-updated-status-topic")
    public void listenOrderUpdatedStatusTopic(NotificationEvent notificationEvent) {
        notificationProcessingService.processOrderUpdatedStatusNotification(notificationEvent);
    }
}

/* ===== notification-service\src\main\java\com\hau\notificationservice\controller\NotificationFirebaseController.java ===== */
package com.hau.notificationservice.controller;

import com.hau.notificationservice.dto.NotificationRequest;
import com.hau.notificationservice.dto.NotificationResponse;
import com.hau.notificationservice.service.FCMService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;

@RestController
@RequiredArgsConstructor
@Slf4j
public class NotificationFirebaseController {
    private final FCMService fcmService;

    @PostMapping("/firebase")
    public ResponseEntity sendNotification(@RequestBody NotificationRequest request) {
        if (request.getToken() != null && (request.getTokens() == null || request.getTokens().isEmpty())) {
            List<String> tokens = new ArrayList<>();
            tokens.add(request.getToken());
            request.setTokens(tokens);
        }

        fcmService.sendMessageToTokens(request);
        return new ResponseEntity<>(new NotificationResponse(HttpStatus.OK.value(), "Thông báo đã được gửi."), HttpStatus.OK);
    }
}

/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\ApiResponse.java ===== */
package com.hau.notificationservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\EmailRequest.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EmailRequest {
    private Sender sender;
    private List<Recipient> to;
    private String subject;
    private String htmlContent;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\EmailResponse.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EmailResponse {
    private String messageId;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\ErrorsResponse.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\FcmTokenCreateRequest.java ===== */
package com.hau.notificationservice.dto;


import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class FcmTokenCreateRequest {
    @NotBlank(message = "Token cannot be blank")
    private String token;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\FcmTokenResponse.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class FcmTokenResponse {
    private String id;
    private String token;
    private Integer userId;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\NotificationRequest.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.Map;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class NotificationRequest {
    private String title;
    private String body;
    private String topic;
    // Hỗ trợ cả token đơn lẻ và danh sách token
    private String token;
    private List<String> tokens;
    // Dữ liệu bổ sung
    private Map<String, String> data;
}

/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\NotificationResponse.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class NotificationResponse {
    private int status;
    private String message;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\Recipient.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Recipient {
    private String name;
    private String email;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\SendEmailRequest.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SendEmailRequest {
    private Recipient to;
    private String subject;
    private String htmlContent;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\dto\Sender.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Sender {
    private String name;
    private String email;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\entity\FcmToken.java ===== */
package com.hau.notificationservice.entity;

import lombok.*;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.MongoId;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Document(collection = "fcm_token")
public class FcmToken {
    @MongoId
    private String id;

    private Integer userId;
    @Indexed(unique = true)
    private String token;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\entity\Notification.java ===== */
package com.hau.notificationservice.entity;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.MongoId;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Document(collection = "notification")
public class Notification {
    @MongoId
    private String id;

    private String title;
    private String body;
    private String topic;
    private String token;
    private List<String> tokens;
    private Map<String, String> data;

    @CreatedDate
    private LocalDateTime createdAt;
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\exception\AppException.java ===== */
package com.hau.notificationservice.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\exception\GlobalExceptionHandler.java ===== */
package com.hau.notificationservice.exception;

import com.hau.notificationservice.dto.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions(Exception ex) {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\mapper\NotificationMapper.java ===== */
package com.hau.notificationservice.mapper;

import com.hau.notificationservice.dto.NotificationRequest;
import com.hau.notificationservice.entity.Notification;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface NotificationMapper {
    Notification toNotification(NotificationRequest notificationRequest);
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\repository\EmailClient.java ===== */
package com.hau.notificationservice.repository;

import com.hau.notificationservice.dto.EmailRequest;
import com.hau.notificationservice.dto.EmailResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;

@FeignClient(name = "email-client", url = "${app.email-service.url}")
public interface EmailClient {
    @PostMapping(value = "/v3/smtp/email", produces = MediaType.APPLICATION_JSON_VALUE)
    EmailResponse sendEmail(@RequestHeader("api-key") String apiKey,
                            @RequestBody EmailRequest emailRequest);
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\repository\FcmTokenRepository.java ===== */
package com.hau.notificationservice.repository;

import com.hau.notificationservice.entity.FcmToken;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface FcmTokenRepository extends MongoRepository<FcmToken, String> {
    List<FcmToken> findFcmTokenByUserId(Integer userId);
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\repository\NotificationRepository.java ===== */
package com.hau.notificationservice.repository;

import com.hau.notificationservice.entity.Notification;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface NotificationRepository extends MongoRepository<Notification, String> {
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\service\EmailService.java ===== */
package com.hau.notificationservice.service;

import com.hau.notificationservice.dto.EmailRequest;
import com.hau.notificationservice.dto.EmailResponse;
import com.hau.notificationservice.dto.SendEmailRequest;
import com.hau.notificationservice.dto.Sender;
import com.hau.notificationservice.exception.AppException;
import com.hau.notificationservice.repository.EmailClient;
import feign.FeignException;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class EmailService {
    private final EmailClient emailClient;

    @Value("${app.email-service.api-key}")
    private String apiKey;

    public EmailResponse sendEmail(SendEmailRequest sendEmailRequest) {
        EmailRequest emailRequest = EmailRequest.builder()
                .sender(Sender.builder()
                        .name("Hiệu sách Hà Nội")
                        .email("datdnk3@gmail.com")
                        .build())
                .to(List.of(sendEmailRequest.getTo()))
                .subject(sendEmailRequest.getSubject())
                .htmlContent(sendEmailRequest.getHtmlContent())
                .build();
        try {
            return emailClient.sendEmail(apiKey, emailRequest);
        } catch (FeignException e) {
            throw new AppException(HttpStatus.BAD_REQUEST,
                    "Gửi email thất bại",
                    e.getMessage());
        }
    }
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\service\FCMInitializer.java ===== */
package com.hau.notificationservice.service;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import java.io.IOException;

@Slf4j
@Service
public class FCMInitializer {
    @Value("${app.firebase-configuration-file}")
    private String firebaseConfigPath;

    @PostConstruct
    public void initialize() {
        try {
            FirebaseOptions options = new FirebaseOptions.Builder()
                    .setCredentials(GoogleCredentials.fromStream(new ClassPathResource(firebaseConfigPath).getInputStream())).build();
            if (FirebaseApp.getApps().isEmpty()) {
                FirebaseApp.initializeApp(options);
                log.info("Firebase application initialized");
            }
        } catch (IOException e) {
            log.error(e.getMessage());
        }
    }
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\service\FCMService.java ===== */
package com.hau.notificationservice.service;

import com.google.firebase.messaging.*;
import com.hau.notificationservice.dto.NotificationRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;

@Service
@Slf4j
public class FCMService {
    public void sendMessageToTokens(NotificationRequest request) {
        if (request.getTokens() == null || request.getTokens().isEmpty()) {
            log.error("No tokens provided for sending notifications");
            return;
        }

        List<String> successfulTokens = new ArrayList<>();
        List<String> failedTokens = new ArrayList<>();

        for (String token : request.getTokens()) {
            try {
                Message message = getPreconfiguredMessageToToken(request, token);
                String response = sendAndGetResponse(message);
                successfulTokens.add(token);
                log.info("Sent message to token: {}, response: {}", token, response);
            } catch (Exception e) {
                failedTokens.add(token);
                log.error("Failed to send message to token: {}, error: {}", token, e.getMessage());
            }
        }

        log.info("Notification sending summary: Success: {}, Failed: {}",
                successfulTokens.size(), failedTokens.size());

        if (!failedTokens.isEmpty()) {
            log.error("Failed tokens: {}", failedTokens);
        }
    }

    private String sendAndGetResponse(Message message) throws InterruptedException, ExecutionException {
        return FirebaseMessaging.getInstance().sendAsync(message).get();
    }

    private AndroidConfig getAndroidConfig(String topic) {
        return AndroidConfig.builder()
                .setTtl(Duration.ofMinutes(2).toMillis()).setCollapseKey(topic)
                .setPriority(AndroidConfig.Priority.HIGH)
                .setNotification(AndroidNotification.builder()
                        .setTag(topic).build()).build();
    }

    private ApnsConfig getApnsConfig(String topic) {
        return ApnsConfig.builder()
                .setAps(Aps.builder().setCategory(topic).setThreadId(topic).build()).build();
    }

    private Message getPreconfiguredMessageToToken(NotificationRequest request, String token) {
        return getPreconfiguredMessageBuilder(request)
                .setToken(token)
                .build();
    }

    private Message.Builder getPreconfiguredMessageBuilder(NotificationRequest request) {
        AndroidConfig androidConfig = getAndroidConfig(request.getTopic());
        ApnsConfig apnsConfig = getApnsConfig(request.getTopic());
        Notification notification = Notification.builder()
                .setTitle(request.getTitle())
                .setBody(request.getBody())
                .build();

        Message.Builder builder = Message.builder()
                .setApnsConfig(apnsConfig)
                .setAndroidConfig(androidConfig)
                .setNotification(notification);

        if (request.getData() != null && !request.getData().isEmpty()) {
            builder.putAllData(request.getData());
        }

        return builder;
    }
}

/* ===== notification-service\src\main\java\com\hau\notificationservice\service\FcmTokenService.java ===== */
package com.hau.notificationservice.service;

import com.hau.notificationservice.dto.ApiResponse;
import com.hau.notificationservice.dto.FcmTokenCreateRequest;
import com.hau.notificationservice.dto.FcmTokenResponse;
import com.hau.notificationservice.entity.FcmToken;
import com.hau.notificationservice.exception.AppException;
import com.hau.notificationservice.repository.FcmTokenRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class FcmTokenService {
    private final FcmTokenRepository fcmTokenRepository;

    public ApiResponse<FcmTokenResponse> fcmTokenResponseApiResponse(FcmTokenCreateRequest fcmTokenCreateRequest) {
        Integer userId = Integer.valueOf(SecurityContextHolder.getContext().getAuthentication().getName());
        FcmToken fcmToken = FcmToken.builder()
                .token(fcmTokenCreateRequest.getToken())
                .userId(userId)
                .build();
        try {
            fcmToken = fcmTokenRepository.save(fcmToken);
            return ApiResponse.<FcmTokenResponse>builder()
                    .status(201)
                    .message("Success")
                    .result(FcmTokenResponse.builder()
                            .id(fcmToken.getId())
                            .token(fcmToken.getToken())
                            .userId(userId)
                            .build())
                    .timestamp(LocalDateTime.now())
                    .build();
        } catch (DataIntegrityViolationException exception) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Token already exists", null);
        }
    }
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\service\NotificationProcessingService.java ===== */
package com.hau.notificationservice.service;

import com.hau.event.dto.NotificationEvent;
import com.hau.notificationservice.dto.NotificationRequest;
import com.hau.notificationservice.entity.FcmToken;
import com.hau.notificationservice.entity.Notification;
import com.hau.notificationservice.mapper.NotificationMapper;
import com.hau.notificationservice.repository.FcmTokenRepository;
import com.hau.notificationservice.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class NotificationProcessingService {
    private final FcmTokenRepository fcmTokenRepository;
    private final FCMService fcmService;
    private final NotificationMapper notificationMapper;
    private final NotificationRepository notificationRepository;

    public void processOrderCreateNotification(NotificationEvent notificationEvent) {
        Integer userId = (Integer) notificationEvent.getParams().get("userId");

        List<FcmToken> fcmTokens = fcmTokenRepository.findFcmTokenByUserId(userId);

        List<String> tokensToSend = fcmTokens.stream()
                .map(FcmToken::getToken)
                .toList();
        Map<String, String> data = new HashMap<>();
        data.put("orderId", notificationEvent.getParams().get("orderId").toString());
        NotificationRequest notificationRequest = NotificationRequest.builder()
                .topic("order created")
                .title("Đặt hàng thành công")
                .body("Đơn hàng của bạn đã được đặt thành công với mã đơn hàng: " + notificationEvent.getParams().get("orderId"))
                .tokens(tokensToSend)
                .data(data)
                .build();
        Notification notification = notificationMapper.toNotification(notificationRequest);
        notificationRepository.save(notification);
        fcmService.sendMessageToTokens(notificationRequest);
    }

    public void processOrderUpdatedStatusNotification(NotificationEvent notificationEvent) {
        Integer userId = (Integer) notificationEvent.getParams().get("userId");
        Integer oderStatus = (Integer) notificationEvent.getParams().get("orderStatus");

        List<FcmToken> fcmTokens = fcmTokenRepository.findFcmTokenByUserId(userId);

        List<String> tokensToSend = fcmTokens.stream()
                .map(FcmToken::getToken)
                .toList();
        Map<String, String> data = new HashMap<>();
        data.put("orderId", notificationEvent.getParams().get("orderId").toString());

        String notificationBody = getNotificationBody(oderStatus);

        NotificationRequest notificationRequest = NotificationRequest.builder()
                .topic("order updated")
                .title("Cập nhật trạng thái đơn hàng")
                .body(notificationBody)
                .tokens(tokensToSend)
                .data(data)
                .build();
        Notification notification = notificationMapper.toNotification(notificationRequest);
        notificationRepository.save(notification);
        fcmService.sendMessageToTokens(notificationRequest);
    }

    private static String getNotificationBody(Integer oderStatus) {
        String notificationBody;
        switch (oderStatus) {
            case 0 -> notificationBody = "Đơn hàng của bạn đã được giao thành công";
            case 1 -> notificationBody = "Đơn hàng của bạn đã được xác nhận";
            case 2 -> notificationBody = "Đơn hàng của bạn đang chờ đơn vị vận chuyển đến lấy hàng";
            case 3 -> notificationBody = "Đơn hàng của bạn đã được giao cho đơn vị vận chuyển";
            case 4 -> notificationBody = "Đơn hàng của bạn đã được hủy";
            default -> notificationBody = "Lỗi không xác định trạng thái đơn hàng";
        }
        return notificationBody;
    }
}


/* ===== notification-service\src\main\java\com\hau\notificationservice\service\NotificationService.java ===== */
package com.hau.notificationservice.service;

import com.google.firebase.messaging.*;
import com.hau.event.dto.NotificationEvent;
import com.hau.notificationservice.dto.Recipient;
import com.hau.notificationservice.dto.SendEmailRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.thymeleaf.context.Context;
import org.thymeleaf.spring6.SpringTemplateEngine;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationService {

    private final EmailService emailService;
    private final SpringTemplateEngine templateEngine;


    public void handleNotification(NotificationEvent notificationEvent) {
        String templateCode = notificationEvent.getTemplateCode();
        String subject;
        String htmlContent = switch (templateCode) {
            case "otp-email-template" -> {
                subject = "Mã OTP Xác Thực - Đặt Lại Mật Khẩu";
                yield processOtpTemplate(notificationEvent);
            }
            case "order-created-email-template" -> {
                subject = "Xác Nhận Đơn Hàng";
                yield processOrderTemplate(notificationEvent);
            }
            default -> throw new IllegalArgumentException("Template code không hợp lệ: " + templateCode);
        };

        emailService.sendEmail(SendEmailRequest.builder()
                .to(Recipient.builder()
                        .email(notificationEvent.getRecipient())
                        .build())
                .subject(subject)
                .htmlContent(htmlContent)
                .build());
    }

    private String processOtpTemplate(NotificationEvent notificationEvent) {
        Context context = new Context();
        Map<String, Object> params = notificationEvent.getParams();
        context.setVariable("username", params.get("username"));
        context.setVariable("otp", params.get("otp"));
        context.setVariable("expiryMinutes", params.get("expiryMinutes"));

        return templateEngine.process("otp-email-template", context);
    }

    private String processOrderTemplate(NotificationEvent notificationEvent) {
        Context context = new Context();
        Map<String, Object> params = notificationEvent.getParams();

        context.setVariable("username", params.get("username"));
        context.setVariable("fullName", params.get("fullName"));
        context.setVariable("orderId", params.get("orderId"));
        context.setVariable("totalPrice", params.get("totalPrice"));
        context.setVariable("address", params.get("address"));
        context.setVariable("phone", params.get("phone"));
        context.setVariable("paymentMethod", params.get("paymentMethod"));
        context.setVariable("paymentStatus", params.get("paymentStatus"));
        context.setVariable("status", params.get("status"));
        context.setVariable("note", params.get("note"));
        context.setVariable("createdAt", params.get("createdAt"));
        context.setVariable("orderProducts", params.get("orderProducts"));


        return templateEngine.process("order-created-email-template", context);
    }
}

/* ===== notification-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8088
  servlet:
    context-path: /notification
spring:
  application:
    name: notification-service
  data:
    mongodb:
      uri: mongodb://root:root@localhost:27017/notification_db?authSource=admin
  kafka:
    bootstrap-servers: localhost:9094
    consumer:
      group-id: notification-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
app:
  email-service:
    url: https://api.brevo.com
    api-key:
  firebase-configuration-file:


/* ===== notification-service\src\main\resources\application.yml ===== */
server:
  port: 8088
  servlet:
    context-path: /notification
spring:
  application:
    name: notification-service
  data:
    mongodb:
      uri: mongodb://root:123456789@localhost:27017/notification_db?authSource=admin
  kafka:
    bootstrap-servers: localhost:9094
    consumer:
      group-id: notification-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
app:
  email-service:
    url: https://api.brevo.com
    api-key:
  firebase-configuration-file:


/* ===== notification-service\src\main\resources\templates\order-created-email-template.html ===== */
<!DOCTYPE html>
<html lang="vi" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xác Nhận Đơn Hàng</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.7;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            font-size: 16px;  /* Tăng kích thước chữ cơ bản */
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #ffffff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .header {
            background-color: #4285f4;
            padding: 22px;
            text-align: center;
            color: white;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;  /* Tăng kích thước tiêu đề */
        }

        .content {
            padding: 12px;
            font-size: 14px;  /* Tăng kích thước nội dung */
        }
        .order-id-container {
            text-align: center;
            margin-bottom: 25px;
        }
        .order-id {
            font-size: 16px;  /* Tăng kích thước */
            font-weight: bold;
            color: #4285f4;
            display: inline-block;
            padding: 12px 24px;
            border: 2px solid #d1e0ff;
            background-color: #f5f8ff;
            border-radius: 6px;
        }
        .order-summary {
            background-color: #f5f8ff;
            border: 1px solid #d1e0ff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            font-size: 14px;  /* Tăng kích thước */
        }
        .status-container {
            display: flex;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .status-label {
            min-width: 166px;
            font-weight: bold;
            margin-right: 10px;
            font-size: 14px;
        }
        .order-status, .payment-status {
            display: inline-block;
            padding: 7px 14px;
            border-radius: 4px;
            margin-right: 10px;
            font-size: 16px;
            font-weight: bold;
        }
        .order-status {
            background-color: #e8f0fe;
            color: #4285f4;
        }
        .payment-status {
            background-color: #e6f4ea;
            color: #34a853;
        }
        .payment-pending {
            background-color: #ffe8e8;
            color: #e53935;
        }
        .info-item {
            display: flex;
            margin-bottom: 12px;
        }
        .info-label {
            font-weight: bold;
            min-width: 95px;  /* Tăng chiều rộng để phù hợp với nhãn dài hơn */
            margin-right: 10px;
        }
        .info-value {
            flex: 1;
        }
        .section-divider {
            height: 1px;
            background-color: #d1e0ff;
            margin: 20px 0;
        }
        .order-details {
            margin: 30px 0;
            padding: 14px;
            background-color: #f5f5f5;
            border-left: 5px solid #4285f4;
            font-size: 16px;
        }
        .order-details h3 {
            font-size: 18px;
            margin-top: 0;
        }
        .product-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 13px;
        }
        .product-table th, .product-table td {
            padding: 6px 0;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        .product-table th {
            background-color: #f5f8ff;
            font-size: 12px;
        }
        .total-price {
            font-size: 18px;  /* Tăng kích thước */
            font-weight: bold;
            text-align: right;
            color: #e53935;  /* Đổi sang màu đỏ */
            margin-top: 20px;
        }
        .note {
            font-style: italic;
            margin-top: 18px;
            padding: 15px;
            background-color: #fffde7;
            border-left: 4px solid #ffd600;
            font-size: 14px;
        }
        .footer {
            background-color: #f5f5f5;
            padding: 25px;
            text-align: center;
            font-size: 16px;
            color: #666;
        }
        .social-icons {
            margin-top: 18px;
        }
        .social-icons a {
            display: inline-block;
            margin: 0 10px;
            color: #4285f4;
            text-decoration: none;
            font-size: 16px;
        }

        @media (max-width: 576px) {
            .container {
                width: 100%;
                border-radius: 0;
            }
            .content {
                padding: 20px 4px;
            }
            .product-table {
                font-size: 14px;
            }
            .info-item {
                flex-direction: column;
            }
            .info-label {
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Xác Nhận Đơn Hàng</h1>
    </div>

    <div class="content">
        <p>Xin chào <strong th:text="${username}">Nguyễn Văn A</strong>!</p>

        <p>Cảm ơn bạn đã đặt hàng tại cửa hàng của chúng tôi. Đơn hàng của bạn đã được tiếp nhận và đang được xử lý.</p>

        <div class="order-id-container">
            <div class="order-id">Mã đơn hàng: <span th:text="${orderId}">#ORD12345</span></div>
        </div>

        <div class="order-summary">
            <div class="status-container">
                <div class="status-label">Trạng thái đơn hàng:</div>
                <div class="info-value" th:text="${status}">Chờ xác nhận</div>
            </div>
            <div class="status-container">
                <div class="status-label">Trạng thái thanh toán:</div>
                <div class="info-value" th:text="${paymentStatus}">Chưa thanh toán</div>
            </div>
            <div class="status-container">
                <div class="status-label">Ngày đặt hàng:</div>
                <div class="info-value" th:text="${createdAt[2] + '/' + createdAt[1] + '/' + createdAt[0] + ' ' + createdAt[3] + ':' + createdAt[4]}">01/05/2025 10:30</div>
            </div>
            <div class="status-container">
                <div class="status-label">Phương thức thanh toán:</div>
                <div class="info-value" th:text="${paymentMethod}">Thanh toán khi nhận hàng</div>
            </div>

            <div class="section-divider"></div>

            <div class="info-item">
                <div class="info-label">Người nhận:</div>
                <div class="info-value" th:text="${fullName}">Nguyễn Văn A</div>
            </div>
            <div class="info-item">
                <div class="info-label">Địa chỉ:</div>
                <div class="info-value" th:text="${address}">123 Đường ABC, Phường XYZ, Quận 123, TP Hà Nội</div>
            </div>
            <div class="info-item">
                <div class="info-label">Số điện thoại:</div>
                <div class="info-value" th:text="${phone}">0912345678</div>
            </div>
        </div>

        <div class="order-details">
            <h3>Chi tiết đơn hàng:</h3>
            <table class="product-table">
                <thead>
                <tr>
                    <th>Sản phẩm</th>
                    <th>Số lượng</th>
                    <th>Đơn giá</th>
                    <th>Thành tiền</th>
                </tr>
                </thead>
                <tbody>
                <tr th:each="product : ${orderProducts}">
                    <td th:text="${product.productName}">Tên sản phẩm</td>
                    <td style="right: 0" th:text="${product.quantity}">1</td>
                    <td style="right: 0" th:text="${#numbers.formatDecimal(product.price, 0, 'COMMA', 0, 'POINT')}">100.000 VNĐ</td>
                    <td style="right: 0" th:text="${#numbers.formatDecimal(product.price * product.quantity, 0, 'COMMA', 0, 'POINT')}">100.000 VNĐ</td>
                </tr>
                </tbody>
            </table>
            <div class="total-price">Tổng tiền: <span th:text="${#numbers.formatDecimal(totalPrice, 0, 'COMMA', 0, 'POINT')} + ' VNĐ'">300.000 VNĐ</span></div>

            <div th:if="${note != ''}" class="note">
                <strong>Ghi chú:</strong> <span th:text="${note}">Gọi điện trước khi giao hàng.</span>
            </div>
        </div>

        <p>Nếu bạn có bất kỳ câu hỏi hoặc thắc mắc nào về đơn hàng, vui lòng liên hệ với đội ngũ hỗ trợ của chúng tôi qua email <a href="mailto:support@example.com">hausupport@gmail.com</a> hoặc hotline <strong>1900 1009</strong>.</p>
    </div>

    <div class="footer">
        <p>Trân trọng,<br /><strong>Đội Ngũ Chăm Sóc Khách Hàng</strong></p>
        <p>© 2025 Đại học Kiến trúc Hà Nội. Tất cả các quyền được bảo lưu.</p>
        <p>Địa chỉ: Km 10, Đường Nguyễn Trãi, Quận Thanh Xuân, TP Hà Nội.</p>

        <div class="social-icons">
            <a href="#" title="Facebook">Facebook</a> |
            <a href="#" title="Instagram">Instagram</a> |
            <a href="#" title="LinkedIn">LinkedIn</a>
        </div>
    </div>
</div>
</body>
</html>

/* ===== notification-service\src\main\resources\templates\otp-email-template.html ===== */
<!DOCTYPE html>
<html lang="vi" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mã OTP Xác Thực - Đặt Lại Mật Khẩu</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background-color: #ffffff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .header {
            background-color: #4285f4;
            padding: 20px;
            text-align: center;
            color: white;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
        }

        .content {
            padding: 30px;
        }
        .otp-container {
            background-color: #f5f8ff;
            border: 1px solid #d1e0ff;
            border-radius: 6px;
            padding: 15px;
            margin: 25px 0;
            text-align: center;
        }
        .otp-code {
            font-size: 32px;
            font-weight: bold;
            color: #4285f4;
            letter-spacing: 4px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        .timer {
            background-color: #ffe8e8;
            border-radius: 4px;
            padding: 8px 15px;
            display: inline-block;
            margin-top: 15px;
            font-weight: bold;
            color: #e53935;
        }
        .instructions {
            margin: 25px 0;
            padding: 15px;
            background-color: #f5f5f5;
            border-left: 4px solid #4285f4;
        }
        .footer {
            background-color: #f5f5f5;
            padding: 20px;
            text-align: center;
            font-size: 14px;
            color: #666;
        }
        .social-icons {
            margin-top: 15px;
        }
        .social-icons a {
            display: inline-block;
            margin: 0 10px;
            color: #4285f4;
            text-decoration: none;
        }
        .warning {
            color: #e53935;
            font-weight: bold;
        }

        @media only screen and (max-width: 600px) {
            .container {
                width: 100%;
                border-radius: 0;
            }
            .content {
                padding: 20px 15px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Xác Thực Tài Khoản</h1>
    </div>

    <div class="content">
        <p>Xin chào <strong th:text="${username}">admin</strong>!</p>

        <p>Chúng tôi đã nhận được yêu cầu đặt lại mật khẩu cho tài khoản của bạn. Để tiếp tục quá trình này, vui lòng sử dụng mã OTP dưới đây:</p>

        <div class="otp-container">
            <p>Mã OTP của bạn là</p>
            <div class="otp-code" th:text="${otp}">123456</div>
            <div class="timer">
                Hết hạn sau <strong th:text="${expiryMinutes}">5</strong> phút
            </div>
        </div>

        <div class="instructions">
            <h3>Hướng dẫn:</h3>
            <ol>
                <li>Nhập mã OTP trên vào trang đặt lại mật khẩu.</li>
                <li>Tạo mật khẩu mới an toàn cho tài khoản của bạn.</li>
                <li>Đăng nhập bằng mật khẩu mới.</li>
            </ol>
        </div>

        <p class="warning">⚠️ Lưu ý quan trọng:</p>
        <ul>
            <li>Không chia sẻ mã OTP này với bất kỳ ai, kể cả nhân viên của chúng tôi.</li>
            <li>Mã OTP chỉ có hiệu lực trong vòng <strong th:text="${expiryMinutes}">5</strong> phút và chỉ sử dụng được 1 lần.</li>
            <li>Nếu bạn không yêu cầu đặt lại mật khẩu, vui lòng bỏ qua email này và kiểm tra tài khoản của bạn.</li>
        </ul>

        <p>Nếu bạn gặp khó khăn hoặc cần trợ giúp, hãy liên hệ với đội ngũ hỗ trợ của chúng tôi qua email <a href="mailto:support@example.com">hausupport@gmail.com</a> hoặc hotline <strong>1900 1009</strong>.</p>
    </div>

    <div class="footer">
        <p>Trân trọng,<br /><strong>Đội Ngũ Quản Trị Viên</strong></p>
        <p>© 2025 Đại học Kiến trúc Hà Nội. Tất cả các quyền được bảo lưu.</p>
        <p>Địa chỉ: Km 10, Đường Nguyễn Trãi, Quận Thanh Xuân , TP Hà Nội.</p>

        <div class="social-icons">
            <a href="#" title="Facebook">Facebook</a> |
            <a href="#" title="Instagram">Instagram</a> |
            <a href="#" title="LinkedIn">LinkedIn</a>
        </div>
    </div>
</div>
</body>
</html>

/* ===== notification-service\src\test\java\com\hau\notificationservice\NotificationServiceApplicationTests.java ===== */
package com.hau.notificationservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class NotificationServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


/* ===== order-service\doc.txt ===== */
/* ===== orderservice/config/CustomJwtDecoder.java ===== */
package com.hau.orderservice.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== orderservice/config/JwtAuthenticationEntryPoint.java ===== */
package com.hau.orderservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.orderservice.dto.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== orderservice/config/SecurityConfig.java ===== */
package com.hau.orderservice.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {

    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== orderservice/controller/OrderController.java ===== */
package com.hau.orderservice.controller;

import com.hau.orderservice.dto.ApiResponse;
import com.hau.orderservice.dto.OrderCreateRequest;
import com.hau.orderservice.dto.OrderResponse;
import com.hau.orderservice.service.OrderService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
public class OrderController {
    private final OrderService orderService;

    @PostMapping
    public ResponseEntity<ApiResponse<OrderResponse>> createOrder(@Valid @RequestBody OrderCreateRequest orderCreateRequest){
        ApiResponse<OrderResponse> apiResponse = orderService.createOrder(orderCreateRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }
}


/* ===== orderservice/controller/ProfileController.java ===== */
package com.hau.orderservice.controller;

import com.hau.event.dto.ProfileCreateEvent;
import com.hau.orderservice.service.ProfileService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class ProfileController {
    private final ProfileService profileService;
    @KafkaListener(topics = "profile-create-event")
    public void handleProfileCreateEvent(ProfileCreateEvent profileCreateEvent) {
        log.info("Received ProfileCreateEvent: {}", profileCreateEvent);
        profileService.saveProfile(profileCreateEvent);
    }
}


/* ===== orderservice/dto/ApiResponse.java ===== */
package com.hau.orderservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== orderservice/dto/ErrorsResponse.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    int status;
    String message;
    Object error;
    LocalDateTime timestamp;
}


/* ===== orderservice/dto/OrderCreateRequest.java ===== */
package com.hau.orderservice.dto;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderCreateRequest {
    @NotNull(message = "Mã địa chỉ nhận hàng không được để trống")
    private Long profileId;
    private Integer status;
    private Integer paymentMethod;
    private Integer paymentStatus;
    private String note;

    private Set<OrderProductCreateRequest> orderProducts;
}


/* ===== orderservice/dto/OrderProductCreateRequest.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderProductCreateRequest {
    private Integer productId;
    private Integer quantity;
}


/* ===== orderservice/dto/OrderProductResponse.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderProductResponse {
    private Long id;

    private Long orderId;
    private Integer productId;
    private String productName;
    private Integer price;
    private Integer quantity;
}


/* ===== orderservice/dto/OrderResponse.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderResponse {
    private Long id;
    private Integer userId;
    private Long profileId;
    private String fullName;
    private String phone;
    private String address;
    private Integer status;
    private Integer paymentMethod;
    private Integer paymentStatus;
    private String note;

    private Set<OrderProductResponse> orderProducts;
}


/* ===== orderservice/dto/PageResponse.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}


/* ===== orderservice/entity/Order.java ===== */
package com.hau.orderservice.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "orders")
@Getter
@Setter
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Integer userId;
    private Long profileId;
    private String fullName;
    private String phone;
    private String address;
    private Integer status;
    private Integer paymentMethod;
    private Integer paymentStatus;
    private String note;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<OrderProduct> orderProducts = new HashSet<>();
}


/* ===== orderservice/entity/OrderProduct.java ===== */
package com.hau.orderservice.entity;

import jakarta.persistence.*;
import lombok.*;

@Builder
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "order_products")
public class OrderProduct {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
    private Integer productId;
    private String productName;
    private Integer price;
    private Integer quantity;
}


/* ===== orderservice/entity/Product.java ===== */
package com.hau.orderservice.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.*;

@Entity
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "products")
@Getter
@Setter
public class Product {
    @Id
    private Integer id;
    private String title;
    private Integer quantity;
    private Integer discount;
    private Integer price;
    private boolean active;
}


/* ===== orderservice/entity/Profile.java ===== */
package com.hau.orderservice.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.*;

@Entity
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "profiles")
@Getter
@Setter
public class Profile {
    @Id
    private Long id;
    private Integer userId;
    private String fullName;
    private String phone;
    private String address;
}


/* ===== orderservice/exception/AppException.java ===== */
package com.hau.orderservice.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== orderservice/exception/GlobalExceptionHandler.java ===== */
package com.hau.orderservice.exception;

import com.hau.orderservice.dto.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions(Exception ex) {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== orderservice/mapper/OrderMapper.java ===== */
package com.hau.orderservice.mapper;

import com.hau.orderservice.dto.OrderCreateRequest;
import com.hau.orderservice.dto.OrderResponse;
import com.hau.orderservice.entity.Order;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface OrderMapper {
    @Mapping(target = "orderProducts", ignore = true)
    Order toOrder(OrderCreateRequest orderCreateRequest);

    OrderResponse toOrderResponse(Order order);
}


/* ===== orderservice/mapper/OrderProductMapper.java ===== */
package com.hau.orderservice.mapper;

import com.hau.orderservice.dto.OrderProductCreateRequest;
import com.hau.orderservice.dto.OrderProductResponse;
import com.hau.orderservice.entity.OrderProduct;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface OrderProductMapper {
    OrderProduct toOrderProduct(OrderProductCreateRequest orderProductCreateRequest);

    OrderProductResponse toOrderProductResponse(OrderProduct orderProduct);
}


/* ===== orderservice/OrderServiceApplication.java ===== */
package com.hau.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

}


/* ===== orderservice/repository/OrderProductRepository.java ===== */
package com.hau.orderservice.repository;

import com.hau.orderservice.entity.OrderProduct;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderProductRepository extends JpaRepository<OrderProduct, Long> {
}


/* ===== orderservice/repository/OrderRepository.java ===== */
package com.hau.orderservice.repository;

import com.hau.orderservice.entity.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
}


/* ===== orderservice/repository/ProfileRepository.java ===== */
package com.hau.orderservice.repository;

import com.hau.orderservice.entity.Profile;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ProfileRepository extends JpaRepository<Profile, Long> {
}


/* ===== orderservice/service/OrderService.java ===== */
package com.hau.orderservice.service;

import com.hau.orderservice.dto.ApiResponse;
import com.hau.orderservice.dto.OrderCreateRequest;
import com.hau.orderservice.dto.OrderResponse;
import com.hau.orderservice.entity.Order;
import com.hau.orderservice.entity.OrderProduct;
import com.hau.orderservice.entity.Profile;
import com.hau.orderservice.exception.AppException;
import com.hau.orderservice.mapper.OrderMapper;
import com.hau.orderservice.mapper.OrderProductMapper;
import com.hau.orderservice.repository.OrderProductRepository;
import com.hau.orderservice.repository.OrderRepository;
import com.hau.orderservice.repository.ProfileRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepository;
    private final OrderMapper orderMapper;
    private final ProfileRepository profileRepository;
    private final OrderProductMapper orderProductMapper;

    public ApiResponse<OrderResponse> createOrder(OrderCreateRequest orderCreateRequest) {
        var authenticatedUser = SecurityContextHolder.getContext().getAuthentication().getName();
        Integer userId = Integer.valueOf(authenticatedUser);
        Profile profile = profileRepository.findById(orderCreateRequest.getProfileId())
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Địa chỉ nhận hàng không tồn tại", null));
        if (!Objects.equals(userId, profile.getUserId())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Địa chỉ nhận hàng không thuộc về bạn", null);
        }
        Order order = orderMapper.toOrder(orderCreateRequest);
        order.setUserId(userId);
        order.setAddress(profile.getAddress());
        order.setFullName(profile.getFullName());
        order.setPhone(profile.getPhone());

        Set<OrderProduct> orderProducts = orderCreateRequest.getOrderProducts().stream()
                .map(orderProductMapper::toOrderProduct)
                .collect(Collectors.toSet());
        orderProducts.forEach(orderProduct -> {
            order.setOrderProducts(orderProducts);
            orderProduct.setOrder(order);
        });
        Order savedOrder = orderRepository.save(order);

        return ApiResponse.<OrderResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo đơn hàng thành công")
                .result(orderMapper.toOrderResponse(savedOrder))
                .timestamp(LocalDateTime.now())
                .build();
    }

}


/* ===== orderservice/service/ProfileService.java ===== */
package com.hau.orderservice.service;

import com.hau.event.dto.ProfileCreateEvent;
import com.hau.orderservice.entity.Profile;
import com.hau.orderservice.repository.ProfileRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@RequiredArgsConstructor
@Service
public class ProfileService {
    private final ProfileRepository profileRepository;

    public void saveProfile(ProfileCreateEvent profileCreateEvent) {
        Profile profile = Profile.builder()
                .id(profileCreateEvent.getId())
                .userId(profileCreateEvent.getUserId())
                .fullName(profileCreateEvent.getFullName())
                .phone(profileCreateEvent.getPhone())
                .address(profileCreateEvent.getAddress())
                .build();
        profileRepository.save(profile);

    }
}




/* ===== order-service\src\main\java\com\hau\event\dto\NotificationEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationEvent {
    private String channel;
    private String recipient;
    private String templateCode;
    private Map<String, Object> params;
}


/* ===== order-service\src\main\java\com\hau\event\dto\OrderCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderCreateEvent {
    private Long orderId;
    private Integer userId;
    private Integer totalPrice;
    private Integer paymentMethod;
    private Integer paymentStatus;
}


/* ===== order-service\src\main\java\com\hau\event\dto\PaymentCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PaymentCreateEvent {
    private Long orderId;
    private Integer paymentStatus;
}


/* ===== order-service\src\main\java\com\hau\event\dto\ProductEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductEvent {
    private Long id;
    private Integer discount;
    private Integer price;
    private Integer quantity;
    private String title;
}


/* ===== order-service\src\main\java\com\hau\event\dto\ProfileCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProfileCreateEvent {
    private Long id;
    private Integer userId;
    private String fullName;
    private String phone;
    private String address;
}


/* ===== order-service\src\main\java\com\hau\event\dto\UserCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCreateEvent {
    private Integer id;
    private String email;
    private String username;
}


/* ===== order-service\src\main\java\com\hau\orderservice\OrderServiceApplication.java ===== */
package com.hau.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

}


/* ===== order-service\src\main\java\com\hau\orderservice\config\CustomJwtDecoder.java ===== */
package com.hau.orderservice.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.orderservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.orderservice.dto.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\config\SecurityConfig.java ===== */
package com.hau.orderservice.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {

    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== order-service\src\main\java\com\hau\orderservice\controller\OrderController.java ===== */
package com.hau.orderservice.controller;

import com.hau.orderservice.dto.*;
import com.hau.orderservice.service.OrderService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
public class OrderController {
    private final OrderService orderService;

    @PostMapping
    public ResponseEntity<ApiResponse<OrderResponse>> createOrder(@Valid @RequestBody OrderCreateRequest orderCreateRequest) {
        ApiResponse<OrderResponse> apiResponse = orderService.createOrder(orderCreateRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @GetMapping
    public ResponseEntity<ApiResponse<PageResponse<OrderResponse>>> getAllOrders(
            @RequestParam(defaultValue = "1", required = false) int pageIndex,
            @RequestParam(defaultValue = "10", required = false) int pageSize,
            @RequestParam(required = false) String createdAt,
            @RequestParam(required = false) Integer paymentStatus,
            @RequestParam(required = false) Integer paymentMethod
    ) {
        ApiResponse<PageResponse<OrderResponse>> apiResponse = orderService.getAllOrders(pageIndex, pageSize, createdAt, paymentStatus, paymentMethod);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @GetMapping("/{orderId}")
    public ResponseEntity<ApiResponse<OrderResponse>> getOrderByIdForAdmin(@PathVariable Long orderId) {
        ApiResponse<OrderResponse> apiResponse = orderService.getOrderById(orderId);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping("/my-orders")
    public ResponseEntity<ApiResponse<PageResponse<OrderResponse>>> getMyOrders(
            @RequestParam(defaultValue = "1", required = false) int pageIndex,
            @RequestParam(defaultValue = "10", required = false) int pageSize
    ) {
        ApiResponse<PageResponse<OrderResponse>> apiResponse = orderService.getOrdersByUserId(pageIndex, pageSize);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping("/my-orders/{orderId}")
    public ResponseEntity<ApiResponse<OrderResponse>> getMyOrderById(@PathVariable Long orderId) {
        ApiResponse<OrderResponse> apiResponse = orderService.getOrderByIdForUser(orderId);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("{orderId}/cancer")
    public ResponseEntity<ApiResponse<String>> cancerOrder(@PathVariable Long orderId, @RequestBody CancerOrderRequest cancerOrderRequest) {
        ApiResponse<String> apiResponse = orderService.cancerOrder(orderId, cancerOrderRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @PatchMapping("/{orderId}")
    public ResponseEntity<ApiResponse<OrderResponse>> updateOrderStatus(@Valid @PathVariable Long orderId, @RequestBody OrderUpdateStatus orderUpdateStatus) {
        ApiResponse<OrderResponse> apiResponse = orderService.updateOrderStatus(orderUpdateStatus, orderId);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\controller\PaymentController.java ===== */
package com.hau.orderservice.controller;

import com.hau.event.dto.PaymentCreateEvent;
import com.hau.orderservice.service.OrderService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

@Component
@Slf4j
@RequiredArgsConstructor
public class PaymentController {
    private final OrderService orderService;

    @KafkaListener(topics = "payment-create-topic")
    public void handlePaymentCreateEvent(PaymentCreateEvent paymentCreateEvent) {
        orderService.updatePaymentStatus(paymentCreateEvent);
    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\controller\ProductController.java ===== */
package com.hau.orderservice.controller;

import com.hau.event.dto.ProductEvent;
import com.hau.orderservice.service.ProductService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class ProductController {
    private final ProductService productService;

    @KafkaListener(topics = "product-create-topic")
    public void consumeProductCreateEvent(ProductEvent message) {
        log.info("Received message from product-create-topic: {}", message);
        productService.saveProduct(message);
    }

    @KafkaListener(topics = "product-update-topic")
    public void consumeProductUpdateEvent(ProductEvent message) {
        log.info("Received message from product-update-topic: {}", message);
        productService.updateProduct(message);
    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\controller\ProfileController.java ===== */
package com.hau.orderservice.controller;

import com.hau.event.dto.ProfileCreateEvent;
import com.hau.orderservice.service.ProfileService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class ProfileController {
    private final ProfileService profileService;
    @KafkaListener(topics = "profile-create-event")
    public void handleProfileCreateEvent(ProfileCreateEvent profileCreateEvent) {
        log.info("Received ProfileCreateEvent: {}", profileCreateEvent);
        profileService.saveProfile(profileCreateEvent);
    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\controller\UserController.java ===== */
package com.hau.orderservice.controller;

import com.hau.event.dto.UserCreateEvent;
import com.hau.orderservice.entity.User;
import com.hau.orderservice.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Controller;

@Controller
@Slf4j
@RequiredArgsConstructor
public class UserController {
    private final UserRepository userRepository;

    @KafkaListener(topics = "user-created-topic")
    public void handleUserCreateEvent(UserCreateEvent userCreateEvent) {
        User user = User.builder()
                .id(userCreateEvent.getId())
                .email(userCreateEvent.getEmail())
                .build();
        userRepository.save(user);
    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\dto\ApiResponse.java ===== */
package com.hau.orderservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== order-service\src\main\java\com\hau\orderservice\dto\CancerOrderRequest.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CancerOrderRequest {
    private String note;
}


/* ===== order-service\src\main\java\com\hau\orderservice\dto\ErrorsResponse.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    int status;
    String message;
    Object error;
    LocalDateTime timestamp;
}


/* ===== order-service\src\main\java\com\hau\orderservice\dto\OrderCreateRequest.java ===== */
package com.hau.orderservice.dto;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderCreateRequest {
    @NotNull(message = "Mã địa chỉ nhận hàng không được để trống")
    private Long profileId;
    private Integer paymentMethod;
    private String note;

    private Set<OrderProductCreateRequest> orderProducts;
}


/* ===== order-service\src\main\java\com\hau\orderservice\dto\OrderProductCreateRequest.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderProductCreateRequest {
    private Long productId;
    private Integer quantity;
}


/* ===== order-service\src\main\java\com\hau\orderservice\dto\OrderProductResponse.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderProductResponse {
    private Long id;
    private Integer productId;
    private String productName;
    private Integer price;
    private Integer quantity;
}


/* ===== order-service\src\main\java\com\hau\orderservice\dto\OrderResponse.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderResponse {
    private Long id;
    private Integer userId;
    private Long profileId;
    private String fullName;
    private String phone;
    private String address;
    private Integer status;
    private Integer paymentMethod;
    private Integer paymentStatus;
    private Integer totalPrice;
    private String note;
    private LocalDateTime createdAt;

    private Set<OrderProductResponse> orderProducts;
}


/* ===== order-service\src\main\java\com\hau\orderservice\dto\OrderUpdateStatus.java ===== */
package com.hau.orderservice.dto;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderUpdateStatus {
    @NotNull(message = "Trang thái đơn hàng không được để trống")
    private Integer status;
}


/* ===== order-service\src\main\java\com\hau\orderservice\dto\PageResponse.java ===== */
package com.hau.orderservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}


/* ===== order-service\src\main\java\com\hau\orderservice\entity\Order.java ===== */
package com.hau.orderservice.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "orders")
@Getter
@Setter
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Integer userId;
    private Long profileId;
    private String fullName;
    private String phone;
    private String address;
    private Integer status;
    private Integer paymentMethod;
    private Integer paymentStatus;
    private Integer totalPrice;
    private String note;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<OrderProduct> orderProducts = new HashSet<>();
}


/* ===== order-service\src\main\java\com\hau\orderservice\entity\OrderProduct.java ===== */
package com.hau.orderservice.entity;

import jakarta.persistence.*;
import lombok.*;

@Builder
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "order_products")
public class OrderProduct {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
    private Integer cartProductId;
    private Long productId;
    private String productName;
    private Integer price;
    private Integer quantity;
}


/* ===== order-service\src\main\java\com\hau\orderservice\entity\Product.java ===== */
package com.hau.orderservice.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.*;

@Entity
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "products")
@Getter
@Setter
public class Product {
    @Id
    private Long id;
    private String title;
    private Integer quantity;
    private Integer discount;
    private Integer price;
}


/* ===== order-service\src\main\java\com\hau\orderservice\entity\Profile.java ===== */
package com.hau.orderservice.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.*;

@Entity
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "profiles")
@Getter
@Setter
public class Profile {
    @Id
    private Long id;
    private Integer userId;
    private String fullName;
    private String phone;
    private String address;
}


/* ===== order-service\src\main\java\com\hau\orderservice\entity\User.java ===== */
package com.hau.orderservice.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "users")
public class User {
    @Id
    private Integer id;
    private String email;
    private String username;
}


/* ===== order-service\src\main\java\com\hau\orderservice\exception\AppException.java ===== */
package com.hau.orderservice.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\exception\GlobalExceptionHandler.java ===== */
package com.hau.orderservice.exception;

import com.hau.orderservice.dto.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions(Exception ex) {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\mapper\OrderMapper.java ===== */
package com.hau.orderservice.mapper;

import com.hau.orderservice.dto.OrderCreateRequest;
import com.hau.orderservice.dto.OrderResponse;
import com.hau.orderservice.entity.Order;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface OrderMapper {
    @Mapping(target = "orderProducts", ignore = true)
    Order toOrder(OrderCreateRequest orderCreateRequest);

    OrderResponse toOrderResponse(Order order);
}


/* ===== order-service\src\main\java\com\hau\orderservice\repository\OrderProductRepository.java ===== */
package com.hau.orderservice.repository;

import com.hau.orderservice.entity.OrderProduct;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderProductRepository extends JpaRepository<OrderProduct, Long> {
}


/* ===== order-service\src\main\java\com\hau\orderservice\repository\OrderRepository.java ===== */
package com.hau.orderservice.repository;

import com.hau.orderservice.entity.Order;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long>, JpaSpecificationExecutor<Order> {
    Optional<Order> findByIdAndUserId(Long id, Integer userId);
    Page<Order> findAllByUserId(Integer userId, Pageable pageable);
}


/* ===== order-service\src\main\java\com\hau\orderservice\repository\ProductRepository.java ===== */
package com.hau.orderservice.repository;

import com.hau.orderservice.entity.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
}


/* ===== order-service\src\main\java\com\hau\orderservice\repository\ProfileRepository.java ===== */
package com.hau.orderservice.repository;

import com.hau.orderservice.entity.Profile;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ProfileRepository extends JpaRepository<Profile, Long> {
}


/* ===== order-service\src\main\java\com\hau\orderservice\repository\UserRepository.java ===== */
package com.hau.orderservice.repository;

import com.hau.orderservice.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Integer> {
}


/* ===== order-service\src\main\java\com\hau\orderservice\service\OrderService.java ===== */
package com.hau.orderservice.service;

import com.hau.event.dto.NotificationEvent;
import com.hau.event.dto.OrderCreateEvent;
import com.hau.event.dto.PaymentCreateEvent;
import com.hau.orderservice.dto.*;
import com.hau.orderservice.entity.*;
import com.hau.orderservice.exception.AppException;
import com.hau.orderservice.mapper.OrderMapper;
import com.hau.orderservice.repository.OrderRepository;
import com.hau.orderservice.repository.ProductRepository;
import com.hau.orderservice.repository.ProfileRepository;
import com.hau.orderservice.repository.UserRepository;
import jakarta.persistence.criteria.Predicate;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

@Service
@RequiredArgsConstructor
@Slf4j
public class OrderService {
    private final OrderRepository orderRepository;
    private final OrderMapper orderMapper;
    private final ProfileRepository profileRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    public ApiResponse<OrderResponse> createOrder(OrderCreateRequest orderCreateRequest) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        Integer userId = Integer.valueOf(authentication.getName());
        Profile profile = profileRepository.findById(orderCreateRequest.getProfileId())
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Địa chỉ nhận hàng không tồn tại", null));

        if (!Objects.equals(userId, profile.getUserId())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Địa chỉ nhận hàng không thuộc về bạn", null);
        }

        // Map OrderCreateRequest to base Order entity and populate profile details
        Order order = orderMapper.toOrder(orderCreateRequest);
        order.setUserId(userId);
        order.setAddress(profile.getAddress());
        order.setFullName(profile.getFullName());
        order.setPhone(profile.getPhone());

        Set<OrderProduct> orderProductsEntitySet = new HashSet<>();

        if (orderCreateRequest.getOrderProducts() == null || orderCreateRequest.getOrderProducts().isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Đơn hàng phải có ít nhất một sản phẩm", null);
        }
        int totalPrice = 0;
        for (OrderProductCreateRequest itemRequest : orderCreateRequest.getOrderProducts()) {
            Product product = productRepository.findById(itemRequest.getProductId())
                    .orElseThrow(() -> new AppException(
                            HttpStatus.NOT_FOUND, "Sản phẩm với ID " + itemRequest.getProductId() + " không tồn tại", null));

            if (product.getQuantity() < itemRequest.getQuantity()) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Sản phẩm " + product.getTitle() + " chỉ còn " + product.getQuantity() + " sản phẩm trong kho", null);
            }

            // Create OrderProduct entity
            OrderProduct orderProduct = OrderProduct.builder()
                    .productId(itemRequest.getProductId())
                    .quantity(itemRequest.getQuantity())
                    .productName(product.getTitle())
                    .price(product.getPrice())
                    .order(order)
                    .build();
            product.setQuantity(product.getQuantity() - itemRequest.getQuantity());
            orderProductsEntitySet.add(orderProduct);
            totalPrice += product.getPrice() * itemRequest.getQuantity();
        }
        order.setPaymentStatus(1);
        order.setStatus(1);
        order.setOrderProducts(orderProductsEntitySet);
        order.setTotalPrice(totalPrice);
        orderRepository.save(order);

        if (order.getPaymentMethod() == 0) {
            sendNotification(userId, order);
        } else {
            OrderCreateEvent orderCreateEvent = OrderCreateEvent.builder()
                    .orderId(order.getId())
                    .userId(order.getUserId())
                    .totalPrice(order.getTotalPrice())
                    .paymentMethod(order.getPaymentMethod())
                    .paymentStatus(order.getPaymentStatus())
                    .build();
            kafkaTemplate.send("order-create-topic", orderCreateEvent);
        }

        return ApiResponse.<OrderResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo đơn hàng thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<String> cancerOrder(Long id, CancerOrderRequest cancerOrderRequest) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        Integer userId = Integer.valueOf(authentication.getName());

        Order order = orderRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Đơn hàng không tồn tại", null));
        if (!Objects.equals(userId, order.getUserId())) {
            throw new AppException(HttpStatus.UNAUTHORIZED, "Không có quyền truy cập tài nguyên này", null);
        }
        if (order.getStatus() == 5) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Đơn hàng đã bị huỷ", null);
        }
        if (order.getStatus() == 3) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Đơn hàng đang được vận chuyển", null);
        }
        if (order.getStatus() == 0) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Đơn hàng đã được giao thành công", null);
        }
        order.setStatus(5);
        order.setNote(cancerOrderRequest.getNote());
        orderRepository.save(order);
        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Hủy đơn hàng thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    public void updatePaymentStatus(PaymentCreateEvent paymentCreateEvent) {
        Order order = orderRepository.findById(paymentCreateEvent.getOrderId())
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Đơn hàng không tồn tại", null));
        order.setPaymentStatus(paymentCreateEvent.getPaymentStatus());
        orderRepository.save(order);
        Integer userId = order.getUserId();
        sendNotification(userId, order);
    }

    public ApiResponse<OrderResponse> updateOrderStatus(OrderUpdateStatus orderUpdateStatus, Long id) {
        Order order = orderRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Đơn hàng không tồn tại", null));
        order.setStatus(orderUpdateStatus.getStatus());
        orderRepository.save(order);
        NotificationEvent notificationEvent = NotificationEvent.builder()
                .params(
                        Map.ofEntries(
                                Map.entry("userId", order.getUserId()),
                                Map.entry("orderId", order.getId()),
                                Map.entry("orderStatus", order.getStatus())
                        )
                )
                .build();
        kafkaTemplate.send("order-updated-status-topic", notificationEvent);
        return ApiResponse.<OrderResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật trạng thái đơn hàng thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<OrderResponse> getOrderById(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Đơn hàng không tồn tại", null));
        OrderResponse orderResponse = orderMapper.toOrderResponse(order);
        return ApiResponse.<OrderResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin đơn hàng thành công")
                .result(orderResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<OrderResponse> getOrderByIdForUser(Long orderId) {
        Integer userId = Integer.valueOf(SecurityContextHolder.getContext().getAuthentication().getName());
        Order order = orderRepository.findByIdAndUserId(orderId, userId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Đơn hàng này không thuộc về bạn", null));
        OrderResponse orderResponse = orderMapper.toOrderResponse(order);
        return ApiResponse.<OrderResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin đơn hàng thành công")
                .result(orderResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public void sendNotification(Integer userId, Order order) {
        NotificationEvent notificationEvent = new NotificationEvent();
        notificationEvent.setChannel("EMAIL");
        notificationEvent.setRecipient(
                userRepository.findById(userId).orElseThrow().getEmail()
        );
        notificationEvent.setTemplateCode("order-created-email-template");
        notificationEvent.setParams(Map.ofEntries(
                Map.entry("userId", userId),
                Map.entry("fullName", order.getFullName()),
                Map.entry("orderId", order.getId()),
                Map.entry("totalPrice", order.getTotalPrice()),
                Map.entry("address", order.getAddress()),
                Map.entry("phone", order.getPhone()),
                Map.entry("paymentMethod", order.getPaymentMethod() == 0 ? "COD" : order.getPaymentMethod() == 1 ? "VNPAY" : "MOMO"),
                Map.entry("paymentStatus", order.getPaymentStatus() == 0 ? "Đã thanh toán" : "Chưa thanh toán"),
                Map.entry("status", order.getStatus() == 1 ? "Chờ xác nhận" : "Chờ vận chuyển"),
                Map.entry("note", order.getNote() == null ? "" : order.getNote()),
                Map.entry("createdAt", order.getCreatedAt()),
                Map.entry("orderProducts", order.getOrderProducts().stream()
                        .map(orderProduct -> Map.of(
                                "productId", orderProduct.getProductId(),
                                "productName", orderProduct.getProductName(),
                                "quantity", orderProduct.getQuantity(),
                                "price", orderProduct.getPrice()))
                        .toList()
                )));
        kafkaTemplate.send("order-create-notification-topic", notificationEvent);
    }

    public ApiResponse<PageResponse<OrderResponse>> getAllOrders(int page, int size, String createdAt, Integer paymentStatus, Integer paymentMethod) {
        Sort sort = Sort.by(Sort.Direction.DESC, "createdAt");
        Pageable pageable = PageRequest.of(page - 1, size, sort);

        Specification<Order> spec = getSpecification(createdAt, paymentStatus, paymentMethod);

        Page<Order> orderPage = orderRepository.findAll(spec, pageable);
        return getPageResponseApiResponse(page, orderPage);
    }

    public ApiResponse<PageResponse<OrderResponse>> getOrdersByUserId(int page, int size) {
        Integer userId = Integer.valueOf(SecurityContextHolder.getContext().getAuthentication().getName());
        Sort sort = Sort.by(Sort.Direction.DESC, "createdAt");
        Pageable pageable = PageRequest.of(page - 1, size, sort);
        Page<Order> orderPage = orderRepository.findAllByUserId(userId, pageable);
        return getPageResponseApiResponse(page, orderPage);
    }

    private ApiResponse<PageResponse<OrderResponse>> getPageResponseApiResponse(int page, Page<Order> orderPage) {
        List<OrderResponse> orderResponseList = orderPage.map(orderMapper::toOrderResponse).toList();
        return ApiResponse.<PageResponse<OrderResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách đơn hàng thành công")
                .result(PageResponse.<OrderResponse>builder()
                        .currentPage(page)
                        .totalPages(orderPage.getTotalPages())
                        .totalElements(orderPage.getTotalElements())
                        .pageSize(orderPage.getSize())
                        .data(orderResponseList)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }


    private Specification<Order> getSpecification(String createdAt, Integer paymentStatus, Integer paymentMethod) {
        return (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (createdAt != null && !createdAt.trim().isEmpty()) {
                try {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy");
                    LocalDate createdDate = LocalDate.parse(createdAt, formatter);

                    LocalDateTime startOfDay = createdDate.atStartOfDay();
                    LocalDateTime endOfDay = createdDate.plusDays(1).atStartOfDay();

                    predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get("createdAt"), startOfDay));
                    predicates.add(criteriaBuilder.lessThan(root.get("createdAt"), endOfDay));

                } catch (DateTimeParseException e) {
                    throw new AppException(HttpStatus.BAD_REQUEST, "Định dạng ngày phải là dd-MM-yyyy", null);
                }
            }

            Optional.ofNullable(paymentStatus)
                    .ifPresent(s -> predicates.add(criteriaBuilder.equal(root.get("paymentStatus"), s)));

            Optional.ofNullable(paymentMethod)
                    .ifPresent(s -> predicates.add(criteriaBuilder.equal(root.get("paymentMethod"), s)));

            if (predicates.isEmpty()) {
                return null;
            }

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }
}



/* ===== order-service\src\main\java\com\hau\orderservice\service\ProductService.java ===== */
package com.hau.orderservice.service;

import com.hau.event.dto.ProductEvent;
import com.hau.orderservice.entity.Product;
import com.hau.orderservice.exception.AppException;
import com.hau.orderservice.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class ProductService {
    private final ProductRepository productRepository;

    public void saveProduct(ProductEvent productEvent) {
        Product product = Product.builder()
                .id(productEvent.getId())
                .discount(productEvent.getDiscount())
                .price(productEvent.getPrice())
                .quantity(productEvent.getQuantity())
                .title(productEvent.getTitle())
                .build();
        productRepository.save(product);
    }

    public void updateProduct(ProductEvent productEvent) {
        Product product = productRepository.findById(productEvent.getId())
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));
        product.setQuantity(productEvent.getQuantity());
        product.setDiscount(productEvent.getDiscount());
        product.setPrice(productEvent.getPrice());
        product.setTitle(productEvent.getTitle());
        productRepository.save(product);

    }
}


/* ===== order-service\src\main\java\com\hau\orderservice\service\ProfileService.java ===== */
package com.hau.orderservice.service;

import com.hau.event.dto.ProfileCreateEvent;
import com.hau.orderservice.entity.Profile;
import com.hau.orderservice.repository.ProfileRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@RequiredArgsConstructor
@Service
public class ProfileService {
    private final ProfileRepository profileRepository;

    public void saveProfile(ProfileCreateEvent profileCreateEvent) {
        Profile profile = Profile.builder()
                .id(profileCreateEvent.getId())
                .userId(profileCreateEvent.getUserId())
                .fullName(profileCreateEvent.getFullName())
                .phone(profileCreateEvent.getPhone())
                .address(profileCreateEvent.getAddress())
                .build();
        profileRepository.save(profile);

    }
}


/* ===== order-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8090
  servlet:
    context-path: /order

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/order_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect

  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: order-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"


/* ===== order-service\src\main\resources\application.yml ===== */
server:
  port: 8090
  servlet:
    context-path: /order

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/order_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect

  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: order-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"


/* ===== order-service\src\test\java\com\hau\orderservice\OrderServiceApplicationTests.java ===== */
package com.hau.orderservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class OrderServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


/* ===== payment-service\src\main\java\com\hau\event\dto\OrderCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderCreateEvent {
    private Long orderId;
    private Integer userId;
    private Integer totalPrice;
    private Integer paymentMethod;
    private Integer paymentStatus;
}


/* ===== payment-service\src\main\java\com\hau\event\dto\PaymentCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PaymentCreateEvent {
    private Long orderId;
    private Integer paymentStatus;
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\PaymentServiceApplication.java ===== */
package com.hau.paymentservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class PaymentServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(PaymentServiceApplication.class, args);
    }

}


/* ===== payment-service\src\main\java\com\hau\paymentservice\config\CustomJwtDecoder.java ===== */
package com.hau.paymentservice.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.paymentservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.paymentservice.dto.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\config\SecurityConfig.java ===== */
package com.hau.paymentservice.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
        "/vnpay_return",
        "/momo_return",
    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.GET, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== payment-service\src\main\java\com\hau\paymentservice\controller\OrderController.java ===== */
package com.hau.paymentservice.controller;

import com.hau.event.dto.OrderCreateEvent;
import com.hau.paymentservice.service.OrderService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@Slf4j

public class OrderController {
    private final OrderService orderService;

    @KafkaListener(topics = "order-create-topic")
    public void listenOrderTopic(OrderCreateEvent orderCreateEvent) {
        log.info("Received message: {}", orderCreateEvent);
        orderService.createOrder(orderCreateEvent);
    }
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\controller\PaymentController.java ===== */
package com.hau.paymentservice.controller;

import com.hau.paymentservice.dto.ApiResponse;
import com.hau.paymentservice.dto.MomoResponse;
import com.hau.paymentservice.service.PaymentService;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.net.URI;
import java.time.LocalDateTime;
import java.util.Map;

@RestController
@RequiredArgsConstructor
@Slf4j
public class PaymentController {
    private final PaymentService paymentService;

    @PostMapping("/momo/{orderId}")
    public ResponseEntity<ApiResponse<MomoResponse>> payWithMomo(@PathVariable Long orderId) {
        MomoResponse momoResponse = paymentService.createMomoQR(orderId);
        return ResponseEntity.ok(ApiResponse.<MomoResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Tạo QR thanh toán Momo thành công")
                .result(momoResponse)
                .timestamp(LocalDateTime.now())
                .build());
    }

    @GetMapping("/momo_return")
    public ResponseEntity<?> momoReturn(HttpServletRequest request) {
        paymentService.processMomoReturn(request);
        HttpHeaders headers = new HttpHeaders();
        headers.setLocation(URI.create("http://localhost:3000"));
        return new ResponseEntity<>(headers, HttpStatus.FOUND);
    }

    @GetMapping("/vnpay/{orderId}")
    public ResponseEntity<ApiResponse<Map<String, String>>> payWithVNPay(
            @PathVariable Long orderId, HttpServletRequest request,
            @RequestParam(value = "bankCode", required = false) String bankCode) {
        String paymentURL = paymentService.createPaymentUrl(orderId, request, bankCode);
        return ResponseEntity.ok(ApiResponse.<Map<String, String>>builder()
                .status(HttpStatus.OK.value())
                .message("Tạo URL thanh toán VNPay thành công")
                .result(Map.of("payUrl", paymentURL))
                .timestamp(LocalDateTime.now())
                .build());
    }

    @GetMapping("/vnpay_return")
    public ResponseEntity<?> vnPayReturn(HttpServletRequest request) {
        paymentService.processVnPayReturn(request);
        HttpHeaders headers = new HttpHeaders();
        headers.setLocation(URI.create("http://localhost:3000"));
        return new ResponseEntity<>(headers, HttpStatus.FOUND);
    }
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\dto\ApiResponse.java ===== */
package com.hau.paymentservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\dto\CreateMomoRequest.java ===== */
package com.hau.paymentservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CreateMomoRequest {
    private String partnerCode;
    private String requestType;
    private String ipnUrl;
    private String redirectUrl;
    private String orderId;
    private String amount;
    private String orderInfo;
    private String requestId;
    private String extraData;
    private String signature;
    private String lang;
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\dto\ErrorsResponse.java ===== */
package com.hau.paymentservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    int status;
    String message;
    Object error;
    LocalDateTime timestamp;
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\dto\MomoResponse.java ===== */
package com.hau.paymentservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class MomoResponse {
    private String partnerCode;
    private String orderId;
    private String requestId;
    private long amount;
    private long responseTime;
    private String message;
    private int resultCode;
    private String payUrl;
    private String deeplink;
    private String qrCodeUrl;
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\dto\PageResponse.java ===== */
package com.hau.paymentservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\entity\Order.java ===== */
package com.hau.paymentservice.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "orders")
@Builder
public class Order {
    @Id
    private Long id;

    private Integer userId;
    private Integer totalPrice;
    private Integer paymentMethod;
    private Integer paymentStatus;
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\entity\Payment.java ===== */
package com.hau.paymentservice.entity;

import jakarta.persistence.*;
import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "payments")
@Builder
public class Payment {
    @Id
    private String id;

    private Long orderId;
    private String paymentMethod;
    private Integer amount;
    private String orderInfo;
    private String paymentStatus;
    private String paymentDate;
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\exception\AppException.java ===== */
package com.hau.paymentservice.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\exception\GlobalExceptionHandler.java ===== */
package com.hau.paymentservice.exception;

import com.hau.paymentservice.dto.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions(Exception ex) {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\repository\MomoClientApi.java ===== */
package com.hau.paymentservice.repository;

import com.hau.paymentservice.dto.CreateMomoRequest;
import com.hau.paymentservice.dto.MomoResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "momo", url = "${momo.endpoint}")
public interface MomoClientApi {
    @PostMapping("/create")
    MomoResponse createMomoQR(@RequestBody CreateMomoRequest createMomoRequest);
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\repository\OrderRepository.java ===== */
package com.hau.paymentservice.repository;

import com.hau.paymentservice.entity.Order;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderRepository extends JpaRepository<Order, Long> {
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\repository\PaymentRepository.java ===== */
package com.hau.paymentservice.repository;

import com.hau.paymentservice.entity.Order;
import com.hau.paymentservice.entity.Payment;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PaymentRepository extends JpaRepository<Payment, String> {
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\service\OrderService.java ===== */
package com.hau.paymentservice.service;

import com.hau.event.dto.OrderCreateEvent;
import com.hau.paymentservice.entity.Order;
import com.hau.paymentservice.repository.OrderRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class OrderService {
    private final OrderRepository orderRepository;

    public void createOrder(OrderCreateEvent orderCreateEvent) {
        Order order = Order.builder()
                .id(orderCreateEvent.getOrderId())
                .userId(orderCreateEvent.getUserId())
                .totalPrice(orderCreateEvent.getTotalPrice())
                .paymentMethod(orderCreateEvent.getPaymentMethod())
                .paymentStatus(orderCreateEvent.getPaymentStatus())
                .build();
        orderRepository.save(order);
    }
}


/* ===== payment-service\src\main\java\com\hau\paymentservice\service\PaymentService.java ===== */
package com.hau.paymentservice.service;

import com.hau.event.dto.PaymentCreateEvent;
import com.hau.paymentservice.dto.ApiResponse;
import com.hau.paymentservice.dto.CreateMomoRequest;
import com.hau.paymentservice.dto.MomoResponse;
import com.hau.paymentservice.entity.Order;
import com.hau.paymentservice.entity.Payment;
import com.hau.paymentservice.exception.AppException;
import com.hau.paymentservice.repository.MomoClientApi;
import com.hau.paymentservice.repository.OrderRepository;
import com.hau.paymentservice.repository.PaymentRepository;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;

@Service
@RequiredArgsConstructor
@Slf4j
public class PaymentService {
    private final OrderRepository orderRepository;
    private final PaymentRepository paymentRepository;
    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final MomoClientApi momoClientApi;

    @Value("${vnpay.payUrl}")
    private String payUrl;

    @Value("${vnpay.returnUrl}")
    private String returnUrl;

    @Value("${vnpay.tmnCode}")
    private String tmnCode;

    @Value("${vnpay.secretKey}")
    private String secretKey;

    @Value("${momo.partnerCode}")
    private String partnerCode;

    @Value("${momo.accessKey}")
    private String accessKey;

    @Value("${momo.secretKey}")
    private String momoSecretKey;

    @Value("${momo.returnUrl}")
    private String momoReturnUrl;

    @Value("${momo.ipn-url}")
    private String ipnUrl;

    @Value("${momo.requestType}")
    private String requestType;

    public MomoResponse createMomoQR(Long orderId) {
        Integer userId = Integer.valueOf(SecurityContextHolder.getContext().getAuthentication().getName());
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Đơn hàng không tồn tại", null));
        if (!order.getUserId().equals(userId))
            throw new AppException(HttpStatus.FORBIDDEN, "Đơn hàng không thuộc về bạn", null);
        if (order.getPaymentStatus() == 0)
            throw new AppException(HttpStatus.BAD_REQUEST, "Đơn hàng đã được thanh toán", null);
        if (!(order.getPaymentMethod() == 2))
            throw new AppException(HttpStatus.BAD_REQUEST, "Đơn hàng không hỗ trợ phương thức thanh toán này", null);

        String requestId = UUID.randomUUID().toString();
        String amount = order.getTotalPrice().toString();
        String orderInfo = "Thanh toan don hang: " + orderId;
        String orderIdCustom = orderId + "_" + UUID.randomUUID();
        String extraData = "";
        String lang = "vi";
        try {
            String rawSignature = "accessKey=" + accessKey
                    + "&amount=" + amount
                    + "&extraData=" + extraData
                    + "&ipnUrl=" + ipnUrl
                    + "&orderId=" + orderIdCustom
                    + "&orderInfo=" + orderInfo
                    + "&partnerCode=" + partnerCode
                    + "&redirectUrl=" + momoReturnUrl
                    + "&requestId=" + requestId
                    + "&requestType=" + requestType;

            String signature = hmacSHA256(rawSignature, momoSecretKey);

            CreateMomoRequest createMomoRequest = CreateMomoRequest.builder()
                    .partnerCode(partnerCode)
                    .requestType(requestType)
                    .ipnUrl(ipnUrl)
                    .redirectUrl(momoReturnUrl)
                    .orderId(orderIdCustom)
                    .amount(amount)
                    .orderInfo(orderInfo)
                    .requestId(requestId)
                    .extraData(extraData)
                    .signature(signature)
                    .lang(lang)
                    .build();
            return momoClientApi.createMomoQR(createMomoRequest);
        } catch (Exception e) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi tạo chữ ký MoMo", e.getMessage());
        }
    }

    @Transactional
    public void processMomoReturn(HttpServletRequest request) {
        String orderIdRequest = request.getParameter("orderId").split("_")[0];
        Order order = orderRepository.findById(Long.valueOf(orderIdRequest))
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Đơn hàng không tồn tại", null));
        if (request.getParameter("resultCode").equals("0")) {
            // Giao dịch thành công
            order.setPaymentStatus(0);
            orderRepository.save(order);

            Payment payment = Payment.builder()
                    .id("MMP" + request.getParameter("transId"))
                    .amount(Integer.parseInt(request.getParameter("amount")))
                    .orderInfo(request.getParameter("orderInfo"))
                    .paymentDate(request.getParameter("responseTime"))
                    .paymentStatus("0" + request.getParameter("resultCode"))
                    .orderId(order.getId())
                    .paymentMethod(request.getParameter("payType"))
                    .build();

            paymentRepository.save(payment);
            PaymentCreateEvent paymentCreateEvent = PaymentCreateEvent.builder()
                    .orderId(order.getId())
                    .paymentStatus(0)
                    .build();
            kafkaTemplate.send("payment-create-topic", paymentCreateEvent);
        } else {
            // Giao dịch thất bại
            order.setPaymentStatus(3);
            orderRepository.save(order);
            PaymentCreateEvent paymentCreateEvent = PaymentCreateEvent.builder()
                    .orderId(order.getId())
                    .paymentStatus(3)
                    .build();
            kafkaTemplate.send("payment-create-topic", paymentCreateEvent);
        }
    }



    private static String hmacSHA256(String data, String key) throws Exception {
        Mac mac = Mac.getInstance("HmacSHA256");
        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
        mac.init(secretKey);
        byte[] hashBytes = mac.doFinal(data.getBytes(StandardCharsets.UTF_8));
        StringBuilder hexString = new StringBuilder();
        for (byte b : hashBytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }

    public String createPaymentUrl(Long orderId, HttpServletRequest request, String bankCode) {
        Integer userId = Integer.valueOf(SecurityContextHolder.getContext().getAuthentication().getName());
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Đơn hàng không tồn tại", null));
        if (!Objects.equals(order.getUserId(), userId)) {
            throw new AppException(HttpStatus.FORBIDDEN, "Đơn hàng không thuộc về bạn", null);
        }
        if (order.getPaymentStatus() == 0)
            throw new AppException(HttpStatus.BAD_REQUEST, "Đơn hàng đã được thanh toán", null);
        if (!(order.getPaymentMethod() == 1))
            throw new AppException(HttpStatus.BAD_REQUEST, "Đơn hàng không hỗ trợ phương thức thanh toán này", null);

        String vnp_TxnRef = String.valueOf(order.getId());
        String vnp_IpAddr = getIpAddress(request);
        long amount = order.getTotalPrice() * 100L;

        Map<String, String> vnp_Params = new HashMap<>();
        vnp_Params.put("vnp_Version", "2.1.0");
        vnp_Params.put("vnp_Command", "pay");
        vnp_Params.put("vnp_TmnCode", tmnCode);
        vnp_Params.put("vnp_Amount", String.valueOf(amount));
        vnp_Params.put("vnp_CurrCode", "VND");

        if (bankCode != null && !bankCode.isEmpty()) {
            vnp_Params.put("vnp_BankCode", bankCode);
        }
        vnp_Params.put("vnp_TxnRef", vnp_TxnRef);
        vnp_Params.put("vnp_OrderInfo", "Thanh toan don hang: " + vnp_TxnRef);
        vnp_Params.put("vnp_OrderType", "other");
        vnp_Params.put("vnp_Locale", "vn");
        vnp_Params.put("vnp_ReturnUrl", returnUrl);
        vnp_Params.put("vnp_IpAddr", vnp_IpAddr);

        LocalDateTime localDateTime = LocalDateTime.now(ZoneId.of("Etc/GMT+7"));
        SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMddHHmmss");
        String vnp_CreateDate = formatter.format(Date.from(localDateTime.atZone(ZoneId.of("Etc/GMT+7")).toInstant()));
        vnp_Params.put("vnp_CreateDate", vnp_CreateDate);

        Calendar cld = Calendar.getInstance(TimeZone.getTimeZone("Etc/GMT+7"));
        cld.add(Calendar.MINUTE, 15);
        String vnp_ExpireDate = formatter.format(cld.getTime());
        vnp_Params.put("vnp_ExpireDate", vnp_ExpireDate);

        List<String> fieldNames = new ArrayList<>(vnp_Params.keySet());
        Collections.sort(fieldNames);
        StringBuilder hashData = new StringBuilder();
        StringBuilder query = new StringBuilder();
        Iterator<String> itr = fieldNames.iterator();
        while (itr.hasNext()) {
            String fieldName = itr.next();
            String fieldValue = vnp_Params.get(fieldName);
            if ((fieldValue != null) && (!fieldValue.isEmpty())) {
                //Build hash data
                hashData.append(fieldName);
                hashData.append('=');
                hashData.append(URLEncoder.encode(fieldValue, StandardCharsets.US_ASCII));
                //Build a query
                query.append(URLEncoder.encode(fieldName, StandardCharsets.US_ASCII));
                query.append('=');
                query.append(URLEncoder.encode(fieldValue, StandardCharsets.US_ASCII));
                if (itr.hasNext()) {
                    query.append('&');
                    hashData.append('&');
                }
            }
        }
        String queryUrl = query.toString();
        String vnp_SecureHash = hmacSHA512(secretKey, hashData.toString());
        queryUrl += "&vnp_SecureHash=" + vnp_SecureHash;
        return payUrl + "?" + queryUrl;
    }

    @Transactional
    public void processVnPayReturn(HttpServletRequest request) {
        try {
            // 1. Kiểm tra chữ ký
            Map<String, String> fields = new HashMap<>();
            for (Enumeration<String> params = request.getParameterNames(); params.hasMoreElements(); ) {
                String fieldName = params.nextElement();
                String fieldValue = request.getParameter(fieldName);
                if (fieldValue != null && !fieldValue.isEmpty()) {
                    fields.put(fieldName, fieldValue);
                }
            }

            String vnp_SecureHash = request.getParameter("vnp_SecureHash");
            fields.remove("vnp_SecureHashType");
            fields.remove("vnp_SecureHash");
            String signValue = hashAllFields(fields);

            if (!signValue.equals(vnp_SecureHash)) {
                ApiResponse.<String>builder()
                        .status(HttpStatus.BAD_REQUEST.value())
                        .message("Invalid signature")
                        .result(null)
                        .timestamp(LocalDateTime.now())
                        .build();
                return;
            }

            // 2. Lấy các tham số
            String vnpResponseCode = request.getParameter("vnp_ResponseCode");
            String vnpTransactionStatus = request.getParameter("vnp_TransactionStatus");
            String vnpTxnRef = request.getParameter("vnp_TxnRef");
            Long orderId = Long.valueOf(vnpTxnRef);

            // 3. Tìm Order
            Order order = orderRepository.findById(orderId)
                    .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Đơn hàng không tồn tại", null));

            // 4. Xử lý kết quả giao dịch
            if ("00".equals(vnpResponseCode) && "00".equals(vnpTransactionStatus)) {
                // Giao dịch thành công
                order.setPaymentStatus(0);
                orderRepository.save(order);

                // Tạo và lưu Payment
                Payment payment = Payment.builder()
                        .id(request.getParameter("vnp_BankTranNo"))
                        .amount(Integer.parseInt(request.getParameter("vnp_Amount")) / 100)
                        .orderInfo(request.getParameter("vnp_OrderInfo"))
                        .paymentDate(request.getParameter("vnp_PayDate"))
                        .paymentStatus(request.getParameter("vnp_TransactionStatus"))
                        .orderId(orderId)
                        .paymentMethod(request.getParameter("vnp_BankCode"))
                        .build();


                paymentRepository.save(payment);
                PaymentCreateEvent paymentCreateEvent = PaymentCreateEvent.builder()
                        .orderId(orderId)
                        .paymentStatus(0)
                        .build();
                kafkaTemplate.send("payment-create-topic", paymentCreateEvent);
                ApiResponse.<String>builder()
                        .status(HttpStatus.OK.value())
                        .message("Thanh toán thành công")
                        .timestamp(LocalDateTime.now())
                        .build();
            } else {
                // Giao dịch thất bại
                order.setPaymentStatus(3);
                orderRepository.save(order);
                PaymentCreateEvent paymentCreateEvent = PaymentCreateEvent.builder()
                        .orderId(orderId)
                        .paymentStatus(3)
                        .build();
                kafkaTemplate.send("payment-create-topic", paymentCreateEvent);
                ApiResponse.<String>builder()
                        .status(HttpStatus.BAD_REQUEST.value())
                        .message("Thanh toán thất bại")
                        .timestamp(LocalDateTime.now())
                        .build();
            }
        } catch (DataIntegrityViolationException e) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Giao dịch thanh toán này đã được ghi nhận trước đó.", e);
        }
    }

    public String hashAllFields(Map<String, String> fields) {
        List<String> fieldNames = new ArrayList<>(fields.keySet());
        Collections.sort(fieldNames);
        StringBuilder sb = new StringBuilder();
        Iterator<String> itr = fieldNames.iterator();
        while (itr.hasNext()) {
            String fieldName = itr.next();
            String fieldValue = fields.get(fieldName);
            if ((fieldValue != null) && (!fieldValue.isEmpty())) {
                // *Sửa ở đây*: Encode *tất cả* các trường bằng US-ASCII
                sb.append(fieldName);
                sb.append("=");
                sb.append(URLEncoder.encode(fieldValue, StandardCharsets.US_ASCII)); // Dùng US-ASCII
            }
            if (itr.hasNext()) {
                sb.append("&");
            }
        }
        return hmacSHA512(secretKey, sb.toString());
    }

    public String hmacSHA512(final String key, final String data) {
        try {
            if (key == null || data == null) {
                throw new NullPointerException();
            }
            final Mac hmac512 = Mac.getInstance("HmacSHA512");
            byte[] hmacKeyBytes = key.getBytes();
            final SecretKeySpec secretKey = new SecretKeySpec(hmacKeyBytes, "HmacSHA512");
            hmac512.init(secretKey);
            byte[] dataBytes = data.getBytes(StandardCharsets.UTF_8);
            byte[] result = hmac512.doFinal(dataBytes);
            StringBuilder sb = new StringBuilder(2 * result.length);
            for (byte b : result) {
                sb.append(String.format("%02x", b & 0xff));
            }
            return sb.toString();

        } catch (Exception ex) {
            return "";
        }
    }

    public String getIpAddress(HttpServletRequest request) {
        String ipAdress;
        try {
            ipAdress = request.getHeader("X-FORWARDED-FOR");
            if (ipAdress == null) {
                ipAdress = request.getRemoteAddr();
            }
        } catch (Exception e) {
            ipAdress = "Invalid IP:" + e.getMessage();
        }
        return ipAdress;
    }
}


/* ===== payment-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8089
  servlet:
    context-path: /payment

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/payment_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect

  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: payment-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"

vnpay:
  payUrl: "https://sandbox.vnpayment.vn/paymentv2/vpcpay.html"
  returnUrl: "http://localhost:8089/payment/vnpay_return"
  tmnCode: ""
  secretKey: ""

momo:
  partnerCode: "MOMOBKUN20180529"
  returnUrl: "http://localhost:8089/payment/momo_return"
  endpoint: "https://test-payment.momo.vn/v2/gateway/api/"
  ipn-url: "http://localhost:8089/payment/momo_return"
  accessKey: "klm05TvNBzhg7h7j"
  secretKey: "at67qH6mk8w5Y1nAyMoYKMWACiEi2bsa"
  requestType: "payWithMethod"

/* ===== payment-service\src\main\resources\application.yml ===== */
server:
  port: 8089
  servlet:
    context-path: /payment

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/payment_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect

  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: payment-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
vnpay:
  payUrl: "https://sandbox.vnpayment.vn/paymentv2/vpcpay.html"
  returnUrl: "http://localhost:8089/payment/vnpay_return"
  tmnCode: "TY24L0SC"
  secretKey: "OLLNHDCEMOEUUO6KJ12C1F9B9GMX4A3N"
momo:
  partnerCode: "MOMOBKUN20180529"
  returnUrl: "http://localhost:8089/payment/momo_return"
  endpoint: "https://test-payment.momo.vn/v2/gateway/api/"
  ipn-url: "http://localhost:8089/payment/momo_return"
  accessKey: "klm05TvNBzhg7h7j"
  secretKey: "at67qH6mk8w5Y1nAyMoYKMWACiEi2bsa"
  requestType: "payWithMethod"

/* ===== payment-service\src\test\java\com\hau\paymentservice\PaymentServiceApplicationTests.java ===== */
package com.hau.paymentservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class PaymentServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


/* ===== product-service\doc.txt ===== */
/* ===== java/com/hau/event/dto/CategoryEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;


@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryEvent {
    private String type;
    private Long categoryId;
    private Object data;

    // Enum hoặc Constant cho các loại sự kiện
    public static String TYPE_CREATED = "CATEGORY_CREATED";
    public static String TYPE_UPDATED = "CATEGORY_UPDATED";
    public static String TYPE_DELETED = "CATEGORY_DELETED";
}


/* ===== java/com/hau/event/dto/NotificationEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationEvent {
    private String channel;
    private String recipient;
    private String templateCode;
    private Map<String, Object> params;
}


/* ===== java/com/hau/event/dto/ProductEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductEvent {
    private Long id;
    private Integer discount;
    private Integer price;
    private Integer quantity;
    private String title;
}


/* ===== java/com/hau/event/dto/UserCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCreateEvent {
    private String username;
    private Integer id;
}


/* ===== java/com/hau/product_service/config/AuthenticationRequestInterceptor.java ===== */
package com.hau.product_service.config;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
public class AuthenticationRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes servletRequestAttributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

        assert servletRequestAttributes != null;
        var authHeader = servletRequestAttributes.getRequest().getHeader("Authorization");
        log.info("Auth header: {}", authHeader);
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            requestTemplate.header("Authorization", authHeader);
        } else {
            log.warn("No Authorization header found in the request");
        }
    }
}


/* ===== java/com/hau/product_service/config/CustomJwtDecoder.java ===== */
package com.hau.product_service.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== java/com/hau/product_service/config/FeignMultipartSupportConfig.java ===== */
package com.hau.product_service.config;

import feign.codec.Encoder;
import feign.form.spring.SpringFormEncoder;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringEncoder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class FeignMultipartSupportConfig {
    @Bean
    public Encoder feignFormEncoder() {
        return new SpringFormEncoder(new SpringEncoder(() -> new HttpMessageConverters(new RestTemplate().getMessageConverters())));
    }
}


/* ===== java/com/hau/product_service/config/JwtAuthenticationEntryPoint.java ===== */
package com.hau.product_service.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.product_service.dto.response.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== java/com/hau/product_service/config/SecurityConfig.java ===== */
package com.hau.product_service.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
        "/**"
    };


    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.GET, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== java/com/hau/product_service/controller/CategoryController.java ===== */
package com.hau.product_service.controller;

import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.product_service.service.CategoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class CategoryController {
    private final CategoryService categoryService;

    @GetMapping("/category")
    public ResponseEntity<ApiResponse<List<CategoryResponse>>> getAllCategories() {
        ApiResponse<List<CategoryResponse>> response = categoryService.getAllCategories();
        return ResponseEntity.ok(response);
    }
}


/* ===== java/com/hau/product_service/controller/ProductController.java ===== */
package com.hau.product_service.controller;

import com.hau.event.dto.NotificationEvent;
import com.hau.product_service.dto.request.ProductFilter;
import com.hau.product_service.dto.request.ProductRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResult;
import com.hau.product_service.dto.response.ProductResponse;
import com.hau.product_service.service.ProductService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class ProductController {
    private final ProductService productService;

    @GetMapping
    public ResponseEntity<ApiResponse<PageResult<ProductResponse>> >getAllProduct(@ModelAttribute ProductFilter filter,
                                                                  @RequestParam(defaultValue = "1", required = false) Integer pageIndex,
                                                                  @RequestParam(defaultValue = "10", required = false) Integer pageSize) {
        ApiResponse<PageResult<ProductResponse>> response = productService.getAllProduct(filter, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/active")
    public ResponseEntity<ApiResponse<PageResult<ProductResponse>>> getAllProductByActive(@ModelAttribute ProductFilter filter,
                                                                                          @RequestParam(defaultValue = "1", required = false) Integer pageIndex,
                                                                                          @RequestParam(defaultValue = "10", required = false) Integer pageSize) {
        ApiResponse<PageResult<ProductResponse>> response = productService.getAllProductByActive(filter, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/top-discount")
    public ResponseEntity<ApiResponse<List<ProductResponse>>> getTopTenBestDiscountProduct() {
        ApiResponse<List<ProductResponse>> response = productService.getTopTenProductByBestDiscountPercent();
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/top-rating")
    public ResponseEntity<ApiResponse<List<ProductResponse>>> getTopTenBestAverageRateProduct() {
        ApiResponse<List<ProductResponse>> response = productService.getTopTenProductByAverageRate();
        return new ResponseEntity<>(response, HttpStatus.OK);
    }


    @PostMapping
    public ResponseEntity<ApiResponse<ProductResponse>> createProduct(
            @RequestPart("product") @Valid ProductRequest request,
            @RequestPart("thumbnail") MultipartFile thumbnail,
            @RequestPart(value = "images", required = false) List<MultipartFile> images // Added: accept multiple images, make it optional
    ) {
        ApiResponse<ProductResponse> response = productService.createProduct(request, thumbnail, images);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    // Modified for image/thumbnail update
    @PutMapping(value = "/{productId}")
    public ResponseEntity<ApiResponse<ProductResponse>> updateProduct(
            @PathVariable Long productId,
            @RequestPart("product") @Valid ProductRequest request,
            @RequestPart(value = "thumbnail", required = false) MultipartFile thumbnail,
            @RequestPart(value = "images", required = false) List<MultipartFile> images
    ) {
        ApiResponse<ProductResponse> response = productService.updateProduct(request, productId, thumbnail, images);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @DeleteMapping("/{productId}")
    public ResponseEntity<ApiResponse<ProductResponse>> deleteProduct(@PathVariable Long productId) {
        ApiResponse<ProductResponse> response = productService.deleteProduct(productId);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/{productId}")
    public ResponseEntity<ApiResponse<ProductResponse>> getProductById(@PathVariable Long productId) {
        ApiResponse<ProductResponse> response = productService.getProductById(productId);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @KafkaListener(topics = "order-create-notification-topic")
    public void updateProductQuantity(NotificationEvent notificationEvent) {
        productService.updateProductQuantity(notificationEvent);
    }

}


/* ===== java/com/hau/product_service/controller/RateController.java ===== */
package com.hau.product_service.controller;

import com.hau.product_service.dto.request.RateRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResult;
import com.hau.product_service.dto.response.RateResponse;
import com.hau.product_service.service.RateService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequiredArgsConstructor
public class RateController {
    private final RateService rateService;

    @GetMapping("/rate")
    public ResponseEntity<ApiResponse<PageResult<RateResponse>>> getAllRate(@RequestParam(required = false, defaultValue = "1")  Integer pageIndex,
                                                                            @RequestParam(required = false, defaultValue = "10") Integer pageSize) {
        ApiResponse<PageResult<RateResponse>> response = rateService.getAllRate(pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/rate/{id}")
    public ResponseEntity<ApiResponse<RateResponse>> getRateById(@PathVariable Long id) {
        ApiResponse<RateResponse> response = rateService.getRateById(id);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/rate/product/{productId}")
    public ResponseEntity<ApiResponse<PageResult<RateResponse>>> getRateByProductId(@PathVariable Long productId,
                                                                                     @RequestParam(required = false, defaultValue = "1") Integer pageIndex,
                                                                                     @RequestParam(required = false, defaultValue = "10") Integer pageSize) {
        ApiResponse<PageResult<RateResponse>> response = rateService.getRateByProductId(productId, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/rate")
    public ResponseEntity<ApiResponse<RateResponse>> createRate(@RequestBody @Valid RateRequest request) {
        ApiResponse<RateResponse> response = rateService.createRate(request);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @DeleteMapping("/rate/{id}")
    public ResponseEntity<ApiResponse<RateResponse>> deleteRate(@PathVariable Long id) {
        ApiResponse<RateResponse> response = rateService.removeRate(id);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }



}


/* ===== java/com/hau/product_service/converter/StringConverter.java ===== */
package com.hau.product_service.converter;

public class StringConverter {
    public static String toSlug(String str) {
        // Convert to lowercase
        str = str.toLowerCase();

        // Replace spaces with hyphens
        str = str.replaceAll(" ", "-");

        // Remove special characters
        str = str.replaceAll("[^a-z0-9-]", "");

        // Remove consecutive hyphens
        str = str.replaceAll("-+", "-");

        // Trim leading and trailing hyphens
        str = str.replaceAll("^-|-$", "");

        return str;
    }
}


/* ===== java/com/hau/product_service/dto/request/CategoryRequest.java ===== */
package com.hau.product_service.dto.request;


import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryRequest {
    @NotNull(message = "ID danh mục không được để trống")
    private Long id;
    @NotNull(message = "Tên danh mục không được để trống")
    private String name;
    @NotNull(message = "Độ ưu tiên không được để trống")
    @Min(value = 1, message = "Mức độ ưu tiên phải lớn hơn 0")
    private Integer priority;
    private Long parentId;
    private String slug;
}


/* ===== java/com/hau/product_service/dto/request/ProductFilter.java ===== */
package com.hau.product_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductFilter {
    private String title;
    private String author;
    private Integer priceFrom;
    private Integer priceTo;
    private String sortBy;
    private String sortDir;
    private Long categoryId;
    private Float averageRateFrom;

    public boolean isEmpty() {
        return (title == null || title.isEmpty()) &&
                (author == null || author.isEmpty()) &&
                (priceFrom == null || priceFrom <= 0) &&
                (priceTo == null || priceTo <= 0) &&
                (sortBy == null || sortBy.isEmpty()) &&
                (sortDir == null || sortDir.isEmpty()) &&
                (categoryId == null || categoryId <= 0) &&
                (averageRateFrom == null || averageRateFrom <= 0);
    }
}


/* ===== java/com/hau/product_service/dto/request/ProductImageRequest.java ===== */
package com.hau.product_service.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
public class ProductImageRequest {
    @NotNull
    Long productId;
    @NotBlank
    String imageUrl;
}


/* ===== java/com/hau/product_service/dto/request/ProductRequest.java ===== */
package com.hau.product_service.dto.request;

import jakarta.validation.constraints.*;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductRequest {
    @NotBlank(message = "Tên sản phẩm không được để trống")
    @NotNull
    private String title;

    @NotBlank(message = "Tác giả không được để trống")
    @NotNull
    private String author;

    @NotBlank(message = "Nhà xuất bản không được để trống")
    private String publisher;

    @NotNull(message = "Năm xuất bản không được để trống")
    private Integer publicationYear;

    @NotNull(message = "Kích thước đóng gói không được để trống")
    @Min(value = 1, message = "Kích thước đóng gói phải lớn hơn 0")
    private Integer packageSize;

    @NotNull(message = "Số trang không được để trống")
    @Min(value = 1, message = "Số trang phải lớn hơn 0")
    private Integer pageSize;

    @NotBlank(message = "Hình thức không được để trống") // ví dụ: Bìa mềm, Bìa cứng
    private String form;


    @NotNull(message = "Số lượng không được để trống")
    @Min(value = 0, message = "Số lượng phải >= 0")
    private Integer quantity;

    @NotNull(message = "giá hiện tại không được để trống")
    @Min(value = 1, message = "Giá hiện tại phải > 0")
    private Integer discount;

    @NotNull(message = "Giá cũ không được để trống")
    @Min(value = 1000, message = "Giá cũ phải > 0")
    private Integer price;

    @NotNull(message = "Độ ưu tiên không được để trống")
    @Min(value = 0, message = "Độ ưu tiên phải >= 0")
    private Integer priority;

    @NotBlank(message = "Mô tả không được để trống")
    private String description;

    Boolean active;

    private List<Long> categoryIds;
}


/* ===== java/com/hau/product_service/dto/request/RateRequest.java ===== */
package com.hau.product_service.dto.request;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class RateRequest {
    @NotNull(message = "Mã sản phẩm không được để trống")
    private Long productId;

    @NotNull(message = "Điểm đánh giá không được để trống")
    @Min(value = 1, message = "Điểm đánh giá phải lớn hơn hoặc bằng 1")
    @Max(value = 5, message = "Điểm đánh giá phải nhỏ hơn hoặc bằng 5")
    private int vote;

    private String comment;
}


/* ===== java/com/hau/product_service/dto/response/ApiResponse.java ===== */
package com.hau.product_service.dto.response;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== java/com/hau/product_service/dto/response/CategoryResponse.java ===== */
package com.hau.product_service.dto.response;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CategoryResponse {
    private Long id;
    private String name;
    private Long priority;
    private Long parentId;
    private String slug;
}


/* ===== java/com/hau/product_service/dto/response/ErrorsResponse.java ===== */
package com.hau.product_service.dto.response;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== java/com/hau/product_service/dto/response/FileResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FileResponse {
    private String originalFileName;
    private String url;
}


/* ===== java/com/hau/product_service/dto/response/PageResult.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult<T> {
    private List<T> data;
    private int pageIndex;
    private int pageSize;
    private int totalPages;
    private long totalItems;
    private boolean hasNext;
    private boolean hasPrevious;
}



/* ===== java/com/hau/product_service/dto/response/ProductImageResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
public class ProductImageResponse {
    private String url;
}


/* ===== java/com/hau/product_service/dto/response/ProductResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductResponse {
    private Long id;
    private String title;
    private String author;
    private String publisher;
    private Integer publicationYear;
    private Integer packageSize;
    private Integer pageSize;
    private String form;
    private String thumbnail;
    private Integer quantity;
    private Integer discount;
    private Integer price;
    private Double discountPercent;
    private Integer priority;
    private String description;
    private Float averageRate;

    private boolean active;

    private List<String> imageUrls;
    private List<Long> categories;
}


/* ===== java/com/hau/product_service/dto/response/RateResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RateResponse {
    private Long id;
    private Long productId;
    private Integer userId;
    private Integer vote;
    private String comment;
    private String createdAt;
}


/* ===== java/com/hau/product_service/entity/Category.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;


@Table(name = "categories")
@Entity
@Data
public class Category {
    @Id
    private Long id;
    private String name;
    private String slug;
    private Long parentId;


    @ManyToMany(mappedBy = "categories", fetch = FetchType.LAZY)
    @EqualsAndHashCode.Exclude
    @ToString.Exclude
    private List<Product> products = new ArrayList<>();

}


/* ===== java/com/hau/product_service/entity/Product.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.CreationTimestamp;

import java.util.ArrayList;
import java.util.List;

import java.time.LocalDateTime;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "products")
@FieldDefaults(level = AccessLevel.PRIVATE)
public class Product {
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Id
    Long id;
    String title;
    String author;
    String publisher;
    Integer publicationYear;
    Integer packageSize;
    Integer pageSize;
    String form;
    String thumbnail;
    Integer quantity;
    Integer discount;
    Integer price;
    Integer priority;
    String description;
    @Column(unique = true)
    String slug;
    Double discountPercent;

    @ManyToMany(fetch = FetchType.LAZY) // Use LAZY fetching
    @JoinTable(
            name = "product_category", // Name of the join table
            joinColumns = @JoinColumn(name = "product_id", referencedColumnName = "id"), // Column referring to Product's ID
            inverseJoinColumns = @JoinColumn(name = "category_id", referencedColumnName = "id") // Column referring to Category's ID
    )
    // Exclude from equals and hashCode/toString generated by Lombok @Data
    // to prevent infinite loops or StackOverflow errors in bidirectional relationships.
    @EqualsAndHashCode.Exclude
    @ToString.Exclude
    private List<Category> categories = new ArrayList<>();

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, mappedBy = "product")
    List<ProductImage> productImage = new ArrayList<>();

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true)
    List<Rate> rates;

    private Float averageRate;

    boolean active;
    @CreationTimestamp
    LocalDateTime createdAt;
    @CreationTimestamp
    LocalDateTime updatedAt;


}


/* ===== java/com/hau/product_service/entity/ProductImage.java ===== */
package com.hau.product_service.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@Table(name = "product_images")
@NoArgsConstructor
@AllArgsConstructor
public class ProductImage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @JsonIgnore
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;
    private String url;
}


/* ===== java/com/hau/product_service/entity/Rate.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "rates")
public class Rate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int vote;
    private String comment;
    @ManyToOne
    @JoinColumn(name = "product_id", referencedColumnName = "id")
    private Product product;

    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id")
    private User user;

    @CreationTimestamp
    LocalDateTime createdAt;
}


/* ===== java/com/hau/product_service/entity/User.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Entity
@Data
@Table(name = "users")
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    private Integer id;
    private String username;
    @Version
    private Integer version;
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Rate> rate;
}


/* ===== java/com/hau/product_service/exception/AppException.java ===== */
package com.hau.product_service.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== java/com/hau/product_service/exception/GlobalExceptionHandler.java ===== */
package com.hau.product_service.exception;

import com.hau.product_service.dto.response.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
//import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.multipart.support.MissingServletRequestPartException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    @ExceptionHandler(MissingServletRequestPartException.class)
    public ResponseEntity<ErrorsResponse> handleMissingServletRequestPartException(MissingServletRequestPartException ex) {
        String errorMessage = getString(ex);

        // Tạo đối tượng ErrorsResponse với status 400 và thông báo lỗi tùy chỉnh
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), // Status luôn là 400 cho loại lỗi này
                errorMessage,
                // Bạn có thể đưa tên part bị thiếu vào trường 'error' nếu muốn chi tiết hơn
                // hoặc để null như AppException mặc định nếu error không có thông tin cụ thể
                null, // Hoặc partName
                LocalDateTime.now()
        );

        // Trả về ResponseEntity với status 400
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    private static String getString(MissingServletRequestPartException ex) {
        String partName = ex.getRequestPartName();
        String errorMessage;
        // Tạo thông báo lỗi thân thiện dựa trên tên part bị thiếu
        if ("thumbnail".equals(partName)) {
            errorMessage = "Ảnh thumbnail không được để trống";
        } else if ("images".equals(partName)) {
            errorMessage = "Danh sách ảnh sản phẩm không được để trống";
        }
        else {
            // Trường hợp thiếu part khác không phải thumbnail hoặc images
            errorMessage = "Thiếu phần yêu cầu trong request: " + partName;
        }
        return errorMessage;
    }

    // Xử lý lỗi không có quyền truy cập
//    @ExceptionHandler(AuthorizationDeniedException.class)
//    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
//    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
//    @ExceptionHandler(Exception.class)
//    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
//    }

}


/* ===== java/com/hau/product_service/mapper/CategoryMapper.java ===== */
package com.hau.product_service.mapper;

import com.hau.product_service.dto.request.CategoryRequest;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.product_service.entity.Category;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface CategoryMapper {
    CategoryResponse toCategoryResponse(Category category);

    Category toCategory(CategoryRequest categoryRequest);

    Category toCategoryUpdateFromRequest(CategoryRequest categoryRequest, @MappingTarget Category category);
}



/* ===== java/com/hau/product_service/mapper/ProductMapper.java ===== */
package com.hau.product_service.mapper;


import com.hau.product_service.dto.request.ProductRequest;
import com.hau.product_service.dto.response.ProductResponse;
import com.hau.product_service.entity.Category;
import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.ProductImage;
import com.hau.product_service.entity.Rate;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.ReportingPolicy;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.util.CollectionUtils;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;


@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface ProductMapper {
    // Define mapping methods here
    @Mapping(target = "productImage", ignore = true)
    Product toProduct(ProductRequest productRequest);

    ProductResponse toProductResponse(Product product);

    @Mapping(source = "productImage", target = "imageUrls")
    @Mapping(source = "categories", target = "categories")
    ProductResponse toProductWithImageResponse(Product product);

    @Mapping(target = "productImage", ignore = true)
    Product updateProductFromRequest(ProductRequest productUpdateRequest, @MappingTarget Product product);


    default List<String> mapProductImagesToUrls(List<ProductImage> images) {
        if (CollectionUtils.isEmpty(images)) { // Sử dụng CollectionUtils cho kiểm tra null và empty
            return Collections.emptyList();
        }
        return images.stream()
                .map(ProductImage::getUrl) // Lấy URL từ mỗi ProductImage
                .collect(Collectors.toList());
    }

    default List<Long> mapCategoriesToIds(List<Category> categories) {
        if (CollectionUtils.isEmpty(categories)) {
            return Collections.emptyList();
        }
        return categories.stream()
                .map(Category::getId)
                .collect(Collectors.toList());
    }

}


/* ===== java/com/hau/product_service/mapper/RateMapper.java ===== */
package com.hau.product_service.mapper;

import com.hau.product_service.dto.request.RateRequest;
import com.hau.product_service.dto.response.RateResponse;
import com.hau.product_service.entity.Rate;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;


@Mapper(componentModel = "spring")
public interface RateMapper {

    @Mapping(target = "productId", source = "product.id")
    @Mapping(target = "userId", source = "user.id")
    RateResponse toRateResponse(Rate rate);

    @Mapping(target = "product", ignore = true)
    @Mapping(target = "user", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "id", ignore = true)
    Rate toRate(RateRequest request);

}


/* ===== java/com/hau/product_service/ProductServiceApplication.java ===== */
package com.hau.product_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableFeignClients
@EnableScheduling
public class ProductServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProductServiceApplication.class, args);
    }

}


/* ===== java/com/hau/product_service/repository/CategoryRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    void deleteByParentId(Long id);

    List<Category> findByParentId(Long parentId);


}


/* ===== java/com/hau/product_service/repository/FileServiceClientRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.config.AuthenticationRequestInterceptor;
import com.hau.product_service.config.FeignMultipartSupportConfig;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.FileResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

@FeignClient(name = "file-service", url = "${app.file-service.url}",
        configuration = {AuthenticationRequestInterceptor.class, FeignMultipartSupportConfig.class})
public interface FileServiceClientRepository {
    @PostMapping(value = "/file/media", consumes = MediaType.MULTIPART_FORM_DATA_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    ApiResponse<FileResponse> uploadFile(@RequestPart("file") MultipartFile file);

    @DeleteMapping("/file/media/{fileName}")
    ApiResponse<FileResponse> deleteFile(@PathVariable String fileName);
}


/* ===== java/com/hau/product_service/repository/ProductImageRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.ProductImage;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface ProductImageRepository extends JpaRepository<ProductImage, Long> {
    void deleteByProductId(Long id);
    Optional<List<ProductImage>> findByProductId(Long productId);
}


/* ===== java/com/hau/product_service/repository/ProductRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.dto.request.ProductFilter;
import com.hau.product_service.entity.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Query("""
    SELECT DISTINCT p FROM Product p
    JOIN p.categories c
    WHERE (:#{#filter.title} IS NULL OR p.title ILIKE CONCAT('%', :#{#filter.title}, '%'))
      AND (:#{#filter.author} IS NULL OR p.author ILIKE CONCAT('%', :#{#filter.author}, '%'))
      AND (:#{#filter.priceFrom} IS NULL OR p.price >= :#{#filter.priceFrom})
      AND (:#{#filter.priceTo} IS NULL OR p.price <= :#{#filter.priceTo})
      AND (:categoryIds IS NULL OR c.id IN (:categoryIds))
      AND (:#{#filter.averageRateFrom} IS NULL OR p.averageRate >= :#{#filter.averageRateFrom})
""")
    Page<Product> findAllByFilter(@Param("filter") ProductFilter filter,
                                  @Param("categoryIds") List<Long> categoryIds,
                                  Pageable pageable);

    @Query("""
    SELECT DISTINCT p FROM Product p
    JOIN p.categories c
    WHERE (:#{#filter.title} IS NULL OR p.title ILIKE CONCAT('%', :#{#filter.title}, '%'))
      AND (:#{#filter.author} IS NULL OR p.author ILIKE CONCAT('%', :#{#filter.author}, '%'))
      AND (:#{#filter.priceFrom} IS NULL OR p.price >= :#{#filter.priceFrom})
      AND (:#{#filter.priceTo} IS NULL OR p.price <= :#{#filter.priceTo})
      AND (:categoryIds IS NULL OR c.id IN (:categoryIds))
      AND (:#{#filter.averageRateFrom} IS NULL OR p.averageRate >= :#{#filter.averageRateFrom})
      AND (p.active = :active OR :active IS NULL)
""")
    Page<Product> findAllByActiveStatus(@Param("filter") ProductFilter filter,
                                      @Param("categoryIds") List<Long> categoryIds,
                                      Pageable pageable, @Param("active") Boolean active);


    @Query("SELECT p FROM Product p WHERE p.active = true ORDER BY p.discountPercent DESC LIMIT 10 ")
    List<Product> getTopTenBestDiscountProduct();


    @Query("SELECT p FROM Product p WHERE p.active = true ORDER BY p.averageRate DESC LIMIT 10")
    List<Product> getTopTenBestAverageRateProduct();
}


/* ===== java/com/hau/product_service/repository/RateRepository.java ===== */
package com.hau.product_service.repository;


import com.hau.product_service.entity.Rate;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface RateRepository extends JpaRepository<Rate, Long> {
    Page<Rate> findAllByProductId(Long productId, Pageable pageable);
    List<Rate> findAllByProductId(Long productId);
}


/* ===== java/com/hau/product_service/repository/UserRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Integer> {
}


/* ===== java/com/hau/product_service/service/CategoryService.java ===== */
package com.hau.product_service.service;


import com.hau.product_service.dto.request.CategoryRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.product_service.entity.Category;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.mapper.CategoryMapper;
import com.hau.product_service.repository.CategoryRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
public class CategoryService {
    private final CategoryRepository categoryRepository;
    private final CategoryMapper categoryMapper;


    @Transactional
    public void handleCategoryCreated(CategoryRequest request) {
        Category category = categoryMapper.toCategory(request);
        Category savedCategory = categoryRepository.save(category);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    public void handleCategoryUpdated(Long id, CategoryRequest request) {
        Category existCategory = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));
        Category updatedCategory = categoryMapper.toCategoryUpdateFromRequest(request, existCategory);

        Category savedCategory = categoryRepository.save(updatedCategory);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    public void handleCategoryDeleted(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));

        categoryRepository.deleteByParentId(id);
        categoryRepository.delete(category);

        ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa danh mục thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public List<Category> handleCategoryFromProduct(List<Long> categoryIds) {
        Set<Long> uniqueCategoryIds = new HashSet<>(categoryIds);
        List<Category> categories = categoryRepository.findAllById(uniqueCategoryIds);
        if (categories.size() != uniqueCategoryIds.size()) {
            throw new AppException(
                    HttpStatus.NOT_FOUND,
                    "Không tìm thấy một số danh mục trong danh sách",
                    uniqueCategoryIds
            );
        }
        return categories;
    }

    public Set<Long> findAllSubCategoryIds(Long parentId) {
        Set<Long> result = new HashSet<>();
        List<Category> children = categoryRepository.findByParentId(parentId);
        for (Category child : children) {
            result.add(child.getId());
            result.addAll(findAllSubCategoryIds(child.getId()));
        }
        return result;
    }

    public ApiResponse<List<CategoryResponse>> getAllCategories() {
        List<Category> categories = categoryRepository.findAll();
        List<CategoryResponse> responses = categories.stream()
                .map(categoryMapper::toCategoryResponse)
                .toList();

        return ApiResponse.<List<CategoryResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách danh mục thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== java/com/hau/product_service/service/event/CategoryEventConsumer.java ===== */
package com.hau.product_service.service.event;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hau.product_service.dto.request.CategoryRequest;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.event.dto.CategoryEvent;
import com.hau.product_service.service.CategoryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class CategoryEventConsumer {

    private static final String TOPIC_CATEGORY_PRODUCT_EVENT = "category-product-event";
    private final CategoryService categoryService;
    private final ObjectMapper objectMapper; // Inject ObjectMapper

    @KafkaListener(topics = TOPIC_CATEGORY_PRODUCT_EVENT)
    public void listen(CategoryEvent event) {
        log.info("Received Category Event: {}", event);

        try {
            switch (event.getType()) {
                case "CATEGORY_CREATED":
                    log.info("Handling Category Created event for ID: {}", event.getCategoryId());
                    if (event.getData() != null) {
                        CategoryResponse createdCategory = objectMapper.convertValue(event.getData(), CategoryResponse.class); // Sử dụng convertValue
                        CategoryRequest categoryRequest = convertToCategoryRequest(createdCategory);
                        categoryService.handleCategoryCreated(categoryRequest);
                    } else {
                        log.warn("Category Created event received with no data for ID: {}", event.getCategoryId());
                    }
                    break;

                case "CATEGORY_UPDATED":
                    log.info("Handling Category Updated event for ID: {}", event.getCategoryId());
                    if (event.getData() != null) {
                        CategoryResponse updatedCategory = objectMapper.convertValue(event.getData(), CategoryResponse.class); // Sử dụng convertValue
                        CategoryRequest updatedCategoryRequest = convertToCategoryRequest(updatedCategory);
                        categoryService.handleCategoryUpdated(updatedCategory.getId() ,updatedCategoryRequest);
                    } else {
                        log.warn("Category Updated event received with no data for ID: {}", event.getCategoryId());
                    }
                    break;

                case "CATEGORY_DELETED":
                    log.info("Handling Category Deleted event for ID: {}", event.getCategoryId());
                    categoryService.handleCategoryDeleted(event.getCategoryId());
                    break;

                default:
                    log.warn("Received unknown Category Event type: {}", event.getType());
            }

            if (event.getCategoryId() != null) { // Kiểm tra null cho categoryId trước khi log
                log.info("Successfully processed Category Event for ID: {}", event.getCategoryId());
            } else {
                log.info("Successfully processed Category Event (ID not provided in event)");
            }


        } catch (Exception e) {
            String eventIdLog = (event != null && event.getCategoryId() != null) ? event.getCategoryId().toString() : "N/A";
            log.error("Error processing Category Event for ID {}: {}", eventIdLog, e.getMessage(), e);
        }
    }


    private CategoryRequest convertToCategoryRequest(CategoryResponse category) {
        if (category == null) {
            return null;
        }
        CategoryRequest categoryRequest = new CategoryRequest();
        categoryRequest.setId(category.getId());
        categoryRequest.setName(category.getName());
        categoryRequest.setSlug(category.getSlug());
        categoryRequest.setParentId(category.getParentId());
        return categoryRequest;
    }
}

/* ===== java/com/hau/product_service/service/event/UserEventConsumer.java ===== */
package com.hau.product_service.service.event;

import com.hau.event.dto.UserCreateEvent;
import com.hau.product_service.entity.User;
import com.hau.product_service.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserEventConsumer {
    private final UserRepository userRepository;

    @KafkaListener(topics = "user-created-topic")
    public void handleUserCreateEvent(UserCreateEvent userCreateEvent) {
        log.info("Received user create event: {}", userCreateEvent);

        Optional<User> existingUser = userRepository.findById(userCreateEvent.getId());

        if (existingUser.isPresent()) {
            log.warn("User with id {} already exists. Skipping creation for this event.", userCreateEvent.getId());
        } else {
            User newUser = User.builder()
                    .id(userCreateEvent.getId())
                    .username(userCreateEvent.getUsername())
                    .build();
            try {
                userRepository.save(newUser); // Let JPA manage the ID and version
                log.info("Successfully created user with id {}", newUser.getId()); // Log the newly generated ID
            } catch (Exception e) {
                log.error("Failed to save user with id {}. Error: {}", userCreateEvent.getId(), e.getMessage(), e);
                throw new RuntimeException("Failed to save user", e);
            }
        }
    }
}

/* ===== java/com/hau/product_service/service/FileUploadService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.exception.AppException;
import com.hau.product_service.repository.FileServiceClientRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

@RequiredArgsConstructor
@Service
public class FileUploadService {
    private final FileServiceClientRepository fileServiceClientRepository;

    String uploadFileAndGetUrl(MultipartFile file, String fileTypeDescription) {
        if (file == null || file.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "File " + fileTypeDescription + " không được để trống", null);
        }
        try {
            var fileResponse = fileServiceClientRepository.uploadFile(file);
            if (fileResponse != null && fileResponse.getResult() != null && fileResponse.getResult().getUrl() != null) {
                return fileResponse.getResult().getUrl(); // Return only the relative URL path
            } else {
                throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Không nhận được thông tin hợp lệ từ file-service cho " + fileTypeDescription, null);
            }
        } catch (Exception e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi tải lên file " + fileTypeDescription, e);
        }
    }
}


/* ===== java/com/hau/product_service/service/ProductImageService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.ProductImage;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.repository.FileServiceClientRepository;
import com.hau.product_service.repository.ProductImageRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@Service
@RequiredArgsConstructor
public class ProductImageService {
    private final ProductImageRepository productImageRepository;
    private final FileUploadService fileUploadService;
    private final FileServiceClientRepository fileServiceClient;

    @Transactional
    public void deleteAllByProductId(Long productId) {
        deleteImage(productId);
        productImageRepository.deleteByProductId(productId);
    }

    @Transactional
    public void createImageByProduct(Product product, List<MultipartFile> images) {
            if(images != null && !images.isEmpty()) {
                for (MultipartFile imageFile : images) {
                    if (imageFile != null && !imageFile.isEmpty()) {
                        try {
                            String imageUrl = fileUploadService.uploadFileAndGetUrl(imageFile, "product image");

                            ProductImage productImage = new ProductImage();
                            productImage.setProduct(product);
                            productImage.setUrl(imageUrl);

                            productImageRepository.save(productImage);
                        } catch (Exception e) {
                            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi tải lên hình ảnh sản phẩm: " + imageFile.getOriginalFilename(), e);
                        }
                    }
                }
            }
    }

    @Transactional
    public void deleteImage(Long productId) {
        List<ProductImage> productImage = productImageRepository.findByProductId(productId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy ảnh sản phẩm", null));

        try {
            for (ProductImage item : productImage) {
                fileServiceClient.deleteFile(item.getUrl());
            };
        } catch (Exception e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi xóa ảnh sản phẩm", e);
        }
    }

}


/* ===== java/com/hau/product_service/service/ProductService.java ===== */
package com.hau.product_service.service;

import com.hau.event.dto.NotificationEvent;
import com.hau.event.dto.ProductEvent;
import com.hau.product_service.entity.Category;
import com.hau.product_service.repository.FileServiceClientRepository;
import com.hau.product_service.converter.StringConverter;
import com.hau.product_service.dto.request.ProductFilter;
import com.hau.product_service.dto.request.ProductRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResult;
import com.hau.product_service.dto.response.ProductResponse;
import com.hau.product_service.entity.Product;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.mapper.ProductMapper;
import com.hau.product_service.repository.ProductRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.web.multipart.MultipartFile;


import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ProductService {
    private final ProductRepository productRepository;
    private final ProductMapper productMapper;
    private final FileServiceClientRepository fileServiceClientRepository;
    private final ProductImageService productImageService;
    private final FileUploadService fileUploadService;
    private final SlugService slugService;
    private final CategoryService categoryService;
    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final RateService rateService;


    @Value("${app.file.download-prefix}")
    private String fileServiceUrl;

    public ApiResponse<PageResult<ProductResponse>> getAllProduct(ProductFilter filter, Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;

        Sort sort;
        if (filter.getSortDir() != null && !filter.getSortDir().isEmpty()) {
            Sort.Direction direction = "asc".equalsIgnoreCase(filter.getSortDir()) ? Sort.Direction.ASC : Sort.Direction.DESC;
            sort = Sort.by(direction, "price");
        } else {
            sort = Sort.by(Sort.Direction.DESC, "createdAt");
        }

        Pageable pageable = PageRequest.of(page, pageSize, sort);

        List<Long> categoryIds = null;
        if (filter.getCategoryId() != null) {
            Set<Long> allCategoryIds = new HashSet<>();
            allCategoryIds.add(filter.getCategoryId());
            allCategoryIds.addAll(categoryService.findAllSubCategoryIds(filter.getCategoryId()));
            categoryIds = allCategoryIds.stream().toList();
        }

        Page<Product> productPage = productRepository.findAllByFilter(filter, categoryIds, pageable);

        List<ProductResponse> responses = productPage.getContent().stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();

        PageResult<ProductResponse> result = new PageResult<>(
                responses,
                productPage.getNumber() + 1,
                productPage.getSize(),
                productPage.getTotalPages(),
                productPage.getTotalElements(),
                productPage.hasNext(),
                productPage.hasPrevious()
        );

        return ApiResponse.<PageResult<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm thành công")
                .result(result)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<PageResult<ProductResponse>> getAllProductByActive(ProductFilter filter, Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;

        Sort sort;
        if (filter.getSortDir() != null && !filter.getSortDir().isEmpty()) {
            Sort.Direction direction = "asc".equalsIgnoreCase(filter.getSortDir()) ? Sort.Direction.ASC : Sort.Direction.DESC;
            sort = Sort.by(direction, "price");
        } else {
            sort = Sort.by(Sort.Direction.DESC, "createdAt");
        }

        Pageable pageable = PageRequest.of(page, pageSize, sort);

        List<Long> categoryIds = null;
        if (filter.getCategoryId() != null) {
            Set<Long> allCategoryIds = new HashSet<>();
            allCategoryIds.add(filter.getCategoryId());
            allCategoryIds.addAll(categoryService.findAllSubCategoryIds(filter.getCategoryId()));
            categoryIds = allCategoryIds.stream().toList();
        }

        // Explicitly search for active=true products
        Page<Product> productPage = productRepository.findAllByActiveStatus(filter, categoryIds, pageable, Boolean.TRUE);

        List<ProductResponse> responses = productPage.getContent().stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();

        PageResult<ProductResponse> result = new PageResult<>(
                responses,
                productPage.getNumber() + 1,
                productPage.getSize(),
                productPage.getTotalPages(),
                productPage.getTotalElements(),
                productPage.hasNext(),
                productPage.hasPrevious()
        );

        return ApiResponse.<PageResult<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm đang hoạt động thành công")
                .result(result)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<ProductResponse>> getTopTenProductByBestDiscountPercent() {
        List<Product> products = productRepository.getTopTenBestDiscountProduct();
        List<ProductResponse> responses = products.stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();
        return ApiResponse.<List<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<ProductResponse>> getTopTenProductByAverageRate() {
        List<Product> products = productRepository.getTopTenBestAverageRateProduct();
        List<ProductResponse> responses = products.stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();
        return ApiResponse.<List<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional // Ensure atomicity
    public ApiResponse<ProductResponse> createProduct(ProductRequest request, MultipartFile thumbnail, List<MultipartFile> images) {
        if (thumbnail == null || thumbnail.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Ảnh thumbnail không được để trống", null);
        }

        if (images == null || images.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Danh sách ảnh sản phẩm không được để trống", null);
        }

        List<Category> categories = categoryService.handleCategoryFromProduct(request.getCategoryIds());

        Product product = productMapper.toProduct(request);
        product.setActive(true);
        product.setCategories(categories);

        product.setDiscountPercent(calculateProductDiscountPercent(product.getPrice(), product.getDiscount()));
        product.setAverageRate(0.0f);
        String thumbnailUrl = fileUploadService.uploadFileAndGetUrl(thumbnail, "thumbnail");
        product.setThumbnail(thumbnailUrl);

        product.setSlug(StringConverter.toSlug(product.getTitle()));

        Product savedProduct = productRepository.save(product);
        Long productId = savedProduct.getId();

        String uniqueSlug = slugService.generateUniqueSlug(savedProduct.getTitle(), productId);
        savedProduct.setSlug(uniqueSlug);

        productImageService.createImageByProduct(savedProduct, images);

        savedProduct.setProductImage(null);
        savedProduct = productRepository.save(savedProduct);

        ProductEvent productEvent = ProductEvent.builder()
                .id(savedProduct.getId())
                .discount(savedProduct.getDiscount())
                .price(savedProduct.getPrice())
                .quantity(savedProduct.getQuantity())
                .title(savedProduct.getTitle())
                .build();
        kafkaTemplate.send("product-create-topic", productEvent);
        ProductResponse productResponse = productMapper.toProductResponse(savedProduct);
        productResponse.setThumbnail(fileServiceUrl + savedProduct.getThumbnail());

        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Thêm sản phẩm thành công")
                .result(productResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }


    // Modified to handle thumbnail and image updates
    @Transactional
    public ApiResponse<ProductResponse> updateProduct(ProductRequest request, Long id, MultipartFile thumbnail, List<MultipartFile> images) {
        Product existProduct = productRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));

        Product product = productMapper.updateProductFromRequest(request, existProduct);

        List<Category> categories = categoryService.handleCategoryFromProduct(request.getCategoryIds());

        if (request.getActive() != null) {
            existProduct.setActive(request.getActive());
        }

        if (thumbnail != null && !thumbnail.isEmpty()) {
            fileServiceClientRepository.deleteFile(existProduct.getThumbnail());
            String newThumbnailUrl = fileUploadService.uploadFileAndGetUrl(thumbnail, "new thumbnail");
            existProduct.setThumbnail(newThumbnailUrl);
        }

        if (!CollectionUtils.isEmpty(images)) {
            productImageService.deleteAllByProductId(id);
            productImageService.createImageByProduct(product, images);
        }

        existProduct.setDiscountPercent(calculateProductDiscountPercent(product.getPrice(), product.getDiscount()));
        existProduct.setSlug(slugService.generateUniqueSlug(product.getTitle(), id));
        existProduct.setCategories(categories);
        Product savedProduct = productRepository.save(existProduct);

        ProductEvent productEvent = ProductEvent.builder()
                .id(savedProduct.getId())
                .discount(savedProduct.getDiscount())
                .price(savedProduct.getPrice())
                .quantity(savedProduct.getQuantity())
                .title(savedProduct.getTitle())
                .build();
        kafkaTemplate.send("product-update-topic", productEvent);

        ProductResponse response = productMapper.toProductResponse(savedProduct);
        response.setThumbnail(savedProduct.getThumbnail());


        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật sản phẩm thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }



    public ApiResponse<ProductResponse> deleteProduct(Long id) {
        Product product =  productRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));

        productImageService.deleteImage(product.getId());
        fileServiceClientRepository.deleteFile(product.getThumbnail());
        productRepository.deleteById(id);
        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa sản phẩm thành công")
                .timestamp(LocalDateTime.now())
                .build();
    }



    public ApiResponse<ProductResponse> getProductById(Long productId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));
        ProductResponse response = productMapper.toProductWithImageResponse(product);
        response.setThumbnail(fileServiceUrl + product.getThumbnail());
        List<String> imageUrls = response.getImageUrls();
        for(String item : imageUrls) {
            imageUrls.set(imageUrls.indexOf(item), fileServiceUrl + item);
        }
        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy sản phẩm thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }


    public void updateProductQuantity(NotificationEvent notificationEvent) {
        Map<String, Object> params = notificationEvent.getParams();
        Object orderProducts = params.get("orderProducts");

        if (orderProducts instanceof List<?> orderProductList) {
            for (Object item : orderProductList) {
                if (item instanceof Map<?, ?> productMap) {
                    log.info("Product map: {}", productMap);

                    Object productIdObj = productMap.get("productId");
                    if (!(productIdObj instanceof Integer)) {
                        log.error("productId không phải là Integer.  Value: {}", productIdObj);
                        continue;
                    }
                    Long productId = ((Integer) productIdObj).longValue();


                    Object quantityObj = productMap.get("quantity");
                    if (!(quantityObj instanceof Integer)) {
                        log.error("quantity không phải là Integer. Value: {}", quantityObj);
                        continue;
                    }
                    int quantity = (Integer) quantityObj;


                    try {
                        Product product = productRepository.findById(productId)
                                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));
                        product.setQuantity(product.getQuantity() - quantity);
                        productRepository.save(product);
                    } catch (AppException e) {
                        log.error("Lỗi khi xử lý sản phẩm với productId {}: {}", productId, e.getMessage());
                    }
                }
            }
        } else {
            log.warn("orderProducts không phải là List hoặc null");
        }
    }

    public Double calculateProductDiscountPercent(Integer price, Integer discount) {
        if (price == null || discount == null || price <= 0) {
            return 0.0;
        }
        return 100 - ((double) discount / price) * 100;
    }
}


/* ===== java/com/hau/product_service/service/RateService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.dto.request.RateRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResult;
import com.hau.product_service.dto.response.RateResponse;
import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.Rate;
import com.hau.product_service.entity.User;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.mapper.RateMapper;
import com.hau.product_service.repository.ProductRepository;
import com.hau.product_service.repository.RateRepository;
import com.hau.product_service.repository.UserRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class RateService {
    private final RateRepository rateRepository;
    private final RateMapper rateMapper;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;

    public ApiResponse<PageResult<RateResponse>> getAllRate(Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;
        Pageable pageable = PageRequest.of(page, pageSize);

        Page<Rate> rates = rateRepository.findAll(pageable);

        List<RateResponse> rateResponses = rates.getContent().stream()
                .map(rateMapper::toRateResponse)
                .toList();

        PageResult<RateResponse> result = new PageResult<>(
                rateResponses,
                rates.getNumber() + 1,
                rates.getSize(),
                rates.getTotalPages(),
                rates.getTotalElements(),
                rates.hasNext(),
                rates.hasPrevious()
        );


        return ApiResponse.<PageResult<RateResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Get all rates successfully")
                .result(result)
                .build();
    }

    public ApiResponse<RateResponse> getRateById(Long id) {
        Rate rate = rateRepository.findById(id).orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy đánh giá ", "id = " + id));
        RateResponse rateResponse = rateMapper.toRateResponse(rate);
        return ApiResponse.<RateResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy đánh giá thành công")
                .result(rateResponse)
                .build();
    }

    public ApiResponse<PageResult<RateResponse>> getRateByProductId(Long productId, Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;
        Pageable pageable = PageRequest.of(page, pageSize);

        Page<Rate> rates = rateRepository.findAllByProductId(productId, pageable);

        List<RateResponse> rateResponses = rates.getContent().stream()
                .map(rateMapper::toRateResponse)
                .toList();

        PageResult<RateResponse> result = new PageResult<>(
                rateResponses,
                rates.getNumber() + 1,
                rates.getSize(),
                rates.getTotalPages(),
                rates.getTotalElements(),
                rates.hasNext(),
                rates.hasPrevious()
        );

        return ApiResponse.<PageResult<RateResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy đánh giá thành công")
                .result(result)
                .build();
    }

    @Transactional
    public ApiResponse<RateResponse> createRate(RateRequest request) {
        Product product = productRepository.findById(request.getProductId())
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy sản phẩm", "id = " + request.getProductId()));
        Integer userId = Integer.valueOf(SecurityContextHolder.getContext().getAuthentication().getName());
        User user =  userRepository.findById(userId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy người dùng", "id = " + userId));
        Rate newRate = rateMapper.toRate(request);

        newRate.setProduct(product);
        newRate.setUser(user);
        Rate savedRate = rateRepository.save(newRate);
        Float averageRate = calculateAverageRate(newRate.getProduct().getId());
        product.setAverageRate(averageRate);
        productRepository.save(product);

        RateResponse rateResponse = rateMapper.toRateResponse(savedRate);

        return ApiResponse.<RateResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo đánh giá thành công")
                .result(rateResponse)
                .build();
    }

    @Transactional
    public ApiResponse<RateResponse> removeRate(Long id) {
        Rate rate = rateRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy đánh giá", "id = " + id));
        rateRepository.delete(rate);
        Product product = rate.getProduct();
        Float averageRate = calculateAverageRate(product.getId());
        product.setAverageRate(averageRate);
        productRepository.save(product);
        return ApiResponse.<RateResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa đánh giá thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public Float calculateAverageRate(Long productId) {
        List<Rate> rates = rateRepository.findAllByProductId(productId);

        float totalRate = 0f;
        for (Rate rate : rates) {
            totalRate += rate.getVote();
        }
        return Float.valueOf(String.format("%.1f", totalRate / rates.size())) ;
    }

}


/* ===== java/com/hau/product_service/service/SlugService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.converter.StringConverter;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class SlugService {
    String generateUniqueSlug(String title, Long productId) {
        String baseSlug = StringConverter.toSlug(title);
        return baseSlug + "-" + productId;
    }

}




/* ===== product-service\src\main\java\com\hau\event\dto\CategoryEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;


@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryEvent {
    private String type;
    private Long categoryId;
    private Object data;

    // Enum hoặc Constant cho các loại sự kiện
    public static String TYPE_CREATED = "CATEGORY_CREATED";
    public static String TYPE_UPDATED = "CATEGORY_UPDATED";
    public static String TYPE_DELETED = "CATEGORY_DELETED";
}


/* ===== product-service\src\main\java\com\hau\event\dto\NotificationEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationEvent {
    private String channel;
    private String recipient;
    private String templateCode;
    private Map<String, Object> params;
}


/* ===== product-service\src\main\java\com\hau\event\dto\ProductEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductEvent {
    private Long id;
    private Integer discount;
    private Integer price;
    private Integer quantity;
    private String title;
}


/* ===== product-service\src\main\java\com\hau\event\dto\UserCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCreateEvent {
    private String username;
    private Integer id;
}


/* ===== product-service\src\main\java\com\hau\product_service\ProductServiceApplication.java ===== */
package com.hau.product_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableFeignClients
@EnableScheduling
public class ProductServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProductServiceApplication.class, args);
    }

}


/* ===== product-service\src\main\java\com\hau\product_service\config\AuthenticationRequestInterceptor.java ===== */
package com.hau.product_service.config;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
public class AuthenticationRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes servletRequestAttributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

        assert servletRequestAttributes != null;
        var authHeader = servletRequestAttributes.getRequest().getHeader("Authorization");
        log.info("Auth header: {}", authHeader);
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            requestTemplate.header("Authorization", authHeader);
        } else {
            log.warn("No Authorization header found in the request");
        }
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\config\CustomJwtDecoder.java ===== */
package com.hau.product_service.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\config\FeignMultipartSupportConfig.java ===== */
package com.hau.product_service.config;

import feign.codec.Encoder;
import feign.form.spring.SpringFormEncoder;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringEncoder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class FeignMultipartSupportConfig {
    @Bean
    public Encoder feignFormEncoder() {
        return new SpringFormEncoder(new SpringEncoder(() -> new HttpMessageConverters(new RestTemplate().getMessageConverters())));
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.product_service.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.product_service.dto.response.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\config\SecurityConfig.java ===== */
package com.hau.product_service.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
        "/**"
    };


    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.GET, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== product-service\src\main\java\com\hau\product_service\controller\CategoryController.java ===== */
package com.hau.product_service.controller;

import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.product_service.service.CategoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class CategoryController {
    private final CategoryService categoryService;

    @GetMapping("/category")
    public ResponseEntity<ApiResponse<List<CategoryResponse>>> getAllCategories() {
        ApiResponse<List<CategoryResponse>> response = categoryService.getAllCategories();
        return ResponseEntity.ok(response);
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\controller\ProductController.java ===== */
package com.hau.product_service.controller;

import com.hau.event.dto.NotificationEvent;
import com.hau.product_service.dto.request.ProductFilter;
import com.hau.product_service.dto.request.ProductRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResponse;
import com.hau.product_service.dto.response.ProductResponse;
import com.hau.product_service.service.ProductService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.apache.kafka.shaded.com.google.protobuf.Api;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class ProductController {
    private final ProductService productService;

    @GetMapping
    public ResponseEntity<ApiResponse<PageResponse<ProductResponse>> >getAllProduct(@ModelAttribute ProductFilter filter,
                                                                  @RequestParam(defaultValue = "1", required = false) Integer pageIndex,
                                                                  @RequestParam(defaultValue = "10", required = false) Integer pageSize) {
        ApiResponse<PageResponse<ProductResponse>> response = productService.getAllProduct(filter, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/active")
    public ResponseEntity<ApiResponse<PageResponse<ProductResponse>>> getAllProductByActive(@ModelAttribute ProductFilter filter,
                                                                                          @RequestParam(defaultValue = "1", required = false) Integer pageIndex,
                                                                                          @RequestParam(defaultValue = "10", required = false) Integer pageSize) {
        ApiResponse<PageResponse<ProductResponse>> response = productService.getAllProductByActive(filter, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/top-discount")
    public ResponseEntity<ApiResponse<List<ProductResponse>>> getTopTenBestDiscountProduct() {
        ApiResponse<List<ProductResponse>> response = productService.getTopTenProductByBestDiscountPercent();
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/top-rating")
    public ResponseEntity<ApiResponse<List<ProductResponse>>> getTopTenBestAverageRateProduct() {
        ApiResponse<List<ProductResponse>> response = productService.getTopTenProductByAverageRate();
        return new ResponseEntity<>(response, HttpStatus.OK);
    }


    @PostMapping
    public ResponseEntity<ApiResponse<ProductResponse>> createProduct(
            @RequestPart("product") @Valid ProductRequest request,
            @RequestPart("thumbnail") MultipartFile thumbnail,
            @RequestPart(value = "images", required = false) List<MultipartFile> images // Added: accept multiple images, make it optional
    ) {
        ApiResponse<ProductResponse> response = productService.createProduct(request, thumbnail, images);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    // Modified for image/thumbnail update
    @PutMapping(value = "/{productId}")
    public ResponseEntity<ApiResponse<ProductResponse>> updateProduct(
            @PathVariable Long productId,
            @RequestPart("product") @Valid ProductRequest request,
            @RequestPart(value = "thumbnail", required = false) MultipartFile thumbnail,
            @RequestPart(value = "images", required = false) List<MultipartFile> images
    ) {
        ApiResponse<ProductResponse> response = productService.updateProduct(request, productId, thumbnail, images);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @DeleteMapping("/{productId}")
    public ResponseEntity<ApiResponse<ProductResponse>> deleteProduct(@PathVariable Long productId) {
        ApiResponse<ProductResponse> response = productService.deleteProduct(productId);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/{productId}")
    public ResponseEntity<ApiResponse<ProductResponse>> getProductById(@PathVariable Long productId) {
        ApiResponse<ProductResponse> response = productService.getProductById(productId);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @KafkaListener(topics = "order-create-notification-topic")
    public void updateProductQuantity(NotificationEvent notificationEvent) {
        productService.updateProductQuantity(notificationEvent);
    }

    @PutMapping(value = "/active/{id}")
    public ResponseEntity<ApiResponse<ProductResponse>> updateProductStatus(@PathVariable Long id, @RequestBody Boolean active) {
        ApiResponse<ProductResponse> response = productService.updateProductStatus(id, active);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\controller\RateController.java ===== */
package com.hau.product_service.controller;

import com.hau.product_service.dto.request.RateRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResponse;
import com.hau.product_service.dto.response.RateResponse;
import com.hau.product_service.service.RateService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequiredArgsConstructor
public class RateController {
    private final RateService rateService;

    @GetMapping("/rate")
    public ResponseEntity<ApiResponse<PageResponse<RateResponse>>> getAllRate(@RequestParam(required = false, defaultValue = "1")  Integer pageIndex,
                                                                            @RequestParam(required = false, defaultValue = "10") Integer pageSize) {
        ApiResponse<PageResponse<RateResponse>> response = rateService.getAllRate(pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/rate/{id}")
    public ResponseEntity<ApiResponse<RateResponse>> getRateById(@PathVariable Long id) {
        ApiResponse<RateResponse> response = rateService.getRateById(id);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/rate/product/{productId}")
    public ResponseEntity<ApiResponse<PageResponse<RateResponse>>> getRateByProductId(@PathVariable Long productId,
                                                                                     @RequestParam(required = false, defaultValue = "1") Integer pageIndex,
                                                                                     @RequestParam(required = false, defaultValue = "10") Integer pageSize) {
        ApiResponse<PageResponse<RateResponse>> response = rateService.getRateByProductId(productId, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/rate")
    public ResponseEntity<ApiResponse<RateResponse>> createRate(@RequestBody @Valid RateRequest request) {
        ApiResponse<RateResponse> response = rateService.createRate(request);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @DeleteMapping("/rate/{id}")
    public ResponseEntity<ApiResponse<RateResponse>> deleteRate(@PathVariable Long id) {
        ApiResponse<RateResponse> response = rateService.removeRate(id);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }



}


/* ===== product-service\src\main\java\com\hau\product_service\converter\StringConverter.java ===== */
package com.hau.product_service.converter;

public class StringConverter {
    public static String toSlug(String str) {
        // Convert to lowercase
        str = str.toLowerCase();

        // Replace spaces with hyphens
        str = str.replaceAll(" ", "-");

        // Remove special characters
        str = str.replaceAll("[^a-z0-9-]", "");

        // Remove consecutive hyphens
        str = str.replaceAll("-+", "-");

        // Trim leading and trailing hyphens
        str = str.replaceAll("^-|-$", "");

        return str;
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\request\CategoryRequest.java ===== */
package com.hau.product_service.dto.request;


import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryRequest {
    @NotNull(message = "ID danh mục không được để trống")
    private Long id;
    @NotNull(message = "Tên danh mục không được để trống")
    private String name;
    @NotNull(message = "Độ ưu tiên không được để trống")
    @Min(value = 1, message = "Mức độ ưu tiên phải lớn hơn 0")
    private Integer priority;
    private Long parentId;
    private String slug;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\request\ProductFilter.java ===== */
package com.hau.product_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductFilter {
    private String title;
    private String author;
    private Integer priceFrom;
    private Integer priceTo;
    private String sortBy;
    private String sortDir;
    private Long categoryId;
    private Float averageRateFrom;

    public boolean isEmpty() {
        return (title == null || title.isEmpty()) &&
                (author == null || author.isEmpty()) &&
                (priceFrom == null || priceFrom <= 0) &&
                (priceTo == null || priceTo <= 0) &&
                (sortBy == null || sortBy.isEmpty()) &&
                (sortDir == null || sortDir.isEmpty()) &&
                (categoryId == null || categoryId <= 0) &&
                (averageRateFrom == null || averageRateFrom <= 0);
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\request\ProductImageRequest.java ===== */
package com.hau.product_service.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
public class ProductImageRequest {
    @NotNull
    Long productId;
    @NotBlank
    String imageUrl;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\request\ProductRequest.java ===== */
package com.hau.product_service.dto.request;

import jakarta.validation.constraints.*;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductRequest {
    @NotBlank(message = "Tên sản phẩm không được để trống")
    @NotNull
    private String title;

    @NotBlank(message = "Tác giả không được để trống")
    @NotNull
    private String author;

    @NotBlank(message = "Nhà xuất bản không được để trống")
    private String publisher;

    @NotNull(message = "Năm xuất bản không được để trống")
    private Integer publicationYear;

    @NotNull(message = "Kích thước đóng gói không được để trống")
    @Min(value = 1, message = "Kích thước đóng gói phải lớn hơn 0")
    private Integer packageSize;

    @NotNull(message = "Số trang không được để trống")
    @Min(value = 1, message = "Số trang phải lớn hơn 0")
    private Integer pageSize;

    @NotBlank(message = "Hình thức không được để trống") // ví dụ: Bìa mềm, Bìa cứng
    private String form;


    @NotNull(message = "Số lượng không được để trống")
    @Min(value = 0, message = "Số lượng phải >= 0")
    private Integer quantity;

    @NotNull(message = "giá hiện tại không được để trống")
    @Min(value = 1, message = "Giá hiện tại phải > 0")
    private Integer discount;

    @NotNull(message = "Giá cũ không được để trống")
    @Min(value = 1000, message = "Giá cũ phải > 0")
    private Integer price;

    @NotNull(message = "Độ ưu tiên không được để trống")
    @Min(value = 0, message = "Độ ưu tiên phải >= 0")
    private Integer priority;

    @NotBlank(message = "Mô tả không được để trống")
    private String description;

    Boolean active;

    private List<Long> categoryIds;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\request\RateRequest.java ===== */
package com.hau.product_service.dto.request;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class RateRequest {
    @NotNull(message = "Mã sản phẩm không được để trống")
    private Long productId;

    @NotNull(message = "Điểm đánh giá không được để trống")
    @Min(value = 1, message = "Điểm đánh giá phải lớn hơn hoặc bằng 1")
    @Max(value = 5, message = "Điểm đánh giá phải nhỏ hơn hoặc bằng 5")
    private int vote;

    private String comment;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\response\ApiResponse.java ===== */
package com.hau.product_service.dto.response;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\response\CategoryResponse.java ===== */
package com.hau.product_service.dto.response;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CategoryResponse {
    private Long id;
    private String name;
    private Long priority;
    private Long parentId;
    private String slug;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\response\ErrorsResponse.java ===== */
package com.hau.product_service.dto.response;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\response\FileResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FileResponse {
    private String originalFileName;
    private String url;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\response\PageResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}

/* ===== product-service\src\main\java\com\hau\product_service\dto\response\ProductImageResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
public class ProductImageResponse {
    private String url;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\response\ProductResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductResponse {
    private Long id;
    private String title;
    private String author;
    private String publisher;
    private Integer publicationYear;
    private Integer packageSize;
    private Integer pageSize;
    private String form;
    private String thumbnail;
    private Integer quantity;
    private Integer discount;
    private Integer price;
    private Double discountPercent;
    private Integer priority;
    private String description;
    private Float averageRate;

    private boolean active;

    private List<String> imageUrls;
    private List<Long> categories;
    private LocalDateTime createdAt;
}


/* ===== product-service\src\main\java\com\hau\product_service\dto\response\RateResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RateResponse {
    private Long id;
    private Long productId;
    private Integer userId;
    private Integer vote;
    private String comment;
    private String createdAt;
}


/* ===== product-service\src\main\java\com\hau\product_service\entity\Category.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;


@Table(name = "categories")
@Entity
@Data
public class Category {
    @Id
    private Long id;
    private String name;
    private String slug;
    private Long parentId;


    @ManyToMany(mappedBy = "categories", fetch = FetchType.LAZY)
    @EqualsAndHashCode.Exclude
    @ToString.Exclude
    private List<Product> products = new ArrayList<>();

}


/* ===== product-service\src\main\java\com\hau\product_service\entity\Product.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.CreationTimestamp;

import java.util.ArrayList;
import java.util.List;

import java.time.LocalDateTime;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "products")
@FieldDefaults(level = AccessLevel.PRIVATE)
public class Product {
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Id
    Long id;
    String title;
    String author;
    String publisher;
    Integer publicationYear;
    Integer packageSize;
    Integer pageSize;
    String form;
    String thumbnail;
    Integer quantity;
    Integer discount;
    Integer price;
    Integer priority;
    String description;
    @Column(unique = true)
    String slug;
    Double discountPercent;

    @ManyToMany(fetch = FetchType.LAZY) // Use LAZY fetching
    @JoinTable(
            name = "product_category", // Name of the join table
            joinColumns = @JoinColumn(name = "product_id", referencedColumnName = "id"), // Column referring to Product's ID
            inverseJoinColumns = @JoinColumn(name = "category_id", referencedColumnName = "id") // Column referring to Category's ID
    )
    // Exclude from equals and hashCode/toString generated by Lombok @Data
    // to prevent infinite loops or StackOverflow errors in bidirectional relationships.
    @EqualsAndHashCode.Exclude
    @ToString.Exclude
    private List<Category> categories = new ArrayList<>();

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, mappedBy = "product")
    List<ProductImage> productImage = new ArrayList<>();

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true)
    List<Rate> rates;

    private Float averageRate;

    boolean active;
    @CreationTimestamp
    LocalDateTime createdAt;
    @CreationTimestamp
    LocalDateTime updatedAt;


}


/* ===== product-service\src\main\java\com\hau\product_service\entity\ProductImage.java ===== */
package com.hau.product_service.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@Table(name = "product_images")
@NoArgsConstructor
@AllArgsConstructor
public class ProductImage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @JsonIgnore
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;
    private String url;
}


/* ===== product-service\src\main\java\com\hau\product_service\entity\Rate.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "rates")
public class Rate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int vote;
    private String comment;
    @ManyToOne
    @JoinColumn(name = "product_id", referencedColumnName = "id")
    private Product product;

    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id")
    private User user;

    @CreationTimestamp
    LocalDateTime createdAt;
}


/* ===== product-service\src\main\java\com\hau\product_service\entity\User.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Entity
@Data
@Table(name = "users")
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    private Integer id;
    private String username;
    @Version
    private Integer version;
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Rate> rate;
}


/* ===== product-service\src\main\java\com\hau\product_service\exception\AppException.java ===== */
package com.hau.product_service.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\exception\GlobalExceptionHandler.java ===== */
package com.hau.product_service.exception;

import com.hau.product_service.dto.response.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
//import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.multipart.support.MissingServletRequestPartException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    @ExceptionHandler(MissingServletRequestPartException.class)
    public ResponseEntity<ErrorsResponse> handleMissingServletRequestPartException(MissingServletRequestPartException ex) {
        String errorMessage = getString(ex);

        // Tạo đối tượng ErrorsResponse với status 400 và thông báo lỗi tùy chỉnh
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), // Status luôn là 400 cho loại lỗi này
                errorMessage,
                // Bạn có thể đưa tên part bị thiếu vào trường 'error' nếu muốn chi tiết hơn
                // hoặc để null như AppException mặc định nếu error không có thông tin cụ thể
                null, // Hoặc partName
                LocalDateTime.now()
        );

        // Trả về ResponseEntity với status 400
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    private static String getString(MissingServletRequestPartException ex) {
        String partName = ex.getRequestPartName();
        String errorMessage;
        // Tạo thông báo lỗi thân thiện dựa trên tên part bị thiếu
        if ("thumbnail".equals(partName)) {
            errorMessage = "Ảnh thumbnail không được để trống";
        } else if ("images".equals(partName)) {
            errorMessage = "Danh sách ảnh sản phẩm không được để trống";
        }
        else {
            // Trường hợp thiếu part khác không phải thumbnail hoặc images
            errorMessage = "Thiếu phần yêu cầu trong request: " + partName;
        }
        return errorMessage;
    }

    // Xử lý lỗi không có quyền truy cập
//    @ExceptionHandler(AuthorizationDeniedException.class)
//    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
//    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
//    @ExceptionHandler(Exception.class)
//    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
//    }

}


/* ===== product-service\src\main\java\com\hau\product_service\mapper\CategoryMapper.java ===== */
package com.hau.product_service.mapper;

import com.hau.product_service.dto.request.CategoryRequest;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.product_service.entity.Category;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface CategoryMapper {
    CategoryResponse toCategoryResponse(Category category);

    Category toCategory(CategoryRequest categoryRequest);

    Category toCategoryUpdateFromRequest(CategoryRequest categoryRequest, @MappingTarget Category category);
}



/* ===== product-service\src\main\java\com\hau\product_service\mapper\ProductMapper.java ===== */
package com.hau.product_service.mapper;


import com.hau.product_service.dto.request.ProductRequest;
import com.hau.product_service.dto.response.ProductResponse;
import com.hau.product_service.entity.Category;
import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.ProductImage;
import com.hau.product_service.entity.Rate;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.ReportingPolicy;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.util.CollectionUtils;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;


@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface ProductMapper {
    // Define mapping methods here
    @Mapping(target = "productImage", ignore = true)
    Product toProduct(ProductRequest productRequest);

    ProductResponse toProductResponse(Product product);

    @Mapping(source = "productImage", target = "imageUrls")
    @Mapping(source = "categories", target = "categories")
    ProductResponse toProductWithImageResponse(Product product);

    @Mapping(target = "productImage", ignore = true)
    Product updateProductFromRequest(ProductRequest productUpdateRequest, @MappingTarget Product product);


    default List<String> mapProductImagesToUrls(List<ProductImage> images) {
        if (CollectionUtils.isEmpty(images)) { // Sử dụng CollectionUtils cho kiểm tra null và empty
            return Collections.emptyList();
        }
        return images.stream()
                .map(ProductImage::getUrl) // Lấy URL từ mỗi ProductImage
                .collect(Collectors.toList());
    }

    default List<Long> mapCategoriesToIds(List<Category> categories) {
        if (CollectionUtils.isEmpty(categories)) {
            return Collections.emptyList();
        }
        return categories.stream()
                .map(Category::getId)
                .collect(Collectors.toList());
    }

}


/* ===== product-service\src\main\java\com\hau\product_service\mapper\RateMapper.java ===== */
package com.hau.product_service.mapper;

import com.hau.product_service.dto.request.RateRequest;
import com.hau.product_service.dto.response.RateResponse;
import com.hau.product_service.entity.Rate;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;


@Mapper(componentModel = "spring")
public interface RateMapper {

    @Mapping(target = "productId", source = "product.id")
    @Mapping(target = "userId", source = "user.id")
    RateResponse toRateResponse(Rate rate);

    @Mapping(target = "product", ignore = true)
    @Mapping(target = "user", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "id", ignore = true)
    Rate toRate(RateRequest request);

}


/* ===== product-service\src\main\java\com\hau\product_service\repository\CategoryRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    void deleteByParentId(Long id);

    List<Category> findByParentId(Long parentId);


}


/* ===== product-service\src\main\java\com\hau\product_service\repository\FileServiceClientRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.config.AuthenticationRequestInterceptor;
import com.hau.product_service.config.FeignMultipartSupportConfig;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.FileResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

@FeignClient(name = "file-service", url = "${app.file-service.url}",
        configuration = {AuthenticationRequestInterceptor.class, FeignMultipartSupportConfig.class})
public interface FileServiceClientRepository {
    @PostMapping(value = "/file/media", consumes = MediaType.MULTIPART_FORM_DATA_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    ApiResponse<FileResponse> uploadFile(@RequestPart("file") MultipartFile file);

    @DeleteMapping("/file/media/{fileName}")
    ApiResponse<FileResponse> deleteFile(@PathVariable String fileName);
}


/* ===== product-service\src\main\java\com\hau\product_service\repository\ProductImageRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.ProductImage;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface ProductImageRepository extends JpaRepository<ProductImage, Long> {
    void deleteByProductId(Long id);
    Optional<List<ProductImage>> findByProductId(Long productId);
}


/* ===== product-service\src\main\java\com\hau\product_service\repository\ProductRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.dto.request.ProductFilter;
import com.hau.product_service.entity.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Query("""
    SELECT DISTINCT p FROM Product p
    JOIN p.categories c
    WHERE (:#{#filter.title} IS NULL OR p.title ILIKE CONCAT('%', :#{#filter.title}, '%'))
      AND (:#{#filter.author} IS NULL OR p.author ILIKE CONCAT('%', :#{#filter.author}, '%'))
      AND (:#{#filter.priceFrom} IS NULL OR p.discount >= :#{#filter.priceFrom})
      AND (:#{#filter.priceTo} IS NULL OR p.discount <= :#{#filter.priceTo})
      AND (:categoryIds IS NULL OR c.id IN (:categoryIds))
      AND (:#{#filter.averageRateFrom} IS NULL OR p.averageRate >= :#{#filter.averageRateFrom})
""")
    Page<Product> findAllByFilter(@Param("filter") ProductFilter filter,
                                  @Param("categoryIds") List<Long> categoryIds,
                                  Pageable pageable);

    @Query("""
    SELECT DISTINCT p FROM Product p
    JOIN p.categories c
    WHERE (:#{#filter.title} IS NULL OR p.title ILIKE CONCAT('%', :#{#filter.title}, '%'))
      AND (:#{#filter.author} IS NULL OR p.author ILIKE CONCAT('%', :#{#filter.author}, '%'))
      AND (:#{#filter.priceFrom} IS NULL OR p.price >= :#{#filter.priceFrom})
      AND (:#{#filter.priceTo} IS NULL OR p.price <= :#{#filter.priceTo})
      AND (:categoryIds IS NULL OR c.id IN (:categoryIds))
      AND (:#{#filter.averageRateFrom} IS NULL OR p.averageRate >= :#{#filter.averageRateFrom})
      AND (p.active = :active OR :active IS NULL)
""")
    Page<Product> findAllByActiveStatus(@Param("filter") ProductFilter filter,
                                      @Param("categoryIds") List<Long> categoryIds,
                                      Pageable pageable, @Param("active") Boolean active);


    @Query("SELECT p FROM Product p WHERE p.active = true ORDER BY p.discountPercent DESC LIMIT 10 ")
    List<Product> getTopTenBestDiscountProduct();


    @Query("SELECT p FROM Product p WHERE p.active = true ORDER BY p.averageRate DESC LIMIT 10")
    List<Product> getTopTenBestAverageRateProduct();
}


/* ===== product-service\src\main\java\com\hau\product_service\repository\RateRepository.java ===== */
package com.hau.product_service.repository;


import com.hau.product_service.entity.Rate;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface RateRepository extends JpaRepository<Rate, Long> {
    Page<Rate> findAllByProductId(Long productId, Pageable pageable);
    List<Rate> findAllByProductId(Long productId);
}


/* ===== product-service\src\main\java\com\hau\product_service\repository\UserRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Integer> {
}


/* ===== product-service\src\main\java\com\hau\product_service\service\CategoryService.java ===== */
package com.hau.product_service.service;


import com.hau.product_service.dto.request.CategoryRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.product_service.entity.Category;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.mapper.CategoryMapper;
import com.hau.product_service.repository.CategoryRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
public class CategoryService {
    private final CategoryRepository categoryRepository;
    private final CategoryMapper categoryMapper;


    @Transactional
    public void handleCategoryCreated(CategoryRequest request) {
        Category category = categoryMapper.toCategory(request);
        Category savedCategory = categoryRepository.save(category);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    public void handleCategoryUpdated(Long id, CategoryRequest request) {
        Category existCategory = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));
        Category updatedCategory = categoryMapper.toCategoryUpdateFromRequest(request, existCategory);

        Category savedCategory = categoryRepository.save(updatedCategory);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    public void handleCategoryDeleted(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));

        categoryRepository.deleteByParentId(id);
        categoryRepository.delete(category);

        ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa danh mục thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public List<Category> handleCategoryFromProduct(List<Long> categoryIds) {
        Set<Long> uniqueCategoryIds = new HashSet<>(categoryIds);
        List<Category> categories = categoryRepository.findAllById(uniqueCategoryIds);
        if (categories.size() != uniqueCategoryIds.size()) {
            throw new AppException(
                    HttpStatus.NOT_FOUND,
                    "Không tìm thấy một số danh mục trong danh sách",
                    uniqueCategoryIds
            );
        }
        return categories;
    }

    public Set<Long> findAllSubCategoryIds(Long parentId) {
        Set<Long> result = new HashSet<>();
        List<Category> children = categoryRepository.findByParentId(parentId);
        for (Category child : children) {
            result.add(child.getId());
            result.addAll(findAllSubCategoryIds(child.getId()));
        }
        return result;
    }

    public ApiResponse<List<CategoryResponse>> getAllCategories() {
        List<Category> categories = categoryRepository.findAll();
        List<CategoryResponse> responses = categories.stream()
                .map(categoryMapper::toCategoryResponse)
                .toList();

        return ApiResponse.<List<CategoryResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách danh mục thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\service\FileUploadService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.exception.AppException;
import com.hau.product_service.repository.FileServiceClientRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

@RequiredArgsConstructor
@Service
public class FileUploadService {
    private final FileServiceClientRepository fileServiceClientRepository;

    String uploadFileAndGetUrl(MultipartFile file, String fileTypeDescription) {
        if (file == null || file.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "File " + fileTypeDescription + " không được để trống", null);
        }
        try {
            var fileResponse = fileServiceClientRepository.uploadFile(file);
            if (fileResponse != null && fileResponse.getResult() != null && fileResponse.getResult().getUrl() != null) {
                return fileResponse.getResult().getUrl(); // Return only the relative URL path
            } else {
                throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Không nhận được thông tin hợp lệ từ file-service cho " + fileTypeDescription, null);
            }
        } catch (Exception e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi tải lên file " + fileTypeDescription, e);
        }
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\service\ProductImageService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.ProductImage;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.repository.FileServiceClientRepository;
import com.hau.product_service.repository.ProductImageRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@Service
@RequiredArgsConstructor
public class ProductImageService {
    private final ProductImageRepository productImageRepository;
    private final FileUploadService fileUploadService;
    private final FileServiceClientRepository fileServiceClient;

    @Transactional
    public void deleteAllByProductId(Long productId) {
        deleteImage(productId);
        productImageRepository.deleteByProductId(productId);
    }

    @Transactional
    public void createImageByProduct(Product product, List<MultipartFile> images) {
            if(images != null && !images.isEmpty()) {
                for (MultipartFile imageFile : images) {
                    if (imageFile != null && !imageFile.isEmpty()) {
                        try {
                            String imageUrl = fileUploadService.uploadFileAndGetUrl(imageFile, "product image");

                            ProductImage productImage = new ProductImage();
                            productImage.setProduct(product);
                            productImage.setUrl(imageUrl);

                            productImageRepository.save(productImage);
                        } catch (Exception e) {
                            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi tải lên hình ảnh sản phẩm: " + imageFile.getOriginalFilename(), e);
                        }
                    }
                }
            }
    }

    @Transactional
    public void deleteImage(Long productId) {
        List<ProductImage> productImage = productImageRepository.findByProductId(productId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy ảnh sản phẩm", null));

        try {
            for (ProductImage item : productImage) {
                fileServiceClient.deleteFile(item.getUrl());
            };
        } catch (Exception e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi xóa ảnh sản phẩm", e);
        }
    }

}


/* ===== product-service\src\main\java\com\hau\product_service\service\ProductService.java ===== */
package com.hau.product_service.service;

import com.hau.event.dto.NotificationEvent;
import com.hau.event.dto.ProductEvent;
import com.hau.product_service.entity.Category;
import com.hau.product_service.repository.FileServiceClientRepository;
import com.hau.product_service.converter.StringConverter;
import com.hau.product_service.dto.request.ProductFilter;
import com.hau.product_service.dto.request.ProductRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResponse;
import com.hau.product_service.dto.response.ProductResponse;
import com.hau.product_service.entity.Product;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.mapper.ProductMapper;
import com.hau.product_service.repository.ProductRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.web.multipart.MultipartFile;


import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ProductService {
    private final ProductRepository productRepository;
    private final ProductMapper productMapper;
    private final FileServiceClientRepository fileServiceClientRepository;
    private final ProductImageService productImageService;
    private final FileUploadService fileUploadService;
    private final SlugService slugService;
    private final CategoryService categoryService;
    private final KafkaTemplate<String, Object> kafkaTemplate;


    @Value("${app.file.download-prefix}")
    private String fileServiceUrl;

    public ApiResponse<PageResponse<ProductResponse>> getAllProduct(ProductFilter filter, Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;

        Sort sort;
        if (filter.getSortDir() != null && !filter.getSortDir().isEmpty()) {
            Sort.Direction direction = "asc".equalsIgnoreCase(filter.getSortDir()) ? Sort.Direction.ASC : Sort.Direction.DESC;
            sort = Sort.by(direction, "discount");
        } else {
            sort = Sort.by(Sort.Direction.DESC, "createdAt");
        }

        Pageable pageable = PageRequest.of(page, pageSize, sort);

        List<Long> categoryIds = null;
        if (filter.getCategoryId() != null) {
            Set<Long> allCategoryIds = new HashSet<>();
            allCategoryIds.add(filter.getCategoryId());
            allCategoryIds.addAll(categoryService.findAllSubCategoryIds(filter.getCategoryId()));
            categoryIds = allCategoryIds.stream().toList();
        }

        Page<Product> productPage = productRepository.findAllByFilter(filter, categoryIds, pageable);

        List<ProductResponse> responses = productPage.getContent().stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();

        PageResponse<ProductResponse> result = PageResponse.<ProductResponse>builder()
                .data(responses)
                .currentPage(productPage.getNumber() + 1)
                .pageSize(productPage.getSize())
                .totalPages(productPage.getTotalPages())
                .totalElements(productPage.getTotalElements())
                .build();

        return ApiResponse.<PageResponse<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm thành công")
                .result(result)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<PageResponse<ProductResponse>> getAllProductByActive(ProductFilter filter, Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;

        Sort sort;
        if (filter.getSortDir() != null && !filter.getSortDir().isEmpty()) {
            Sort.Direction direction = "asc".equalsIgnoreCase(filter.getSortDir()) ? Sort.Direction.ASC : Sort.Direction.DESC;
            sort = Sort.by(direction, "discount");
        } else {
            sort = Sort.by(Sort.Direction.DESC, "createdAt");
        }

        Pageable pageable = PageRequest.of(page, pageSize, sort);

        List<Long> categoryIds = null;
        if (filter.getCategoryId() != null) {
            Set<Long> allCategoryIds = new HashSet<>();
            allCategoryIds.add(filter.getCategoryId());
            allCategoryIds.addAll(categoryService.findAllSubCategoryIds(filter.getCategoryId()));
            categoryIds = allCategoryIds.stream().toList();
        }

        // Explicitly search for active=true products
        Page<Product> productPage = productRepository.findAllByActiveStatus(filter, categoryIds, pageable, Boolean.TRUE);

        List<ProductResponse> responses = productPage.getContent().stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();

        PageResponse<ProductResponse> result = PageResponse.<ProductResponse>builder()
                .data(responses)
                .currentPage(productPage.getNumber() + 1)
                .pageSize(productPage.getSize())
                .totalPages(productPage.getTotalPages())
                .totalElements(productPage.getTotalElements())
                .build();

        return ApiResponse.<PageResponse<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm đang hoạt động thành công")
                .result(result)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<ProductResponse>> getTopTenProductByBestDiscountPercent() {
        List<Product> products = productRepository.getTopTenBestDiscountProduct();
        List<ProductResponse> responses = products.stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();
        return ApiResponse.<List<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<ProductResponse>> getTopTenProductByAverageRate() {
        List<Product> products = productRepository.getTopTenBestAverageRateProduct();
        List<ProductResponse> responses = products.stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();
        return ApiResponse.<List<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional // Ensure atomicity
    public ApiResponse<ProductResponse> createProduct(ProductRequest request, MultipartFile thumbnail, List<MultipartFile> images) {
        if (thumbnail == null || thumbnail.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Ảnh thumbnail không được để trống", null);
        }

        if (images == null || images.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Danh sách ảnh sản phẩm không được để trống", null);
        }

        List<Category> categories = categoryService.handleCategoryFromProduct(request.getCategoryIds());

        Product product = productMapper.toProduct(request);
        product.setActive(true);
        product.setCategories(categories);

        product.setDiscountPercent(calculateProductDiscountPercent(product.getPrice(), product.getDiscount()));
        product.setAverageRate(0.0f);
        String thumbnailUrl = fileUploadService.uploadFileAndGetUrl(thumbnail, "thumbnail");
        product.setThumbnail(thumbnailUrl);

        product.setSlug(StringConverter.toSlug(product.getTitle()));

        Product savedProduct = productRepository.save(product);
        Long productId = savedProduct.getId();

        String uniqueSlug = slugService.generateUniqueSlug(savedProduct.getTitle(), productId);
        savedProduct.setSlug(uniqueSlug);

        productImageService.createImageByProduct(savedProduct, images);

        savedProduct.setProductImage(null);
        savedProduct = productRepository.save(savedProduct);

        ProductEvent productEvent = ProductEvent.builder()
                .id(savedProduct.getId())
                .discount(savedProduct.getDiscount())
                .price(savedProduct.getPrice())
                .quantity(savedProduct.getQuantity())
                .title(savedProduct.getTitle())
                .build();
        kafkaTemplate.send("product-create-topic", productEvent);
        ProductResponse productResponse = productMapper.toProductResponse(savedProduct);
        productResponse.setThumbnail(fileServiceUrl + savedProduct.getThumbnail());

        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Thêm sản phẩm thành công")
                .result(productResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }


    // Modified to handle thumbnail and image updates
    @Transactional
    public ApiResponse<ProductResponse> updateProduct(ProductRequest request, Long id, MultipartFile thumbnail, List<MultipartFile> images) {
        Product existProduct = productRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));

        Product product = productMapper.updateProductFromRequest(request, existProduct);

        List<Category> categories = categoryService.handleCategoryFromProduct(request.getCategoryIds());

        if (request.getActive() != null) {
            existProduct.setActive(request.getActive());
        }

        if (thumbnail != null && !thumbnail.isEmpty()) {
            fileServiceClientRepository.deleteFile(existProduct.getThumbnail());
            String newThumbnailUrl = fileUploadService.uploadFileAndGetUrl(thumbnail, "new thumbnail");
            existProduct.setThumbnail(newThumbnailUrl);
        }

        if (!CollectionUtils.isEmpty(images)) {
            productImageService.deleteAllByProductId(id);
            productImageService.createImageByProduct(product, images);
        }

        existProduct.setDiscountPercent(calculateProductDiscountPercent(product.getPrice(), product.getDiscount()));
        existProduct.setSlug(slugService.generateUniqueSlug(product.getTitle(), id));
        existProduct.setCategories(categories);
        Product savedProduct = productRepository.save(existProduct);

        ProductEvent productEvent = ProductEvent.builder()
                .id(savedProduct.getId())
                .discount(savedProduct.getDiscount())
                .price(savedProduct.getPrice())
                .quantity(savedProduct.getQuantity())
                .title(savedProduct.getTitle())
                .build();
        kafkaTemplate.send("product-update-topic", productEvent);

        ProductResponse response = productMapper.toProductResponse(savedProduct);
        response.setThumbnail(savedProduct.getThumbnail());


        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật sản phẩm thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }


    @Transactional
    public ApiResponse<ProductResponse> updateProductStatus(Long id, Boolean active) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));

        product.setActive(active);
        productRepository.save(product);

        ProductEvent productEvent = ProductEvent.builder()
                .id(product.getId())
                .discount(product.getDiscount())
                .price(product.getPrice())
                .quantity(product.getQuantity())
                .title(product.getTitle())
                .build();
        kafkaTemplate.send("product-update-topic", productEvent);

        ProductResponse response = productMapper.toProductResponse(product);
        response.setThumbnail(fileServiceUrl + product.getThumbnail());

        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật trạng thái sản phẩm thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<ProductResponse> deleteProduct(Long id) {
        Product product =  productRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));

        productImageService.deleteImage(product.getId());
        fileServiceClientRepository.deleteFile(product.getThumbnail());
        productRepository.deleteById(id);
        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa sản phẩm thành công")
                .timestamp(LocalDateTime.now())
                .build();
    }



    public ApiResponse<ProductResponse> getProductById(Long productId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));
        ProductResponse response = productMapper.toProductWithImageResponse(product);
        response.setThumbnail(fileServiceUrl + product.getThumbnail());
        List<String> imageUrls = response.getImageUrls();
        for(String item : imageUrls) {
            imageUrls.set(imageUrls.indexOf(item), fileServiceUrl + item);
        }
        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy sản phẩm thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }


    public void updateProductQuantity(NotificationEvent notificationEvent) {
        Map<String, Object> params = notificationEvent.getParams();
        Object orderProducts = params.get("orderProducts");

        if (orderProducts instanceof List<?> orderProductList) {
            for (Object item : orderProductList) {
                if (item instanceof Map<?, ?> productMap) {
                    log.info("Product map: {}", productMap);

                    Object productIdObj = productMap.get("productId");
                    if (!(productIdObj instanceof Integer)) {
                        log.error("productId không phải là Integer.  Value: {}", productIdObj);
                        continue;
                    }
                    Long productId = ((Integer) productIdObj).longValue();


                    Object quantityObj = productMap.get("quantity");
                    if (!(quantityObj instanceof Integer)) {
                        log.error("quantity không phải là Integer. Value: {}", quantityObj);
                        continue;
                    }
                    int quantity = (Integer) quantityObj;


                    try {
                        Product product = productRepository.findById(productId)
                                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));
                        product.setQuantity(product.getQuantity() - quantity);
                        productRepository.save(product);
                    } catch (AppException e) {
                        log.error("Lỗi khi xử lý sản phẩm với productId {}: {}", productId, e.getMessage());
                    }
                }
            }
        } else {
            log.warn("orderProducts không phải là List hoặc null");
        }
    }

    public Double calculateProductDiscountPercent(Integer price, Integer discount) {
        if (price == null || discount == null || price <= 0) {
            return 0.0;
        }
        return 100 - ((double) discount / price) * 100;
    }
}


/* ===== product-service\src\main\java\com\hau\product_service\service\RateService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.dto.request.RateRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResponse;
import com.hau.product_service.dto.response.RateResponse;
import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.Rate;
import com.hau.product_service.entity.User;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.mapper.RateMapper;
import com.hau.product_service.repository.ProductRepository;
import com.hau.product_service.repository.RateRepository;
import com.hau.product_service.repository.UserRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class RateService {
    private final RateRepository rateRepository;
    private final RateMapper rateMapper;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;

    public ApiResponse<PageResponse<RateResponse>> getAllRate(Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;
        Pageable pageable = PageRequest.of(page, pageSize);

        Page<Rate> rates = rateRepository.findAll(pageable);

        List<RateResponse> rateResponses = rates.getContent().stream()
                .map(rateMapper::toRateResponse)
                .toList();

        PageResponse<RateResponse> result = PageResponse.<RateResponse>builder()
                .data(rateResponses)
                .currentPage(rates.getNumber() + 1)
                .pageSize(rates.getSize())
                .totalPages(rates.getTotalPages())
                .totalElements(rates.getTotalElements())
                .build();


        return ApiResponse.<PageResponse<RateResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Get all rates successfully")
                .result(result)
                .build();
    }

    public ApiResponse<RateResponse> getRateById(Long id) {
        Rate rate = rateRepository.findById(id).orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy đánh giá ", "id = " + id));
        RateResponse rateResponse = rateMapper.toRateResponse(rate);
        return ApiResponse.<RateResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy đánh giá thành công")
                .result(rateResponse)
                .build();
    }

    public ApiResponse<PageResponse<RateResponse>> getRateByProductId(Long productId, Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;
        Pageable pageable = PageRequest.of(page, pageSize);

        Page<Rate> rates = rateRepository.findAllByProductId(productId, pageable);

        List<RateResponse> rateResponses = rates.getContent().stream()
                .map(rateMapper::toRateResponse)
                .toList();

        PageResponse<RateResponse> result = PageResponse.<RateResponse>builder()
                .data(rateResponses)
                .currentPage(rates.getNumber() + 1)
                .pageSize(rates.getSize())
                .totalPages(rates.getTotalPages())
                .totalElements(rates.getTotalElements())
                .build();

        return ApiResponse.<PageResponse<RateResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy đánh giá thành công")
                .result(result)
                .build();
    }

    @Transactional
    public ApiResponse<RateResponse> createRate(RateRequest request) {
        Product product = productRepository.findById(request.getProductId())
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy sản phẩm", "id = " + request.getProductId()));
        Integer userId = Integer.valueOf(SecurityContextHolder.getContext().getAuthentication().getName());
        User user =  userRepository.findById(userId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy người dùng", "id = " + userId));
        Rate newRate = rateMapper.toRate(request);

        newRate.setProduct(product);
        newRate.setUser(user);
        Rate savedRate = rateRepository.save(newRate);
        Float averageRate = calculateAverageRate(newRate.getProduct().getId());
        product.setAverageRate(averageRate);
        productRepository.save(product);

        RateResponse rateResponse = rateMapper.toRateResponse(savedRate);

        return ApiResponse.<RateResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo đánh giá thành công")
                .result(rateResponse)
                .build();
    }

    @Transactional
    public ApiResponse<RateResponse> removeRate(Long id) {
        Rate rate = rateRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy đánh giá", "id = " + id));
        rateRepository.delete(rate);
        Product product = rate.getProduct();
        Float averageRate = calculateAverageRate(product.getId());
        product.setAverageRate(averageRate);
        productRepository.save(product);
        return ApiResponse.<RateResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa đánh giá thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public Float calculateAverageRate(Long productId) {
        List<Rate> rates = rateRepository.findAllByProductId(productId);

        float totalRate = 0f;
        for (Rate rate : rates) {
            totalRate += rate.getVote();
        }
        return Float.valueOf(String.format("%.1f", totalRate / rates.size())) ;
    }

}


/* ===== product-service\src\main\java\com\hau\product_service\service\SlugService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.converter.StringConverter;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class SlugService {
    String generateUniqueSlug(String title, Long productId) {
        String baseSlug = StringConverter.toSlug(title);
        return baseSlug + "-" + productId;
    }

}


/* ===== product-service\src\main\java\com\hau\product_service\service\event\CategoryEventConsumer.java ===== */
package com.hau.product_service.service.event;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hau.product_service.dto.request.CategoryRequest;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.event.dto.CategoryEvent;
import com.hau.product_service.service.CategoryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class CategoryEventConsumer {

    private static final String TOPIC_CATEGORY_PRODUCT_EVENT = "category-product-event";
    private final CategoryService categoryService;
    private final ObjectMapper objectMapper; // Inject ObjectMapper

    @KafkaListener(topics = TOPIC_CATEGORY_PRODUCT_EVENT)
    public void listen(CategoryEvent event) {
        log.info("Received Category Event: {}", event);

        try {
            switch (event.getType()) {
                case "CATEGORY_CREATED":
                    log.info("Handling Category Created event for ID: {}", event.getCategoryId());
                    if (event.getData() != null) {
                        CategoryResponse createdCategory = objectMapper.convertValue(event.getData(), CategoryResponse.class); // Sử dụng convertValue
                        CategoryRequest categoryRequest = convertToCategoryRequest(createdCategory);
                        categoryService.handleCategoryCreated(categoryRequest);
                    } else {
                        log.warn("Category Created event received with no data for ID: {}", event.getCategoryId());
                    }
                    break;

                case "CATEGORY_UPDATED":
                    log.info("Handling Category Updated event for ID: {}", event.getCategoryId());
                    if (event.getData() != null) {
                        CategoryResponse updatedCategory = objectMapper.convertValue(event.getData(), CategoryResponse.class); // Sử dụng convertValue
                        CategoryRequest updatedCategoryRequest = convertToCategoryRequest(updatedCategory);
                        categoryService.handleCategoryUpdated(updatedCategory.getId() ,updatedCategoryRequest);
                    } else {
                        log.warn("Category Updated event received with no data for ID: {}", event.getCategoryId());
                    }
                    break;

                case "CATEGORY_DELETED":
                    log.info("Handling Category Deleted event for ID: {}", event.getCategoryId());
                    categoryService.handleCategoryDeleted(event.getCategoryId());
                    break;

                default:
                    log.warn("Received unknown Category Event type: {}", event.getType());
            }

            if (event.getCategoryId() != null) { // Kiểm tra null cho categoryId trước khi log
                log.info("Successfully processed Category Event for ID: {}", event.getCategoryId());
            } else {
                log.info("Successfully processed Category Event (ID not provided in event)");
            }


        } catch (Exception e) {
            String eventIdLog = (event != null && event.getCategoryId() != null) ? event.getCategoryId().toString() : "N/A";
            log.error("Error processing Category Event for ID {}: {}", eventIdLog, e.getMessage(), e);
        }
    }


    private CategoryRequest convertToCategoryRequest(CategoryResponse category) {
        if (category == null) {
            return null;
        }
        CategoryRequest categoryRequest = new CategoryRequest();
        categoryRequest.setId(category.getId());
        categoryRequest.setName(category.getName());
        categoryRequest.setSlug(category.getSlug());
        categoryRequest.setParentId(category.getParentId());
        return categoryRequest;
    }
}

/* ===== product-service\src\main\java\com\hau\product_service\service\event\UserEventConsumer.java ===== */
package com.hau.product_service.service.event;

import com.hau.event.dto.UserCreateEvent;
import com.hau.product_service.entity.User;
import com.hau.product_service.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserEventConsumer {
    private final UserRepository userRepository;

    @KafkaListener(topics = "user-created-topic")
    public void handleUserCreateEvent(UserCreateEvent userCreateEvent) {
        log.info("Received user create event: {}", userCreateEvent);

        Optional<User> existingUser = userRepository.findById(userCreateEvent.getId());

        if (existingUser.isPresent()) {
            log.warn("User with id {} already exists. Skipping creation for this event.", userCreateEvent.getId());
        } else {
            User newUser = User.builder()
                    .id(userCreateEvent.getId())
                    .username(userCreateEvent.getUsername())
                    .build();
            try {
                userRepository.save(newUser); // Let JPA manage the ID and version
                log.info("Successfully created user with id {}", newUser.getId()); // Log the newly generated ID
            } catch (Exception e) {
                log.error("Failed to save user with id {}. Error: {}", userCreateEvent.getId(), e.getMessage(), e);
                throw new RuntimeException("Failed to save user", e);
            }
        }
    }
}

/* ===== product-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8082
  servlet:
    context-path: /product

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/product_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 5MB

  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: product-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"

app:
  file-service:
    url: http://localhost:8087
  file:
    download-prefix: http://localhost:8888/api/v1/file/media/download/


/* ===== product-service\src\main\resources\application.yml ===== */
server:
  port: 8082
  servlet:
    context-path: /product

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/product_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 5MB

  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: product-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"

app:
  file-service:
    url: http://localhost:8087
  file:
    download-prefix: http://localhost:8888/api/v1/file/media/download/


/* ===== product-service\src\test\java\com\hau\product_service\ProductServiceApplicationTests.java ===== */
package com.hau.product_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ProductServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


/* ===== profile-service\src\main\java\com\hau\event\dto\ProfileCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProfileCreateEvent {
    private Long id;
    private Integer userId;
    private String fullName;
    private String phone;
    private String address;
}


/* ===== profile-service\src\main\java\com\hau\profile_service\ProfileServiceApplication.java ===== */
package com.hau.profile_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProfileServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProfileServiceApplication.class, args);
    }

}


/* ===== profile-service\src\main\java\com\hau\profile_service\config\CustomJwtDecoder.java ===== */
package com.hau.profile_service.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== profile-service\src\main\java\com\hau\profile_service\config\JwtAuthenticationEntryPoint.java ===== */
package com.hau.profile_service.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.profile_service.dto.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== profile-service\src\main\java\com\hau\profile_service\config\SecurityConfig.java ===== */
package com.hau.profile_service.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {

    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== profile-service\src\main\java\com\hau\profile_service\controller\ProfileController.java ===== */
package com.hau.profile_service.controller;

import com.hau.profile_service.dto.*;
import com.hau.profile_service.service.ProfileService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
public class ProfileController {
    private final ProfileService profileService;


    @PostMapping
    public ResponseEntity<ApiResponse<ProfileResponse>> createProfile(@Valid @RequestBody ProfileCreateRequest profileCreateRequest) {
        ApiResponse<ProfileResponse> response = profileService.createProfile(profileCreateRequest);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @GetMapping("/my-profile")
    public ResponseEntity<ApiResponse<PageResponse<ProfileResponse>>> getMyProfile
            (@RequestParam(required = false, defaultValue = "1") int pageIndex,
             @RequestParam(required = false, defaultValue = "10") int pageSize) {
        ApiResponse<PageResponse<ProfileResponse>> response = profileService.getMyProfile(pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PreAuthorize("@profileService.isOwnerOfProfile(#profileId, authentication)")
    @PutMapping("/{profileId}")
    public ResponseEntity<ApiResponse<ProfileResponse>> updateProfile(@PathVariable Long profileId, @Valid @RequestBody ProfileUpdateRequest profileUpdateRequest) {
        ApiResponse<ProfileResponse> response = profileService.updateProfile(profileId, profileUpdateRequest);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PreAuthorize("@profileService.isOwnerOfProfile(#profileId, authentication)")
    @GetMapping("/{profileId}")
    public ResponseEntity<ApiResponse<ProfileResponse>> getProfileById(@PathVariable Long profileId) {
        ApiResponse<ProfileResponse> response = profileService.getProfileById(profileId);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PreAuthorize("@profileService.isOwnerOfProfile(#profileId, authentication)")
    @DeleteMapping("/{profileId}")
    public ResponseEntity<ApiResponse<String>> deleteProfile(@PathVariable Long profileId) {
        ApiResponse<String> response = profileService.deleteProfile(profileId);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }
}


/* ===== profile-service\src\main\java\com\hau\profile_service\dto\ApiResponse.java ===== */
package com.hau.profile_service.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== profile-service\src\main\java\com\hau\profile_service\dto\CustomUserDetails.java ===== */
package com.hau.profile_service.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CustomUserDetails {
    private Long userId;
    private String username;
}


/* ===== profile-service\src\main\java\com\hau\profile_service\dto\ErrorsResponse.java ===== */
package com.hau.profile_service.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    int status;
    String message;
    Object error;
    LocalDateTime timestamp;
}


/* ===== profile-service\src\main\java\com\hau\profile_service\dto\PageResponse.java ===== */
package com.hau.profile_service.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}


/* ===== profile-service\src\main\java\com\hau\profile_service\dto\ProfileCreateRequest.java ===== */
package com.hau.profile_service.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProfileCreateRequest {
    @NotBlank(message = "Họ tên không được để trống")
    private String fullName;
    @Pattern(regexp = "^[0-9]{10}$", message = "Số điện thoại không hợp lệ")
    private String phone;
    @NotBlank(message = "Địa chỉ không được để trống")
    private String address;
    @Pattern(regexp = "(?i)^(MALE|FEMALE)$", message = "Giá trị gender phải là 'MALE' hoặc 'FEMALE' (không phân biệt chữ hoa chữ thường)")
    private String gender;
}


/* ===== profile-service\src\main\java\com\hau\profile_service\dto\ProfileResponse.java ===== */
package com.hau.profile_service.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProfileResponse {
    private Long id;

    private String fullName;
    private String phone;
    private String address;
    private String gender;
}


/* ===== profile-service\src\main\java\com\hau\profile_service\dto\ProfileUpdateRequest.java ===== */
package com.hau.profile_service.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProfileUpdateRequest {
    @NotBlank(message = "Họ tên không được để trống")
    private String fullName;
    @Pattern(regexp = "^[0-9]{10}$", message = "Số điện thoại không hợp lệ")
    private String phone;
    @NotBlank(message = "Địa chỉ không được để trống")
    private String address;
    @Pattern(regexp = "(?i)^(MALE|FEMALE)$", message = "Giá trị gender phải là 'MALE' hoặc 'FEMALE' (không phân biệt chữ hoa chữ thường)")
    private String gender;
}


/* ===== profile-service\src\main\java\com\hau\profile_service\entity\Profile.java ===== */
package com.hau.profile_service.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "profiles")
public class Profile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String fullName;
    private String phone;
    private String address;
    @Enumerated(EnumType.STRING)
    private Gender gender;
    private Integer userId;

    public enum Gender {
        MALE, FEMALE
    }
}


/* ===== profile-service\src\main\java\com\hau\profile_service\exception\AppException.java ===== */
package com.hau.profile_service.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== profile-service\src\main\java\com\hau\profile_service\exception\GlobalExceptionHandler.java ===== */
package com.hau.profile_service.exception;

import com.hau.profile_service.dto.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions(Exception e) {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", e, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== profile-service\src\main\java\com\hau\profile_service\mapper\ProfileMapper.java ===== */
package com.hau.profile_service.mapper;

import com.hau.profile_service.dto.ProfileCreateRequest;
import com.hau.profile_service.dto.ProfileResponse;
import com.hau.profile_service.dto.ProfileUpdateRequest;
import com.hau.profile_service.entity.Profile;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface ProfileMapper {
    Profile toUserProfile(ProfileCreateRequest profileCreateRequest);

    void updateUserProfile(@MappingTarget Profile profile, ProfileUpdateRequest profileUpdateRequest);

    ProfileResponse toUserProfileResponse(Profile profile);
}


/* ===== profile-service\src\main\java\com\hau\profile_service\repository\ProfileRepository.java ===== */
package com.hau.profile_service.repository;

import com.hau.profile_service.entity.Profile;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ProfileRepository extends JpaRepository<Profile, Long> {
    Page<Profile> findByUserId(Integer userId,
                               Pageable pageable);
}


/* ===== profile-service\src\main\java\com\hau\profile_service\service\ProfileService.java ===== */
package com.hau.profile_service.service;

import com.hau.event.dto.ProfileCreateEvent;
import com.hau.profile_service.dto.*;
import com.hau.profile_service.entity.Profile;
import com.hau.profile_service.exception.AppException;
import com.hau.profile_service.mapper.ProfileMapper;
import com.hau.profile_service.repository.ProfileRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
@Slf4j
public class ProfileService {
    private final ProfileRepository profileRepository;
    private final ProfileMapper profileMapper;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    public ApiResponse<ProfileResponse> createProfile(ProfileCreateRequest profileCreateRequest) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();

        Profile profile = profileMapper.toUserProfile(profileCreateRequest);

        if (authentication != null && authentication.isAuthenticated()) {
            String authenticatedUserId = authentication.getName();
            profile.setUserId(Integer.valueOf(authenticatedUserId));
        }

        profileRepository.save(profile);
        ProfileCreateEvent profileCreateEvent = ProfileCreateEvent.builder()
                .id(profile.getId())
                .userId(profile.getUserId())
                .fullName(profile.getFullName())
                .phone(profile.getPhone())
                .address(profile.getAddress())
                .build();
        log.info("Gửi sự kiện đến Kafka: {}", profileCreateEvent);
        kafkaTemplate.send("profile-create-event", profileCreateEvent);
        return ApiResponse.<ProfileResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Thêm thông tin người nhận hàng thành công")
                .result(profileMapper.toUserProfileResponse(profile))
                .timestamp(LocalDateTime.now())
                .build();
    }


    public ApiResponse<ProfileResponse> getProfileById(Long profileId) {
        Profile profile = findProfileById(profileId);
        return ApiResponse.<ProfileResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin thành công")
                .result(profileMapper.toUserProfileResponse(profile))
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<ProfileResponse> updateProfile(Long userId, ProfileUpdateRequest profileUpdateRequest) {
        Profile profile = findProfileById(userId);
        profileMapper.updateUserProfile(profile, profileUpdateRequest);
        profileRepository.save(profile);

        return ApiResponse.<ProfileResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật thông tin thành công")
                .result(profileMapper.toUserProfileResponse(profile))
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<String> deleteProfile(Long profileId) {
        Profile profile = findProfileById(profileId);
        profileRepository.delete(profile);

        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa thông tin thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<PageResponse<ProfileResponse>> getMyProfile(int pageIndex, int pageSize) {
        Sort sort = Sort.by(Sort.Direction.DESC, "id");
        Pageable pageable = PageRequest.of(pageIndex - 1, pageSize, sort);
        var authentication = SecurityContextHolder.getContext().getAuthentication();

        Integer authenticatedUserId = Integer.valueOf(authentication.getName());
        Page<Profile> profiles = profileRepository.findByUserId(authenticatedUserId, pageable);

        return ApiResponse.<PageResponse<ProfileResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách thông tin thành công")
                .result(PageResponse.<ProfileResponse>builder()
                        .currentPage(pageIndex)
                        .totalPages(profiles.getTotalPages())
                        .totalElements(profiles.getTotalElements())
                        .pageSize(profiles.getSize())
                        .data(profiles.map(profileMapper::toUserProfileResponse).getContent())
                        .build())
                .timestamp(LocalDateTime.now())
                .build();

    }

    public boolean isOwnerOfProfile(Long profileId, Authentication authentication) {
        if (authentication == null || !authentication.isAuthenticated()) {
            return false;
        }
        String authenticatedUserId = authentication.getName();

        try {
            Profile profile = findProfileById(profileId);
            return profile.getUserId().toString().equals(authenticatedUserId);
        } catch (AppException e) {
            log.warn("Không tìm thấy người dùng với ID: {}", authenticatedUserId);
            return false;
        }

    }

    public Profile findProfileById(Long profileId) {
        return profileRepository.findById(profileId)
                .orElseThrow(() -> new AppException(
                        HttpStatus.NOT_FOUND, "Không tìm thấy thông tin người nhận hàng có id: " + profileId, null)
                );
    }

}


/* ===== profile-service\src\main\resources\application-sample.yml ===== */
server:
  port: 8081
  servlet:
    context-path: /profile
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/profile_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

/* ===== profile-service\src\main\resources\application.yml ===== */
server:
  port: 8081
  servlet:
    context-path: /profile
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/profile_db
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  kafka:
    bootstrap-servers: localhost:9094
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

/* ===== profile-service\src\test\java\com\hau\profile_service\ProfileServiceApplicationTests.java ===== */
package com.hau.profile_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ProfileServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}



/* ===== IGNORED FILES & DIRECTORIES ===== */
/* The following items were excluded based on ignore rules */

/* .gitignore patterns: */
/*   .codebase */

/* .watchignore patterns: */
/*   **/.mvn */
/*   **/target */
/*   **/pom.xml */
/*   **/mvnw */
/*   **/mvnw.cmd */
/*   **/.gitattributes */
/*   **/.gitignore */
/*   .idea/ */
/*   .vscode/ */

/* Ignored items list: */
/* Ignored directories: */
/*   .codebase/ */
/*   api-gateway\.mvn/ */
/*   api-gateway\target/ */
/*   blog-service\.mvn/ */
/*   blog-service\target/ */
/*   cart-service\.mvn/ */
/*   cart-service\target/ */
/*   category-service\.mvn/ */
/*   category-service\target/ */
/*   customer-service\target/ */
/*   file-service\.mvn/ */
/*   file-service\target/ */
/*   identity-service\.codebase/ */
/*   identity-service\.mvn/ */
/*   identity-service\target/ */
/*   notification-service\.codebase/ */
/*   notification-service\.mvn/ */
/*   notification-service\target/ */
/*   order-service\.mvn/ */
/*   order-service\target/ */
/*   payment-service\.mvn/ */
/*   payment-service\target/ */
/*   product-service\.mvn/ */
/*   product-service\target/ */
/*   profile-service\.mvn/ */
/*   profile-service\target/ */

/* Ignored files: */
/*   .gitignore */
/*   .idea\.gitignore */
/*   .idea\compiler.xml */
/*   .idea\encodings.xml */
/*   .idea\jarRepositories.xml */
/*   .idea\microservice.iml */
/*   .idea\misc.xml */
/*   .idea\modules.xml */
/*   .idea\vcs.xml */
/*   .idea\workspace.xml */
/*   api-gateway\.gitattributes */
/*   api-gateway\.gitignore */
/*   api-gateway\mvnw */
/*   api-gateway\mvnw.cmd */
/*   api-gateway\pom.xml */
/*   blog-service\.gitattributes */
/*   blog-service\.gitignore */
/*   blog-service\mvnw */
/*   blog-service\mvnw.cmd */
/*   blog-service\pom.xml */
/*   cart-service\.gitattributes */
/*   cart-service\.gitignore */
/*   cart-service\mvnw */
/*   cart-service\mvnw.cmd */
/*   cart-service\pom.xml */
/*   category-service\.gitattributes */
/*   category-service\.gitignore */
/*   category-service\mvnw */
/*   category-service\mvnw.cmd */
/*   category-service\pom.xml */
/*   customer-service\.gitattributes */
/*   customer-service\.gitignore */
/*   customer-service\pom.xml */
/*   file-service\.gitattributes */
/*   file-service\.gitignore */
/*   file-service\mvnw */
/*   file-service\mvnw.cmd */
/*   file-service\pom.xml */
/*   identity-service\.gitattributes */
/*   identity-service\.gitignore */
/*   identity-service\mvnw */
/*   identity-service\mvnw.cmd */
/*   identity-service\pom.xml */
/*   notification-service\.gitattributes */
/*   notification-service\.gitignore */
/*   notification-service\mvnw */
/*   notification-service\mvnw.cmd */
/*   notification-service\pom.xml */
/*   order-service\.gitattributes */
/*   order-service\.gitignore */
/*   order-service\mvnw */
/*   order-service\mvnw.cmd */
/*   order-service\pom.xml */
/*   payment-service\.gitattributes */
/*   payment-service\.gitignore */
/*   payment-service\mvnw */
/*   payment-service\mvnw.cmd */
/*   payment-service\pom.xml */
/*   product-service\.gitattributes */
/*   product-service\.gitignore */
/*   product-service\mvnw */
/*   product-service\mvnw.cmd */
/*   product-service\pom.xml */
/*   profile-service\.gitattributes */
/*   profile-service\.gitignore */
/*   profile-service\mvnw */
/*   profile-service\mvnw.cmd */
/*   profile-service\pom.xml */
