/* ==========================================================
   CODEBASE SNAPSHOT - 2025-06-05 20:10:52
   Project: book_store_mobile
   Files: 77 (73 text, 4 binary)
   Ignored Items: 738
   ========================================================== */

/* PROJECT STRUCTURE
   ------------------------------------------------------------
   .
   ├── .expo/
   │   ├── types/
   │   ├── web/
   │   ├── devices.json
   │   └── README.md
   ├── .git/
   │   ├── hooks/
   │   ├── info/
   │   ├── logs/
   │   ├── objects/
   │   ├── refs/
   │   ├── COMMIT_EDITMSG
   │   ├── config
   │   ├── description
   │   ├── HEAD
   │   └── index
   ├── .idea/
   │   ├── caches/
   │   ├── inspectionProfiles/
   │   ├── .gitignore
   │   ├── book_store_mobile.iml
   │   ├── modules.xml
   │   ├── vcs.xml
   │   └── workspace.xml
   ├── .vscode/
   │   └── settings.json
   ├── node_modules/
   │   ├── .bin/
   │   ├── @0no-co/
   │   ├── @alloc/
   │   ├── @ampproject/
   │   ├── @babel/
   │   ├── @egjs/
   │   ├── @emnapi/
   │   ├── @eslint/
   │   ├── @eslint-community/
   │   ├── @expo/
   │   ├── @faker-js/
   │   ├── @firebase/
   │   ├── @grpc/
   │   ├── @humanfs/
   │   ├── @humanwhocodes/
   │   ├── @ide/
   │   ├── @isaacs/
   │   ├── @istanbuljs/
   │   ├── @jest/
   │   ├── @jridgewell/
   │   ├── @modelcontextprotocol/
   │   ├── @napi-rs/
   │   ├── @nodelib/
   │   ├── @nolyfill/
   │   ├── @pkgjs/
   │   ├── @protobufjs/
   │   ├── @radix-ui/
   │   ├── @react-native/
   │   ├── @react-native-async-storage/
   │   ├── @react-native-firebase/
   │   ├── @react-navigation/
   │   ├── @rneui/
   │   ├── @rtsao/
   │   ├── @sinclair/
   │   ├── @sinonjs/
   │   ├── @tybys/
   │   ├── @types/
   │   ├── @typescript-eslint/
   │   ├── @unrs/
   │   ├── @urql/
   │   ├── @xmldom/
   │   ├── abort-controller/
   │   ├── accepts/
   │   ├── acorn/
   │   ├── acorn-jsx/
   │   ├── agent-base/
   │   ├── ajv/
   │   ├── ajv-formats/
   │   ├── anser/
   │   ├── ansi-escapes/
   │   ├── ansi-regex/
   │   ├── ansi-styles/
   │   ├── any-promise/
   │   ├── anymatch/
   │   ├── arg/
   │   ├── argparse/
   │   ├── array-buffer-byte-length/
   │   ├── array-includes/
   │   ├── array-timsort/
   │   ├── array.prototype.findlast/
   │   ├── array.prototype.findlastindex/
   │   ├── array.prototype.flat/
   │   ├── array.prototype.flatmap/
   │   ├── array.prototype.tosorted/
   │   ├── arraybuffer.prototype.slice/
   │   ├── asap/
   │   ├── assert/
   │   ├── async-function/
   │   ├── async-limiter/
   │   ├── asynckit/
   │   ├── autoprefixer/
   │   ├── available-typed-arrays/
   │   ├── axios/
   │   ├── babel-jest/
   │   ├── babel-plugin-istanbul/
   │   ├── babel-plugin-jest-hoist/
   │   ├── babel-plugin-polyfill-corejs2/
   │   ├── babel-plugin-polyfill-corejs3/
   │   ├── babel-plugin-polyfill-regenerator/
   │   ├── babel-plugin-react-native-web/
   │   ├── babel-plugin-syntax-hermes-parser/
   │   ├── babel-plugin-transform-flow-enums/
   │   ├── babel-preset-current-node-syntax/
   │   ├── babel-preset-expo/
   │   ├── babel-preset-jest/
   │   ├── badgin/
   │   ├── balanced-match/
   │   ├── base64-js/
   │   ├── better-opn/
   │   ├── big-integer/
   │   ├── binary-extensions/
   │   ├── body-parser/
   │   ├── bplist-creator/
   │   ├── bplist-parser/
   │   ├── brace-expansion/
   │   ├── braces/
   │   ├── browserslist/
   │   ├── bser/
   │   ├── buffer/
   │   ├── buffer-from/
   │   ├── bytes/
   │   ├── call-bind/
   │   ├── call-bind-apply-helpers/
   │   ├── call-bound/
   │   ├── caller-callsite/
   │   ├── caller-path/
   │   ├── callsites/
   │   ├── camelcase/
   │   ├── camelcase-css/
   │   ├── caniuse-lite/
   │   ├── chalk/
   │   ├── chokidar/
   │   ├── chownr/
   │   ├── chrome-launcher/
   │   ├── chromium-edge-launcher/
   │   ├── ci-info/
   │   ├── cli-cursor/
   │   ├── cli-spinners/
   │   ├── client-only/
   │   ├── cliui/
   │   ├── clone/
   │   ├── clone-deep/
   │   ├── color/
   │   ├── color-convert/
   │   ├── color-name/
   │   ├── color-string/
   │   ├── combined-stream/
   │   ├── commander/
   │   ├── comment-json/
   │   ├── compressible/
   │   ├── compression/
   │   ├── concat-map/
   │   ├── connect/
   │   ├── content-disposition/
   │   ├── content-type/
   │   ├── convert-source-map/
   │   ├── cookie/
   │   ├── cookie-signature/
   │   ├── core-js-compat/
   │   ├── core-util-is/
   │   ├── cors/
   │   ├── cosmiconfig/
   │   ├── cross-fetch/
   │   ├── cross-spawn/
   │   ├── crypto-random-string/
   │   ├── css-in-js-utils/
   │   ├── cssesc/
   │   ├── csstype/
   │   ├── data-view-buffer/
   │   ├── data-view-byte-length/
   │   ├── data-view-byte-offset/
   │   ├── debug/
   │   ├── decode-uri-component/
   │   ├── deep-extend/
   │   ├── deep-is/
   │   ├── deepmerge/
   │   ├── defaults/
   │   ├── define-data-property/
   │   ├── define-lazy-prop/
   │   ├── define-properties/
   │   ├── delayed-stream/
   │   ├── depd/
   │   ├── destroy/
   │   ├── detect-libc/
   │   ├── didyoumean/
   │   ├── dlv/
   │   ├── doctrine/
   │   ├── dotenv/
   │   ├── dotenv-expand/
   │   ├── dunder-proto/
   │   ├── eastasianwidth/
   │   ├── ee-first/
   │   ├── electron-to-chromium/
   │   ├── emoji-regex/
   │   ├── encodeurl/
   │   ├── env-editor/
   │   ├── error-ex/
   │   ├── error-stack-parser/
   │   ├── es-abstract/
   │   ├── es-define-property/
   │   ├── es-errors/
   │   ├── es-iterator-helpers/
   │   ├── es-object-atoms/
   │   ├── es-set-tostringtag/
   │   ├── es-shim-unscopables/
   │   ├── es-to-primitive/
   │   ├── escalade/
   │   ├── escape-html/
   │   ├── escape-string-regexp/
   │   ├── eslint/
   │   ├── eslint-config-expo/
   │   ├── eslint-import-resolver-node/
   │   ├── eslint-import-resolver-typescript/
   │   ├── eslint-module-utils/
   │   ├── eslint-plugin-expo/
   │   ├── eslint-plugin-import/
   │   ├── eslint-plugin-react/
   │   ├── eslint-plugin-react-hooks/
   │   ├── eslint-scope/
   │   ├── eslint-visitor-keys/
   │   ├── espree/
   │   ├── esprima/
   │   ├── esquery/
   │   ├── esrecurse/
   │   ├── estraverse/
   │   ├── esutils/
   │   ├── etag/
   │   ├── event-target-shim/
   │   ├── eventsource/
   │   ├── eventsource-parser/
   │   ├── exec-async/
   │   ├── expo/
   │   ├── expo-application/
   │   ├── expo-asset/
   │   ├── expo-blur/
   │   ├── expo-constants/
   │   ├── expo-device/
   │   ├── expo-file-system/
   │   ├── expo-font/
   │   ├── expo-haptics/
   │   ├── expo-image/
   │   ├── expo-image-loader/
   │   ├── expo-image-picker/
   │   ├── expo-keep-awake/
   │   ├── expo-linking/
   │   ├── expo-modules-autolinking/
   │   ├── expo-modules-core/
   │   ├── expo-notifications/
   │   ├── expo-router/
   │   ├── expo-splash-screen/
   │   ├── expo-status-bar/
   │   ├── expo-symbols/
   │   ├── expo-system-ui/
   │   ├── expo-web-browser/
   │   ├── exponential-backoff/
   │   ├── express/
   │   ├── express-rate-limit/
   │   ├── fast-deep-equal/
   │   ├── fast-glob/
   │   ├── fast-json-stable-stringify/
   │   ├── fast-levenshtein/
   │   ├── fast-uri/
   │   ├── fastq/
   │   ├── fb-watchman/
   │   ├── fbjs/
   │   ├── fbjs-css-vars/
   │   ├── fdir/
   │   ├── file-entry-cache/
   │   ├── fill-range/
   │   ├── filter-obj/
   │   ├── finalhandler/
   │   ├── find-up/
   │   ├── flat-cache/
   │   ├── flatted/
   │   ├── flow-enums-runtime/
   │   ├── follow-redirects/
   │   ├── fontfaceobserver/
   │   ├── for-each/
   │   ├── for-in/
   │   ├── for-own/
   │   ├── foreground-child/
   │   ├── form-data/
   │   ├── forwarded/
   │   ├── fraction.js/
   │   ├── freeport-async/
   │   ├── fresh/
   │   ├── fs.realpath/
   │   ├── function-bind/
   │   ├── function.prototype.name/
   │   ├── functions-have-names/
   │   ├── gensync/
   │   ├── get-caller-file/
   │   ├── get-intrinsic/
   │   ├── get-package-type/
   │   ├── get-proto/
   │   ├── get-symbol-description/
   │   ├── get-tsconfig/
   │   ├── getenv/
   │   ├── glob/
   │   ├── glob-parent/
   │   ├── globals/
   │   ├── globalthis/
   │   ├── gopd/
   │   ├── graceful-fs/
   │   ├── graphemer/
   │   ├── has-bigints/
   │   ├── has-flag/
   │   ├── has-own-prop/
   │   ├── has-property-descriptors/
   │   ├── has-proto/
   │   ├── has-symbols/
   │   ├── has-tostringtag/
   │   ├── hasown/
   │   ├── hermes-estree/
   │   ├── hermes-parser/
   │   ├── hoist-non-react-statics/
   │   ├── hosted-git-info/
   │   ├── http-errors/
   │   ├── https-proxy-agent/
   │   ├── hyphenate-style-name/
   │   ├── iconv-lite/
   │   ├── ieee754/
   │   ├── ignore/
   │   ├── image-size/
   │   ├── import-fresh/
   │   ├── imurmurhash/
   │   ├── inflight/
   │   ├── inherits/
   │   ├── ini/
   │   ├── inline-style-prefixer/
   │   ├── internal-slot/
   │   ├── invariant/
   │   ├── ipaddr.js/
   │   ├── is-arguments/
   │   ├── is-array-buffer/
   │   ├── is-arrayish/
   │   ├── is-async-function/
   │   ├── is-bigint/
   │   ├── is-binary-path/
   │   ├── is-boolean-object/
   │   ├── is-bun-module/
   │   ├── is-callable/
   │   ├── is-core-module/
   │   ├── is-data-view/
   │   ├── is-date-object/
   │   ├── is-directory/
   │   ├── is-docker/
   │   ├── is-extendable/
   │   ├── is-extglob/
   │   ├── is-finalizationregistry/
   │   ├── is-fullwidth-code-point/
   │   ├── is-generator-function/
   │   ├── is-glob/
   │   ├── is-map/
   │   ├── is-nan/
   │   ├── is-number/
   │   ├── is-number-object/
   │   ├── is-plain-obj/
   │   ├── is-plain-object/
   │   ├── is-promise/
   │   ├── is-regex/
   │   ├── is-set/
   │   ├── is-shared-array-buffer/
   │   ├── is-string/
   │   ├── is-symbol/
   │   ├── is-typed-array/
   │   ├── is-weakmap/
   │   ├── is-weakref/
   │   ├── is-weakset/
   │   ├── is-wsl/
   │   ├── isarray/
   │   ├── isexe/
   │   ├── isobject/
   │   ├── istanbul-lib-coverage/
   │   ├── istanbul-lib-instrument/
   │   ├── iterator.prototype/
   │   ├── jackspeak/
   │   ├── jest-environment-node/
   │   ├── jest-get-type/
   │   ├── jest-haste-map/
   │   ├── jest-message-util/
   │   ├── jest-mock/
   │   ├── jest-regex-util/
   │   ├── jest-util/
   │   ├── jest-validate/
   │   ├── jest-worker/
   │   ├── jimp-compact/
   │   ├── jiti/
   │   ├── js-tokens/
   │   ├── js-yaml/
   │   ├── jsc-safe-url/
   │   ├── jsesc/
   │   ├── json-buffer/
   │   ├── json-parse-better-errors/
   │   ├── json-schema-traverse/
   │   ├── json-stable-stringify-without-jsonify/
   │   ├── json5/
   │   ├── jsx-ast-utils/
   │   ├── keyv/
   │   ├── kind-of/
   │   ├── kleur/
   │   ├── lan-network/
   │   ├── leven/
   │   ├── levn/
   │   ├── lighthouse-logger/
   │   ├── lightningcss/
   │   ├── lightningcss-win32-x64-msvc/
   │   ├── lilconfig/
   │   ├── lines-and-columns/
   │   ├── locate-path/
   │   ├── lodash/
   │   ├── lodash.debounce/
   │   ├── lodash.merge/
   │   ├── lodash.throttle/
   │   ├── log-symbols/
   │   ├── loose-envify/
   │   ├── lru-cache/
   │   ├── makeerror/
   │   ├── marky/
   │   ├── math-intrinsics/
   │   ├── media-typer/
   │   ├── memoize-one/
   │   ├── merge-descriptors/
   │   ├── merge-options/
   │   ├── merge-stream/
   │   ├── merge2/
   │   ├── metro/
   │   ├── metro-babel-transformer/
   │   ├── metro-cache/
   │   ├── metro-cache-key/
   │   ├── metro-config/
   │   ├── metro-core/
   │   ├── metro-file-map/
   │   ├── metro-minify-terser/
   │   ├── metro-resolver/
   │   ├── metro-runtime/
   │   ├── metro-source-map/
   │   ├── metro-symbolicate/
   │   ├── metro-transform-plugins/
   │   ├── metro-transform-worker/
   │   ├── micromatch/
   │   ├── mime/
   │   ├── mime-db/
   │   ├── mime-types/
   │   ├── mimic-fn/
   │   ├── minimatch/
   │   ├── minimist/
   │   ├── minipass/
   │   ├── minizlib/
   │   ├── mixin-object/
   │   ├── mkdirp/
   │   ├── ms/
   │   ├── mz/
   │   ├── nanoid/
   │   ├── napi-postinstall/
   │   ├── nativewind/
   │   ├── natural-compare/
   │   ├── negotiator/
   │   ├── nested-error-stacks/
   │   ├── node-fetch/
   │   ├── node-forge/
   │   ├── node-int64/
   │   ├── node-releases/
   │   ├── normalize-path/
   │   ├── normalize-range/
   │   ├── npm-package-arg/
   │   ├── nullthrows/
   │   ├── ob1/
   │   ├── object-assign/
   │   ├── object-hash/
   │   ├── object-inspect/
   │   ├── object-is/
   │   ├── object-keys/
   │   ├── object.assign/
   │   ├── object.entries/
   │   ├── object.fromentries/
   │   ├── object.groupby/
   │   ├── object.values/
   │   ├── on-finished/
   │   ├── on-headers/
   │   ├── once/
   │   ├── onetime/
   │   ├── open/
   │   ├── opencollective-postinstall/
   │   ├── optionator/
   │   ├── ora/
   │   ├── own-keys/
   │   ├── p-limit/
   │   ├── p-locate/
   │   ├── p-try/
   │   ├── package-json-from-dist/
   │   ├── parent-module/
   │   ├── parse-json/
   │   ├── parse-png/
   │   ├── parseurl/
   │   ├── path-exists/
   │   ├── path-is-absolute/
   │   ├── path-key/
   │   ├── path-parse/
   │   ├── path-scurry/
   │   ├── path-to-regexp/
   │   ├── picocolors/
   │   ├── picomatch/
   │   ├── pify/
   │   ├── pirates/
   │   ├── pkce-challenge/
   │   ├── plist/
   │   ├── pngjs/
   │   ├── possible-typed-array-names/
   │   ├── postcss/
   │   ├── postcss-import/
   │   ├── postcss-js/
   │   ├── postcss-load-config/
   │   ├── postcss-nested/
   │   ├── postcss-selector-parser/
   │   ├── postcss-value-parser/
   │   ├── prelude-ls/
   │   ├── pretty-bytes/
   │   ├── pretty-format/
   │   ├── proc-log/
   │   ├── progress/
   │   ├── promise/
   │   ├── prompts/
   │   ├── prop-types/
   │   ├── proxy-addr/
   │   ├── proxy-from-env/
   │   ├── punycode/
   │   ├── qrcode-terminal/
   │   ├── qs/
   │   ├── query-string/
   │   ├── queue/
   │   ├── queue-microtask/
   │   ├── range-parser/
   │   ├── raw-body/
   │   ├── rc/
   │   ├── react/
   │   ├── react-devtools-core/
   │   ├── react-dom/
   │   ├── react-fast-compare/
   │   ├── react-freeze/
   │   ├── react-is/
   │   ├── react-native/
   │   ├── react-native-css-interop/
   │   ├── react-native-edge-to-edge/
   │   ├── react-native-gesture-handler/
   │   ├── react-native-is-edge-to-edge/
   │   ├── react-native-ratings/
   │   ├── react-native-reanimated/
   │   ├── react-native-safe-area-context/
   │   ├── react-native-screens/
   │   ├── react-native-size-matters/
   │   ├── react-native-web/
   │   ├── react-native-webview/
   │   ├── react-refresh/
   │   ├── read-cache/
   │   ├── readdirp/
   │   ├── reflect.getprototypeof/
   │   ├── regenerate/
   │   ├── regenerate-unicode-properties/
   │   ├── regenerator-runtime/
   │   ├── regexp.prototype.flags/
   │   ├── regexpu-core/
   │   ├── regjsgen/
   │   ├── regjsparser/
   │   ├── repeat-string/
   │   ├── require-directory/
   │   ├── require-from-string/
   │   ├── requireg/
   │   ├── resolve/
   │   ├── resolve-from/
   │   ├── resolve-pkg-maps/
   │   ├── resolve-workspace-root/
   │   ├── resolve.exports/
   │   ├── restore-cursor/
   │   ├── reusify/
   │   ├── rimraf/
   │   ├── router/
   │   ├── run-parallel/
   │   ├── safe-array-concat/
   │   ├── safe-buffer/
   │   ├── safe-push-apply/
   │   ├── safe-regex-test/
   │   ├── safer-buffer/
   │   ├── sax/
   │   ├── scheduler/
   │   ├── schema-utils/
   │   ├── semver/
   │   ├── send/
   │   ├── serialize-error/
   │   ├── serve-static/
   │   ├── server-only/
   │   ├── set-function-length/
   │   ├── set-function-name/
   │   ├── set-proto/
   │   ├── setimmediate/
   │   ├── setprototypeof/
   │   ├── sf-symbols-typescript/
   │   ├── shallow-clone/
   │   ├── shallowequal/
   │   ├── shebang-command/
   │   ├── shebang-regex/
   │   ├── shell-quote/
   │   ├── side-channel/
   │   ├── side-channel-list/
   │   ├── side-channel-map/
   │   ├── side-channel-weakmap/
   │   ├── signal-exit/
   │   ├── simple-plist/
   │   ├── simple-swizzle/
   │   ├── sisteransi/
   │   ├── slash/
   │   ├── slugify/
   │   ├── source-map/
   │   ├── source-map-js/
   │   ├── source-map-support/
   │   ├── split-on-first/
   │   ├── sprintf-js/
   │   ├── stable-hash/
   │   ├── stack-utils/
   │   ├── stackframe/
   │   ├── stacktrace-parser/
   │   ├── statuses/
   │   ├── stream-buffers/
   │   ├── strict-uri-encode/
   │   ├── string-width/
   │   ├── string-width-cjs/
   │   ├── string.prototype.matchall/
   │   ├── string.prototype.repeat/
   │   ├── string.prototype.trim/
   │   ├── string.prototype.trimend/
   │   ├── string.prototype.trimstart/
   │   ├── strip-ansi/
   │   ├── strip-ansi-cjs/
   │   ├── strip-bom/
   │   ├── strip-json-comments/
   │   ├── structured-headers/
   │   ├── styleq/
   │   ├── sucrase/
   │   ├── superstruct/
   │   ├── supports-color/
   │   ├── supports-hyperlinks/
   │   ├── supports-preserve-symlinks-flag/
   │   ├── tailwindcss/
   │   ├── tar/
   │   ├── temp-dir/
   │   ├── terminal-link/
   │   ├── terser/
   │   ├── test-exclude/
   │   ├── thenify/
   │   ├── thenify-all/
   │   ├── throat/
   │   ├── tinyglobby/
   │   ├── tmpl/
   │   ├── to-regex-range/
   │   ├── toidentifier/
   │   ├── tr46/
   │   ├── ts-api-utils/
   │   ├── ts-interface-checker/
   │   ├── tsconfig-paths/
   │   ├── type-check/
   │   ├── type-detect/
   │   ├── type-fest/
   │   ├── type-is/
   │   ├── typed-array-buffer/
   │   ├── typed-array-byte-length/
   │   ├── typed-array-byte-offset/
   │   ├── typed-array-length/
   │   ├── typescript/
   │   ├── ua-parser-js/
   │   ├── unbox-primitive/
   │   ├── undici/
   │   ├── undici-types/
   │   ├── unicode-canonical-property-names-ecmascript/
   │   ├── unicode-match-property-ecmascript/
   │   ├── unicode-match-property-value-ecmascript/
   │   ├── unicode-property-aliases-ecmascript/
   │   ├── unique-string/
   │   ├── unpipe/
   │   ├── unrs-resolver/
   │   ├── update-browserslist-db/
   │   ├── uri-js/
   │   ├── use-latest-callback/
   │   ├── use-sync-external-store/
   │   ├── util/
   │   ├── util-deprecate/
   │   ├── utils-merge/
   │   ├── uuid/
   │   ├── validate-npm-package-name/
   │   ├── vary/
   │   ├── vlq/
   │   ├── walker/
   │   ├── warn-once/
   │   ├── wcwidth/
   │   ├── webidl-conversions/
   │   ├── whatwg-fetch/
   │   ├── whatwg-url/
   │   ├── whatwg-url-without-unicode/
   │   ├── which/
   │   ├── which-boxed-primitive/
   │   ├── which-builtin-type/
   │   ├── which-collection/
   │   ├── which-typed-array/
   │   ├── wonka/
   │   ├── word-wrap/
   │   ├── wrap-ansi/
   │   ├── wrap-ansi-cjs/
   │   ├── wrappy/
   │   ├── write-file-atomic/
   │   ├── ws/
   │   ├── xcode/
   │   ├── xml2js/
   │   ├── xmlbuilder/
   │   ├── y18n/
   │   ├── yallist/
   │   ├── yaml/
   │   ├── yargs/
   │   ├── yargs-parser/
   │   ├── yocto-queue/
   │   ├── zod/
   │   ├── zod-to-json-schema/
   │   └── .package-lock.json
   ├── src/
   │   ├── app/
   │   │   ├── (app)/
   │   │   │   ├── (home)/
   │   │   │   │   ├── _layout.js
   │   │   │   │   └── index.js
   │   │   │   ├── account/
   │   │   │   │   ├── order-history/
   │   │   │   │   │   ├── [id].jsx
   │   │   │   │   │   └── index.jsx
   │   │   │   │   ├── _layout.js
   │   │   │   │   ├── addresses.jsx
   │   │   │   │   ├── change-password.jsx
   │   │   │   │   ├── edit-profile.jsx
   │   │   │   │   └── index.jsx
   │   │   │   ├── blog/
   │   │   │   │   ├── [id].js
   │   │   │   │   ├── _layout.js
   │   │   │   │   └── index.js
   │   │   │   ├── cart/
   │   │   │   │   ├── _layout.js
   │   │   │   │   └── index.js
   │   │   │   ├── checkout/
   │   │   │   │   ├── _layout.js
   │   │   │   │   └── index.js
   │   │   │   ├── notification/
   │   │   │   │   ├── _layout.js
   │   │   │   │   └── index.jsx
   │   │   │   ├── product/
   │   │   │   │   ├── [id].js
   │   │   │   │   ├── _layout.js
   │   │   │   │   ├── index.jsx
   │   │   │   │   └── reviews.js
   │   │   │   └── _layout.js
   │   │   ├── (auth)/
   │   │   │   ├── _layout.js
   │   │   │   ├── forgot-password.js
   │   │   │   ├── login.js
   │   │   │   ├── register.js
   │   │   │   └── reset-password.js
   │   │   ├── _layout.js
   │   │   └── index.js
   │   ├── assets/
   │   │   ├── fonts/
   │   │   │   └── SpaceMono-Regular.ttf
   │   │   └── images/
   │   │       ├── adaptive-icon.png
   │   │       ├── icon.png
   │   │       └── splash-icon.png
   │   ├── components/
   │   │   └── layouts/
   │   │       ├── HeaderLeftBackIcon.jsx
   │   │       └── HeaderRightIcon.jsx
   │   ├── contexts/
   │   │   ├── AuthContext.js
   │   │   ├── CartContext.js
   │   │   ├── index.js
   │   │   └── NotificationContext.js
   │   ├── screens/
   │   │   ├── account/
   │   │   │   ├── AccountScreen.jsx
   │   │   │   ├── ChangePasswordScreen.jsx
   │   │   │   ├── EditProfileScreen.jsx
   │   │   │   ├── OrderDetailScreen.jsx
   │   │   │   ├── OrderHistoryScreen.jsx
   │   │   │   └── ShippingAddressesScreen.jsx
   │   │   ├── auth/
   │   │   │   ├── ForgotPasswordScreen.jsx
   │   │   │   ├── LoginScreen.jsx
   │   │   │   ├── RegisterScreen.jsx
   │   │   │   └── ResetPasswordScreen.jsx
   │   │   ├── blog/
   │   │   │   ├── BlogDetailScreen.jsx
   │   │   │   └── BlogScreen.jsx
   │   │   ├── cart/
   │   │   │   └── CartScreen.jsx
   │   │   ├── checkout/
   │   │   │   └── CheckoutScreen.jsx
   │   │   ├── home/
   │   │   │   └── HomeScreen.jsx
   │   │   ├── notification/
   │   │   │   └── NotificationScreen.jsx
   │   │   └── product/
   │   │       ├── ProductDetailScreen.jsx
   │   │       ├── ProductReviewsScreen.jsx
   │   │       └── ProductScreen.jsx
   │   ├── services/
   │   │   ├── api.js
   │   │   ├── blogService.js
   │   │   ├── cartService.js
   │   │   ├── categoryService.js
   │   │   ├── customerService.js
   │   │   ├── fileService.js
   │   │   ├── identityService.js
   │   │   ├── index.js
   │   │   ├── notificationService.js
   │   │   ├── orderService.js
   │   │   ├── paymentService.js
   │   │   ├── productService.js
   │   │   └── profileService.js
   │   ├── utils/
   │   │   └── imageUtils.js
   │   └── global.css
   ├── .env
   ├── .gitignore
   ├── app.d.ts
   ├── app.json
   ├── babel.config.js
   ├── eslint.config.js
   ├── expo-env.d.ts
   ├── global.d.ts
   ├── index.js
   ├── metro.config.js
   ├── nativewind-env.d.ts
   ├── package-lock.json
   ├── package.json
   ├── postcss.config.js
   ├── README.md
   ├── tailwind.config.js
   └── tsconfig.json
   ------------------------------------------------------------ */

/* ===== app.json ===== */
{
  "expo": {
    "name": "book_store_mobile",
    "slug": "book_store_mobile",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./src/assets/images/icon.png",
    "scheme": "bookstoremobile",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "router": {
      "entry": "src/app/index"
    },
    "ios": {
      "supportsTablet": true,
      "entitlements": {
        "aps-environment": "production"
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./src/assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "package": "com.anonymous.book_store_mobile"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./src/assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      "expo-notifications",
      [
        "expo-splash-screen",
        {
          "image": "./src/assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}


/* ===== index.js ===== */
import 'expo-router/entry';


/* ===== package.json ===== */
{
  "name": "book_store_mobile",
  "main": "expo-router/entry",
  "expo": {
    "router": {
      "entry": "src/app/index"
    }
  },
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.1.0",
    "@faker-js/faker": "^9.8.0",
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-firebase/app": "^19.0.0",
    "@react-native-firebase/messaging": "^19.0.0",
    "@react-navigation/bottom-tabs": "^7.3.10",
    "@react-navigation/elements": "^2.3.8",
    "@react-navigation/native": "^7.1.6",
    "@rneui/base": "^4.0.0-rc.8",
    "@rneui/themed": "^4.0.0-rc.8",
    "axios": "^1.9.0",
    "expo": "~53.0.9",
    "expo-blur": "~14.1.4",
    "expo-constants": "~17.1.6",
    "expo-device": "~7.1.4",
    "expo-font": "~13.3.1",
    "expo-haptics": "~14.1.4",
    "expo-image": "~2.1.7",
    "expo-image-picker": "~16.1.4",
    "expo-linking": "~7.1.5",
    "expo-notifications": "^0.31.2",
    "expo-router": "~5.0.7",
    "expo-splash-screen": "~0.30.8",
    "expo-status-bar": "~2.2.3",
    "expo-symbols": "~0.4.4",
    "expo-system-ui": "~5.0.7",
    "expo-web-browser": "~14.1.6",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-native": "0.79.2",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.10.0",
    "react-native-web": "~0.20.0",
    "react-native-webview": "13.13.5"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~19.0.10",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~9.2.0",
    "nativewind": "^4.1.23",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.17",
    "typescript": "~5.8.3"
  },
  "private": true
}


/* ===== src\global.css ===== */
@tailwind base;
@tailwind components;
@tailwind utilities; 

/* ===== src\app\index.js ===== */
import {Redirect} from 'expo-router';
import React from 'react';

export default function IndexRoute() {
    return <Redirect href="/(app)/(home)/"/>;
} 

/* ===== src\app\_layout.js ===== */
import AppProviders from '@/contexts';
import {Slot} from 'expo-router';
import React, {useEffect} from 'react';
import "../global.css";
// import '@react-native-firebase/app';
// import messaging from '@react-native-firebase/messaging';

export default function RootLayoutRoute() {

    // async function requestUserPermission() {
    //     const authStatus = await messaging().requestPermission();
    //     const enabled = authStatus === messaging.AuthorizationStatus.AUTHORIZED || authStatus === messaging.AuthorizationStatus.PROVISIONAL;
    //
    //     if (enabled) {
    //         console.log('Authorization status:', authStatus);
    //     }
    // }
    //
    // const getToken = async () => {
    //     const token = await messaging().getToken();
    //     console.log("Token: ", token);
    // }

    useEffect(() => {
        console.log("App mounted");
    }, []);

    return (<AppProviders>
        <Slot/>
    </AppProviders>);
}

/* ===== src\app\(app)\_layout.js ===== */
/* ===== app/(app)/_layout.js ===== */
import HeaderRightIcon from '@/components/layouts/HeaderRightIcon';
import { FontAwesome, Ionicons, MaterialCommunityIcons } from '@expo/vector-icons'; // Ví dụ icon
import { Tabs } from 'expo-router';
import React from 'react';

export default function AppTabsLayoutRoute() {
    return (<Tabs
        screenOptions={{
            headerShown: true,
            headerRight: () => <HeaderRightIcon />,
        }}
    >
        <Tabs.Screen
            name="(home)"
            options={{
                headerShown: false,
                headerRight: () => <HeaderRightIcon />,
                title: 'Trang chủ',
                href: "/(app)/(home)",
                tabBarIcon: ({ color, size }) => <FontAwesome name="home" size={size} color={color} />,
            }}
        />
        <Tabs.Screen
            name="blog"
            options={{
                headerShown: false,
                title: 'Tin tức',
                href: "/(app)/blog",
                tabBarIcon: ({ color, size }) => <MaterialCommunityIcons name="post-outline" size={size}
                    color={color} />,
            }}
        />
        <Tabs.Screen
            name="product"
            options={{
                headerShown: false,
                title: 'Sản phẩm',
                href: "/(app)/product",
                tabBarIcon: ({ color, size }) => <Ionicons name="search" size={size} color={color} />,
            }}
        />

        <Tabs.Screen
            name="cart"
            options={{
                headerShown: false,
                href: "/(app)/cart",
                title: ' Giỏ hàng',
                tabBarIcon: ({ color, size }) => <Ionicons name="cart" size={size} color={color} />,
            }}
        />
        <Tabs.Screen
            name="account"
            options={{
                title: 'Tài khoản',
                href: "/(app)/account",
                headerShown: false,
                tabBarIcon: ({ color, size }) => <MaterialCommunityIcons name="account-circle" size={size}
                    color={color} />,
            }}
        />

        {/* Các screen này không hiển thị trên tab bar, được điều hướng tới */}
        <Tabs.Screen
            name="notification"
            options={{
                title: 'Giỏ hàng', headerShown: false, href: null
            }}
        />
        <Tabs.Screen
            name="checkout"
            options={{
                title: 'Thanh toán', headerShown: false, href: null
            }}
        />
    </Tabs>);
}

/* ===== src\app\(app)\(home)\index.js ===== */
import HomeScreen from "@/screens/home/HomeScreen";

export default function HomeRoute() { // Hoặc ProductListRoute
    return <HomeScreen></HomeScreen>;
} 

/* ===== src\app\(app)\(home)\_layout.js ===== */
import HeaderRightIcon from "@/components/layouts/HeaderRightIcon";
import { Stack } from 'expo-router';
import React from 'react';

export default function HomeStackLayoutRoute() {
    return (<Stack>
        <Stack.Screen name="index"
            options={{
                headerShown: true, title: 'Trang chủ', headerRight: () => (<HeaderRightIcon />)
            }}
        />
    </Stack>);
}

/* ===== src\app\(app)\account\addresses.jsx ===== */

/* ===== src/app/(app)/account/addresses.jsx ===== */
import React from 'react';
import ShippingAddressesScreen from '@/screens/account/ShippingAddressesScreen';

export default function ShippingAddressesRoute() {
    return <ShippingAddressesScreen />;
}

/* ===== src\app\(app)\account\change-password.jsx ===== */
/* ===== src/app/(app)/account/change-password.jsx ===== */
import ChangePasswordScreen from '@/screens/account/ChangePasswordScreen';
import React from 'react';

export default function ChangePasswordRoute() {
    return <ChangePasswordScreen />;
}

/* ===== src\app\(app)\account\edit-profile.jsx ===== */

/* ===== src/app/(app)/account/edit-profile.jsx ===== */
import React from 'react';
import EditProfileScreen from '@/screens/account/EditProfileScreen';

export default function EditProfileRoute() {
    return <EditProfileScreen />;
}



/* ===== src\app\(app)\account\index.jsx ===== */
import React from 'react';
import AccountScreen from "@/screens/account/AccountScreen";

function AccountRoute() {
    return (<AccountScreen></AccountScreen>);
}

export default AccountRoute;

/* ===== src\app\(app)\account\_layout.js ===== */
// src/app/(app)/account/_layout.js
import HeaderLeftBackIcon from '@/components/layouts/HeaderLeftBackIcon';
import HeaderRightIcon from "@/components/layouts/HeaderRightIcon";
import { Stack } from 'expo-router';
import React from 'react';

export default function AccountStackLayoutRoute() {
    return (
        <Stack>
            <Stack.Screen
                name="index" // Tham chiếu đến src/app/(app)/account/index.jsx
                options={{
                    headerShown: true,
                    title: 'Tài Khoản Của Tôi',
                    headerRight: () => <HeaderRightIcon />,
                }}
            />
            <Stack.Screen
                name="edit-profile" // src/app/(app)/account/edit-profile.jsx
                options={{
                    headerShown: true,
                    title: 'Chỉnh Sửa Thông Tin',
                    headerLeft: () => <HeaderLeftBackIcon />,
                    headerRight: () => <HeaderRightIcon />,
                }}
            />
            <Stack.Screen
                name="order-history/index" // src/app/(app)/account/order-history/index.jsx
                options={{
                    headerShown: true,
                    title: 'Lịch Sử Đơn Hàng',
                    headerLeft: () => <HeaderLeftBackIcon />, // Có thể không cần nút back ở đây vì đây là màn hình chính của mục này
                    headerRight: () => <HeaderRightIcon />,
                }}
            />
            <Stack.Screen
                name="order-history/[id]" // src/app/(app)/account/order-history/[id].js
                options={{
                    headerShown: true,
                    title: 'Chi Tiết Đơn Hàng',
                    headerLeft: () => <HeaderLeftBackIcon />,
                    headerRight: () => <HeaderRightIcon />,
                }}
            />
            <Stack.Screen
                name="addresses" // src/app/(app)/account/addresses.jsx
                options={{
                    headerShown: true,
                    title: 'Địa Chỉ Giao Hàng',
                    headerLeft: () => <HeaderLeftBackIcon />,
                    headerRight: () => <HeaderRightIcon />,
                }}
            />
            <Stack.Screen
                name="change-password" // src/app/(app)/account/change-password.jsx
                options={{
                    headerShown: true,
                    title: 'Đổi Mật Khẩu',
                    headerLeft: () => <HeaderLeftBackIcon />,
                    headerRight: () => <HeaderRightIcon />,
                }}
            />
        </Stack>
    );
}

/* ===== src\app\(app)\account\order-history\index.jsx ===== */
/* ===== src/app/(app)/account/order-history.jsx ===== */
import React from 'react';
import OrderHistoryScreen from '@/screens/account/OrderHistoryScreen';

export default function OrderHistoryRoute() {
    return <OrderHistoryScreen />;
}

/* ===== src\app\(app)\account\order-history\[id].jsx ===== */
// src/app/(app)/account/order-history/[id].js
import OrderDetailScreen from '@/screens/account/OrderDetailScreen';
import { useLocalSearchParams } from 'expo-router';
import React from 'react';

export default function OrderDetailRoute() {
    const { id } = useLocalSearchParams();
    return <OrderDetailScreen orderId={id} />;
}

/* ===== src\app\(app)\blog\index.js ===== */
import BlogScreen from "@/screens/blog/BlogScreen";

export default function BlogRoute() {
    return <BlogScreen/>;
}

/* ===== src\app\(app)\blog\[id].js ===== */
import BlogDetailScreen from "@/screens/blog/BlogDetailScreen";
import { useLocalSearchParams } from "expo-router";

export default function BlogDetailRoute() {
  const { id } = useLocalSearchParams()
  return <BlogDetailScreen id={id} />;
} 

/* ===== src\app\(app)\blog\_layout.js ===== */
import {Stack} from 'expo-router';
import React from 'react';
import HeaderRightIcon from "@/components/layouts/HeaderRightIcon";

export default function BlogStackLayoutRoute() {
    return (<Stack>
        <Stack.Screen name="index" options={{title: 'Tin tức & Bài viết', headerRight: () => <HeaderRightIcon/>,}}/>
        <Stack.Screen name="[id]" options={{title: 'Chi tiết bài viết', headerRight: () => <HeaderRightIcon/>,}}/>
    </Stack>);
} 

/* ===== src\app\(app)\cart\index.js ===== */
import CartScreen from "@/screens/cart/CartScreen";

export default function CartRoute() { // Hoặc ProductListRoute
    return <CartScreen></CartScreen>;
}

/* ===== src\app\(app)\cart\_layout.js ===== */
import {Stack} from 'expo-router';
import React from 'react';
import HeaderRightIcon from "@/components/layouts/HeaderRightIcon";

export default function CartStackLayoutRoute() {
    return (<Stack>
        <Stack.Screen name="index" options={{title: 'Giỏ hàng của bạn', headerRight: () => <HeaderRightIcon/>,}}/>
    </Stack>);
} 

/* ===== src\app\(app)\checkout\index.js ===== */
import CheckoutScreen from "@/screens/checkout/CheckoutScreen";

export default function AddressSelectionRoute() {
    return <CheckoutScreen/>;
} 

/* ===== src\app\(app)\checkout\_layout.js ===== */
import {Stack} from 'expo-router';
import React from 'react';

export default function CheckoutStackLayoutRoute() {
    return (<Stack>
            <Stack.Screen name="index" options={{title: 'Thanh toán'}}/>
        </Stack>);
} 

/* ===== src\app\(app)\notification\index.jsx ===== */
import React from 'react';
import NotificationScreen from "@/screens/notification/NotificationScreen";

function NotificationRoute() {
    return (<NotificationScreen></NotificationScreen>);
}

export default NotificationRoute;

/* ===== src\app\(app)\notification\_layout.js ===== */
import {Stack} from 'expo-router';
import React from 'react';
import HeaderRightIcon from "@/components/layouts/HeaderRightIcon";
import HeaderLeftBackIcon from "@/components/layouts/HeaderLeftBackIcon";

export default function NotificationStackLayoutRoute() {
    return (<Stack>
        <Stack.Screen name="index" options={{title: 'Thông báo', headerLeft: () => <HeaderLeftBackIcon/>}}/>
    </Stack>);
}

/* ===== src\app\(app)\product\index.jsx ===== */
import React from 'react';
import ProductScreen from "@/screens/product/ProductScreen";

function ProductRoute() {
    return (<ProductScreen></ProductScreen>);
}

export default ProductRoute;

/* ===== src\app\(app)\product\reviews.js ===== */
// src/app/(app)/product/reviews.js
import ProductReviewsScreen from "@/screens/product/ProductReviewsScreen";
import { useLocalSearchParams } from "expo-router";

export default function ProductReviewsRoute() {
    const { productId } = useLocalSearchParams(); // Lấy productId từ params
    return <ProductReviewsScreen productId={productId} />;
}

/* ===== src\app\(app)\product\[id].js ===== */
import ProductDetailScreen from "@/screens/product/ProductDetailScreen";
import { useLocalSearchParams } from "expo-router";

export default function ProductDetailRoute() {
    const { id } = useLocalSearchParams()
    return <ProductDetailScreen id={id} />;
}

/* ===== src\app\(app)\product\_layout.js ===== */
// src/app/(app)/product/_layout.js
import HeaderLeftBackIcon from '@/components/layouts/HeaderLeftBackIcon'; // Thêm import này
import { Stack } from 'expo-router';
import React from 'react';
import HeaderRightIcon from "@/components/layouts/HeaderRightIcon";

export default function ProductStackLayoutRoute() {
    return (<Stack>
        <Stack.Screen name="index" options={{ title: 'Tìm kiếm sách', headerRight: () => <HeaderRightIcon />, }} />
        <Stack.Screen
            name="[id]"
            options={{
                title: 'Chi tiết sách',
                headerRight: () => <HeaderRightIcon />,
                headerLeft: () => <HeaderLeftBackIcon />, // Thêm nút back cho màn hình chi tiết sản phẩm
            }}
        />
        <Stack.Screen // Route mới cho màn hình đánh giá sản phẩm
            name="reviews"
            options={{
                title: 'Đánh giá sản phẩm',
                headerRight: () => <HeaderRightIcon />,
                headerLeft: () => <HeaderLeftBackIcon />,
            }}
        />
    </Stack>);
}

/* ===== src\app\(auth)\forgot-password.js ===== */
// src/app/(auth)/register.js
import ForgotPasswordScreen from './../../screens/auth/ForgotPasswordScreen';

export default function ForgotPasswordRoute() {
    return <ForgotPasswordScreen />;
}

/* ===== src\app\(auth)\login.js ===== */
import LoginScreen from "@/screens/auth/LoginScreen";

export default function LoginRoute() {
    return <LoginScreen></LoginScreen>;
}

/* ===== src\app\(auth)\register.js ===== */
// src/app/(auth)/register.js
import RegisterScreen from "@/screens/auth/RegisterScreen";

export default function RegisterRoute() {
    return <RegisterScreen />;
}

/* ===== src\app\(auth)\reset-password.js ===== */
// src/app/(auth)/reset-password.js
import ResetPasswordScreen from "@/screens/auth/ResetPasswordScreen";

export default function ResetPasswordRoute() {
    return <ResetPasswordScreen></ResetPasswordScreen>;
}

/* ===== src\app\(auth)\_layout.js ===== */
import { Stack } from 'expo-router';
import React from 'react';

export default function AuthStackLayoutRoute() {
    return (<Stack screenOptions={{ headerShown: false }}>
        <Stack.Screen name="login" />
        <Stack.Screen name="register" />
        <Stack.Screen name="forgot-password" />
        <Stack.Screen name="reset-password" />
    </Stack>);
} 

/* ===== src\components\layouts\HeaderLeftBackIcon.jsx ===== */
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React from 'react';
import { TouchableOpacity } from 'react-native';

export default function HeaderLeftBackIcon({ color = 'black', size = 26 }) {
    const router = useRouter();

    return (<TouchableOpacity
        onPress={() => {
            if (router.canGoBack()) {
                router.back();
            }
        }}
        accessibilityLabel="Thông báo"
        accessibilityRole="button"
    >
        <Ionicons name="arrow-back-outline" size={size} color={color} />
    </TouchableOpacity>);
}

/* ===== src\components\layouts\HeaderRightIcon.jsx ===== */
import React from 'react';
import {TouchableOpacity} from 'react-native';
import {Ionicons} from '@expo/vector-icons';
import {useRouter} from 'expo-router';

export default function HeaderRightIcon({color = 'black', size = 26}) {
    const router = useRouter();

    return (<TouchableOpacity
        onPress={() => router.push('/(app)/notification')}
        className="p-2"
        accessibilityLabel="Thông báo"
        accessibilityRole="button"
    >
        <Ionicons name="notifications-outline" size={size} color={color}/>
    </TouchableOpacity>);
}

/* ===== src\contexts\AuthContext.js ===== */
// src/contexts/AuthContext.js
import {useRouter, useSegments} from 'expo-router';
import React, {createContext, useCallback, useContext, useEffect, useState} from 'react';
import {identityService, profileService} from '../services'; // [cite: 854]

const AuthContext = createContext(null); // [cite: 855]

export const AuthProvider = ({children}) => {
    const [user, setUser] = useState(null); // [cite: 855]
    const [isLoading, setIsLoading] = useState(true); // [cite: 856]
    const [isAuthenticated, setIsAuthenticated] = useState(false); // [cite: 856]

    const router = useRouter(); // [cite: 856]
    const segments = useSegments(); // [cite: 856]

    const attemptLoadUser = useCallback(async () => {
        console.log('Attempting to load user...'); // [cite: 857]
        try {
            setIsLoading(true); // [cite: 857]
            const token = await identityService.getAuthToken(); // [cite: 857]
            if (token) {
                console.log('Token found, fetching user info...'); // [cite: 857]
                // Token tồn tại, thử lấy thông tin người dùng
                // getMyInfo sẽ tự động xử lý việc token hợp lệ hay không thông qua interceptor của api.js
                const userInfoResponse = await profileService.getMyInfo(); // [cite: 858]
                if (userInfoResponse && userInfoResponse.result) {
                    console.log('User info fetched successfully:', userInfoResponse.result); // [cite: 859]
                    setUser(userInfoResponse.result); // [cite: 859]
                    setIsAuthenticated(true); // [cite: 859]
                } else {
                    // Trường hợp này ít xảy ra nếu getMyInfo() ném lỗi khi token không hợp lệ
                    // nhưng để phòng trường hợp API trả về thành công mà không có result
                    console.log('getMyInfo successful but no user data, logging out.'); // [cite: 860]
                    await identityService.logout(); // Xóa token không hợp lệ [cite: 861]
                    setUser(null); // [cite: 861]
                    setIsAuthenticated(false); // [cite: 862]
                }
            } else {
                console.log('No token found.'); // [cite: 862]
                setUser(null); // [cite: 863]
                setIsAuthenticated(false); // [cite: 863]
            }
        } catch (error) {
            // Lỗi có thể xảy ra nếu getMyInfo() ném lỗi (ví dụ 401 và interceptor không xử lý được refresh)
            console.error('Error loading user or invalid token:', error.message || error); // [cite: 863]
            // identityService.logout() đã được gọi trong interceptor của api.js nếu có lỗi 401
            // Chỉ cần đảm bảo trạng thái được cập nhật đúng
            setUser(null); // [cite: 864]
            setIsAuthenticated(false); // [cite: 865]
        } finally {
            setIsLoading(false); // [cite: 865]
            console.log('Finished loading user. isLoading:', false, 'isAuthenticated:', isAuthenticated); // [cite: 866]
        }
    }, [isAuthenticated]); // Thêm isAuthenticated vào dependency array nếu bạn muốn nó re-run khi isAuthenticated thay đổi từ bên ngoài [cite: 866, 867]

    useEffect(() => {
        attemptLoadUser(); // [cite: 867]
    }, [attemptLoadUser]); // Chỉ chạy một lần khi component mount [cite: 867, 868]

    useEffect(() => {
        if (isLoading) {
            console.log('Auth state loading, skipping route protection.'); // [cite: 868]
            return;
        }
        console.log('Auth state loaded. isAuthenticated:', isAuthenticated, 'Current segments:', segments); // [cite: 868]

        const inAuthGroup = segments[0] === '(auth)'; // [cite: 868]

        if (!isAuthenticated && !inAuthGroup) {
            console.log('Not authenticated and not in auth group, redirecting to login.'); // [cite: 869]
            router.replace('/(auth)/login'); // [cite: 869]
        } else if (isAuthenticated && inAuthGroup) {
            console.log('Authenticated and in auth group, redirecting to home.'); // [cite: 869]
            router.replace('/(app)/(home)/'); // Điều hướng đến màn hình chính trong (app) group [cite: 869]
        } else {
            console.log('Routing condition not met or already in correct group.'); // [cite: 870]
        }
    }, [isAuthenticated, segments, isLoading, router]); // [cite: 870]

    const login = async (username, password) => {
        try {
            setIsLoading(true); // [cite: 871]
            const loginResponse = await identityService.login({username, password}); // [cite: 872]
            // loginResponse là ApiResponse<AuthenticationResponse>
            if (loginResponse && loginResponse.result && loginResponse.result.token) {
                // Token đã được lưu trong identityService.login
                console.log('Login successful, fetching user info...'); // [cite: 872]
                const userInfoResponse = await profileService.getMyInfo(); // [cite: 873]
                if (userInfoResponse && userInfoResponse.result) {
                    setUser(userInfoResponse.result); // [cite: 873]
                    setIsAuthenticated(true); // [cite: 874]
                    console.log('User set in context:', userInfoResponse.result); // [cite: 874]
                    return loginResponse; // Trả về response gốc của login [cite: 874]
                } else {
                    throw new Error("Failed to fetch user information after login."); // [cite: 874]
                }
            } else {
                // Xử lý trường hợp login API thành công nhưng không trả về token
                throw new Error(loginResponse.message || "Login failed, no token received."); // [cite: 875]
            }
        } catch (error) {
            console.error('Login error in AuthProvider:', error.message || error); // [cite: 876]
            setUser(null); // [cite: 877]
            setIsAuthenticated(false); // [cite: 877]
            throw error; // Ném lỗi để màn hình Login có thể xử lý [cite: 877]
        } finally {
            setIsLoading(false); // [cite: 877]
        }
    };

    const register = async (userData) => { // { username, password, email } [cite: 878]
        try {
            setIsLoading(true); // [cite: 878]
            const response = await identityService.register(userData); // [cite: 879]
            // Sau khi đăng ký thành công, backend có thể không tự động login user
            // User sẽ cần đăng nhập sau khi đăng ký
            return response; // [cite: 879]
            // ApiResponse<UserResponse> (result có thể null)
        } catch (error) {
            console.error('Register error in AuthProvider:', error.message || error); // [cite: 880]
            throw error; // [cite: 881]
        } finally {
            setIsLoading(false); // [cite: 881]
        }
    };

    const logout = async () => {
        try {
            setIsLoading(true); // [cite: 882]
            await identityService.logout(); // Xử lý cả API call và AsyncStorage [cite: 883]
            setUser(null); // [cite: 883]
            setIsAuthenticated(false); // [cite: 884]
            router.replace('/(auth)/login'); // [cite: 884]
            console.log('User logged out and redirected to login.'); // [cite: 884]
        } catch (error) {
            // Lỗi ở đây thường là lỗi mạng khi gọi API logout, AsyncStorage vẫn sẽ được xóa
            console.error('Logout error in AuthProvider:', error.message || error); // [cite: 884]
            // Đảm bảo trạng thái local được reset ngay cả khi API logout thất bại
            setUser(null); // [cite: 885]
            setIsAuthenticated(false); // [cite: 886]
            router.replace('/(auth)/login'); // [cite: 886]
        } finally {
            setIsLoading(false); // [cite: 886]
        }
    };

    const sendOtpForgotPassword = async (username) => {
        try {
            return await identityService.sendOtpForgotPassword(username); // [cite: 887]
        } catch (error) {
            console.error('Forgot password (send OTP) error in AuthProvider:', error.message || error); // [cite: 888]
            throw error; // [cite: 889]
        }
    };

    const verifyOtpAndGetResetToken = async (username, otp) => {
        try {
            const response = await identityService.verifyOtpForgotPassword(username, otp); // [cite: 889]
            // response.result.verificationToken
            return response; // [cite: 890]
            // Trả về toàn bộ ApiResponse để màn hình có thể lấy token
        } catch (error) {
            console.error('Verify OTP error in AuthProvider:', error.message || error); // [cite: 891]
            throw error; // [cite: 892]
        }
    };

    const resetPasswordWithVerificationToken = async (newPassword, verificationToken) => {
        try {
            return await identityService.resetPasswordWithToken(newPassword, verificationToken); // [cite: 892]
        } catch (error) {
            console.error('Reset password error in AuthProvider:', error.message || error); // [cite: 893]
            throw error; // [cite: 894]
        }
    };

    // Cập nhật email
    const updateMyEmail = async (email) => {
        try {
            setIsLoading(true); // [cite: 894]
            const response = await profileService.updateMyInfo({email}); // identityService.updateMyInfo mong muốn { email } [cite: 895]
            if (response && response.result) {
                setUser(prevUser => ({...prevUser, ...response.result})); // [cite: 895]
                // Cập nhật user state với thông tin mới
                await identityService.setCurrentUser(response.result); // [cite: 896]
                // Cập nhật AsyncStorage
            }
            return response; // [cite: 897]
        } catch (error) {
            console.error('Update email error in AuthProvider:', error.message || error); // [cite: 898]
            throw error; // [cite: 899]
        } finally {
            setIsLoading(false); // [cite: 899]
        }
    };

    // Cập nhật mật khẩu
    const updateMyPassword = async (oldPassword, newPassword) => {
        if (!user || !user.id) {
            console.error("User ID not available for password update."); // [cite: 900]
            throw new Error("User not authenticated or ID missing."); // [cite: 901]
        }
        try {
            return await identityService.updateMyPassword(user.id, {oldPassword, newPassword}); // [cite: 901]
        } catch (error) {
            console.error('Update password error in AuthProvider:', error.message || error); // [cite: 902]
            throw error; // [cite: 903]
        }
    };

    // Cập nhật ảnh đại diện
    const updateMyProfileImage = async (profileImageFile) => {
        try {
            setIsLoading(true); // [cite: 903]
            // Hoặc một state loading riêng cho việc update ảnh
            // identityService.updateMyProfileImage đã bao gồm logic gọi API và cập nhật AsyncStorage
            const response = await identityService.updateMyProfileImage(profileImageFile); // [cite: 904]

            if (response && response.status === 200) {
                setUser(response.result); // This will trigger re-renders in consumers
                console.log('AuthContext user state updated with new profile info:', response.result);
                attemptLoadUser()
            }
            return response; // [cite: 907]
            // Trả về response đầy đủ để component xử lý
        } catch (error) {
            console.error('Update profile image error in AuthContext:', error); // [cite: 908]
            throw error; // Ném lỗi để component xử lý [cite: 909]
        } finally {
            setIsLoading(false); // [cite: 909]
        }
    };

    const value = {
        user,
        isLoading,
        isAuthenticated,
        login,
        register,
        logout,
        sendOtpForgotPassword,
        verifyOtpAndGetResetToken,
        resetPasswordWithVerificationToken,
        updateMyEmail,
        updateMyPassword,
        updateMyProfileImage, // Các hàm khác liên quan đến profile chi tiết (tên, địa chỉ) sẽ gọi profileService [cite: 910, 911]
        // và có thể không cần thiết phải nằm trong AuthContext nếu chúng không ảnh hưởng trực tiếp đến trạng thái auth.
    }; // [cite: 912]

    return (<AuthContext.Provider value={value}>
        {children}
    </AuthContext.Provider>); // [cite: 912]
};

export const useAuth = () => {
    const context = useContext(AuthContext); // [cite: 913]
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider'); // [cite: 914]
    }
    return context; // [cite: 915]
};

export default AuthContext; // [cite: 915]

/* ===== src\contexts\CartContext.js ===== */
// src/contexts/CartContext.js
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';
import { cartService, productService } from '../services'; // Import cả cartService và productService
import { useAuth } from './AuthContext'; // Để biết user đã đăng nhập chưa

const CartContext = createContext(null);

export const CartProvider = ({ children }) => {
  const [cart, setCart] = useState(null); // cart sẽ là CartResponse từ API, với products đã được populate
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const { isAuthenticated, user } = useAuth(); // Lấy user để biết userId (cartId)

  /**
   * Fetch giỏ hàng của người dùng hiện tại và populate thông tin chi tiết sản phẩm.
   * @param {boolean} forceRefresh - Buộc làm mới dữ liệu, bỏ qua cache nếu có.
   */
  const fetchCart = useCallback(async (forceRefresh = false) => {
    if (!isAuthenticated || !user || !user.id) {
      // console.log('Not authenticated or user missing, resetting cart.');
      setCart(null); // Nếu chưa đăng nhập hoặc không có user, reset giỏ hàng
      setError(null);
      setIsLoading(false); // Đảm bảo loading state được reset
      return;
    }

    // console.log('Fetching cart for user:', user.id);
    setIsLoading(true);
    setError(null);
    try {
      const cartResponse = await cartService.getMyCart(); // Lấy giỏ hàng từ Cart Service
      console.log('Cart response:', cartResponse);

      // cartResponse là ApiResponse<CartResponse>
      // CartResponse: { id (cartId), userId, cartProducts: CartProduct[] }
      // CartProduct: { id (cartProductId), cartId, productId, quantity, createdAt, updatedAt }

      if (cartResponse && cartResponse.status === 200 && cartResponse.result) {
        const fetchedCart = cartResponse.result;
        const cartProductsRaw = fetchedCart.cartProducts || [];

        if (cartProductsRaw.length === 0) {
          // console.log('Cart is empty.');
          setCart({ ...fetchedCart, cartProducts: [] }); // Set giỏ hàng rỗng nếu không có sản phẩm
          return;
        }

        // Lấy tất cả productId duy nhất từ giỏ hàng để fetch thông tin chi tiết
        const productIds = [...new Set(cartProductsRaw.map(item => item.productId))];

        // Fetch thông tin chi tiết của tất cả các sản phẩm
        // Cần một hàm để fetch nhiều sản phẩm cùng lúc nếu API hỗ trợ, hoặc fetch từng cái.
        // Hiện tại, productService.getProductById chỉ lấy từng sản phẩm.
        // Để tối ưu, có thể dùng Promise.all.
        const productDetailsPromises = productIds.map(id =>
          productService.getProductById(id).then(res => res.result).catch(err => {
            console.error(`Failed to fetch details for product ${id}:`, err);
            return null; // Trả về null nếu có lỗi với 1 sản phẩm
          })
        );

        const productDetails = await Promise.all(productDetailsPromises);
        const productMap = new Map(productDetails.filter(p => p !== null).map(p => [p.id, p]));

        // Kết hợp thông tin chi tiết sản phẩm vào mỗi item trong giỏ hàng
        const populatedCartProducts = cartProductsRaw.map(item => ({
          ...item,
          productDetails: productMap.get(item.productId), // Gán thông tin chi tiết sản phẩm
        }));

        // console.log('Populated cart:', { ...fetchedCart, cartProducts: populatedCartProducts });
        setCart({ ...fetchedCart, cartProducts: populatedCartProducts });

      } else if (cartResponse && cartResponse.status === 404) {
        // Backend trả về 404 nếu giỏ hàng chưa tồn tại hoặc rỗng
        // console.log('Cart not found (empty) for user, initializing empty cart.');
        setCart({ id: user.id, userId: user.id, cartProducts: [] }); // Tạo cart rỗng tạm thời
      } else {
        // console.log('Failed to fetch cart:', cartResponse?.message);
        throw new Error(cartResponse?.message || "Không thể tải giỏ hàng.");
      }
    } catch (err) {
      console.error('Fetch cart error in CartContext:', err);
      setError(err.message || 'Lỗi tải giỏ hàng.');
      setCart(null); // Reset cart nếu có lỗi
    } finally {
      setIsLoading(false);
    }
  }, [isAuthenticated, user]);

  // Effect để fetch giỏ hàng khi người dùng đăng nhập hoặc `fetchCart` thay đổi
  useEffect(() => {
    fetchCart();
  }, [fetchCart]); // Chạy khi `fetchCart` (do dependencies của nó thay đổi)

  /**
   * Thêm hoặc cập nhật số lượng sản phẩm trong giỏ hàng.
   * @param {number} productId - ID của sản phẩm.
   * @param {number} quantity - Số lượng sản phẩm (để thêm vào hoặc set cho total mới).
   * @returns {boolean} True nếu thành công, false nếu thất bại.
   */
  const addProductToCart = async (productId, quantity = 1) => {
    if (!isAuthenticated || !user || !user.id) {
      setError("Vui lòng đăng nhập để thêm sản phẩm vào giỏ hàng.");
      return false;
    }
    setIsLoading(true);
    setError(null);
    try {
      // Gọi cartService.addProductToCart. Backend sẽ tự xử lý logic tăng/cập nhật số lượng.
      const response = await cartService.addProductToCart({ productId, quantity });
      if (response && (response.status === 200 || response.status === 201)) {
        // Sau khi thêm/cập nhật thành công, fetch lại giỏ hàng để cập nhật UI
        await fetchCart(true); // Force refresh để lấy dữ liệu mới nhất
        return true;
      } else {
        throw new Error(response?.message || "Không thể thêm sản phẩm vào giỏ hàng.");
      }
    } catch (err) {
      console.error('Add to cart error:', err);
      setError(err.message || 'Lỗi thêm vào giỏ hàng.');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Cập nhật số lượng của một sản phẩm cụ thể trong giỏ hàng.
   * Logic này sử dụng lại `addProductToCart` vì backend hỗ trợ cập nhật số lượng thông qua cùng endpoint.
   * @param {number} productId - ID của sản phẩm.
   * @param {number} newQuantity - Số lượng mới cho sản phẩm.
   * @returns {boolean} True nếu thành công, false nếu thất bại.
   */
  const updateCartItemQuantity = async (productId, newQuantity) => {
    if (!isAuthenticated || !user || !user.id) {
      setError("Vui lòng đăng nhập để cập nhật giỏ hàng.");
      return false;
    }
    setIsLoading(true);
    setError(null);
    try {
      // Backend Cart Service's `addProductToCart` handles quantity updates.
      // If item exists, it updates; otherwise, it adds.
      const response = await cartService.addProductToCart({ productId, quantity: newQuantity });

      if (response && (response.status === 200 || response.status === 201)) {
        await fetchCart(true); // Force refresh
        return true;
      } else {
        throw new Error(response?.message || "Không thể cập nhật số lượng sản phẩm.");
      }
    } catch (err) {
      console.error('Update cart item quantity error:', err);
      setError(err.message || 'Lỗi cập nhật số lượng giỏ hàng.');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Xóa một sản phẩm cụ thể khỏi giỏ hàng bằng productId.
   * @param {number} productId - ID của sản phẩm cần xóa.
   * @returns {boolean} True nếu thành công, false nếu thất bại.
   */
  const removeProductFromCartByProductId = async (productId) => {
    if (!isAuthenticated || !cart || !cart.cartProducts) {
      setError("Giỏ hàng không tồn tại hoặc bạn chưa đăng nhập.");
      return false;
    }
    // Tìm `cartProduct.id` từ `productId`
    const itemToRemove = cart.cartProducts.find(item => item.productId === productId);
    if (!itemToRemove) {
      // console.warn(`Product ID ${productId} not found in cart.`);
      setError("Sản phẩm không tồn tại trong giỏ hàng.");
      return false;
    }

    setIsLoading(true);
    setError(null);
    try {
      // API: DELETE /cart/cart-products, body: Array<integer> (cartProductIds)
      const response = await cartService.removeProductsFromCart([itemToRemove.id]);
      if (response && response.status === 200) {
        await fetchCart(true); // Force refresh
        return true;
      } else {
        throw new Error(response?.message || "Không thể xóa sản phẩm khỏi giỏ hàng.");
      }
    } catch (err) {
      console.error('Remove from cart error:', err);
      setError(err.message || 'Lỗi xóa khỏi giỏ hàng.');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Xóa tất cả các sản phẩm khỏi giỏ hàng của người dùng hiện tại.
   * @returns {boolean} True nếu thành công, false nếu thất bại.
   */
  const clearCart = async () => {
    if (!isAuthenticated || !cart || !cart.cartProducts || cart.cartProducts.length === 0) {
      // Giỏ hàng đã trống, coi như thành công
      // console.log("Cart is already empty, no need to clear.");
      return true;
    }
    const cartProductIds = cart.cartProducts.map(item => item.id); // Lấy tất cả cartProduct.id
    setIsLoading(true);
    setError(null);
    try {
      const response = await cartService.removeProductsFromCart(cartProductIds);
      if (response && response.status === 200) {
        await fetchCart(true); // Sẽ set cart thành rỗng
        return true;
      } else {
        throw new Error(response?.message || "Không thể xóa toàn bộ giỏ hàng.");
      }
    } catch (err) {
      console.error('Clear cart error:', err);
      setError(err.message || 'Lỗi xóa giỏ hàng.');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Tính tổng giá trị của các sản phẩm trong giỏ hàng.
   * Sử dụng useMemo để tối ưu hiệu suất.
   * @returns {number} Tổng giá trị.
   */
  const getCartTotal = useMemo(() => {
    if (!cart || !cart.cartProducts) return 0;
    return cart.cartProducts.reduce((total, item) => {
      // Sử dụng `item.productDetails.discount` (giá sau giảm) nếu có, nếu không thì dùng `item.productDetails.price` (giá gốc)
      const price = item.productDetails?.discount || item.productDetails?.price || 0;
      return total + (price * item.quantity);
    }, 0);
  }, [cart]);

  /**
   * Tính tổng số lượng sản phẩm (items) trong giỏ hàng.
   * Sử dụng useMemo để tối ưu hiệu suất.
   * @returns {number} Tổng số lượng.
   */
  const getCartCount = useMemo(() => {
    if (!cart || !cart.cartProducts) return 0;
    return cart.cartProducts.reduce((count, item) => count + item.quantity, 0);
  }, [cart]);


  const value = {
    cart, // CartResponse { id, userId, cartProducts: List<CartProductResponseWithDetails> }
    // CartProductResponseWithDetails: { id, cartId, productId, quantity, ..., productDetails: ProductResponse }
    isLoading,
    error,
    fetchCart, // Có thể dùng để refresh thủ công
    addProductToCart,
    updateCartItemQuantity,
    removeProductFromCartByProductId,
    clearCart,
    getCartTotal,
    getCartCount,
  };

  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
};

export const useCart = () => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};

export default CartContext;

/* ===== src\contexts\index.js ===== */
import {AuthProvider, useAuth} from './AuthContext';
import {CartProvider, useCart} from './CartContext';
import {NotificationProvider, useNotification} from './NotificationContext';

export {
    AuthProvider, CartProvider, NotificationProvider, useAuth, useCart, useNotification
};

const AppProviders = ({children}) => (<AuthProvider>
    <CartProvider>
        <NotificationProvider>
            {children}
        </NotificationProvider>
    </CartProvider>
</AuthProvider>);

export default AppProviders

/* ===== src\contexts\NotificationContext.js ===== */
/* ===== NotificationContext.js ===== */
// src/contexts/NotificationContext.js
import React, {createContext, useCallback, useContext, useEffect, useState} from 'react';
import {notificationService} from '../services';
import {useAuth} from './AuthContext';

const NotificationContext = createContext(null);

export const NotificationProvider = ({children}) => {
    const [notifications, setNotifications] = useState([]);
    const [unreadCount, setUnreadCount] = useState(0);
    const [isLoading, setIsLoading] = useState(false);
    const [loadingMore, setLoadingMore] = useState(false);
    const [error, setError] = useState(null);
    const {isAuthenticated, user} = useAuth();

    const [pageIndex, setPageIndex] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const pageSize = 15;

    useEffect(() => {
        const newUnreadCount = notifications.filter(n => !n.isRead).length;
        setUnreadCount(newUnreadCount);
    }, [notifications]);

    const fetchNotifications = useCallback(async (page = 1, isRefreshing = false) => {
        if (!isAuthenticated || !user) {
            setNotifications([]);
            setPageIndex(1);
            setTotalPages(1);
            setIsLoading(false);
            setLoadingMore(false);
            return;
        }
        if (loadingMore && !isRefreshing && page > 1) return;

        if (page === 1) setIsLoading(true); else if (!isRefreshing) setLoadingMore(true);
        setError(null);

        try {
            const response = await notificationService.getMyNotifications(page, pageSize);
            if (response && response.status === 200 && response.result) {
                const fetchedData = response.result.data || [];
                // Assuming each notification item in the list has an 'id' and 'status' ('READ'/'UNREAD')
                const newNotifications = fetchedData.map(n => ({
                    ...n, id: n.id, isRead: n.isRead,
                }));

                if (isRefreshing || page === 1) {
                    setNotifications(newNotifications);
                } else {
                    setNotifications(prev => {
                        const existingIds = new Set(prev.map(notif => notif.id)); // Use 'id'
                        const uniqueNewNotifications = newNotifications.filter(notif => !existingIds.has(notif.id));
                        return [...prev, ...uniqueNewNotifications];
                    });
                }
                setTotalPages(response.result.totalPages || 1);
                setPageIndex(page);
            } else {
                throw new Error(response?.message || "Không thể tải thông báo. Phản hồi không hợp lệ từ máy chủ.");
            }
        } catch (err) {
            console.error('Fetch notifications error:', err);
            setError(err.message);
            if (page === 1) setNotifications([]);
        } finally {
            setIsLoading(false);
            setLoadingMore(false);
        }
    }, [isAuthenticated, user, pageSize, loadingMore]);

    useEffect(() => {
        if (isAuthenticated) {
            fetchNotifications(1, true);
        } else {
            setNotifications([]);
            setUnreadCount(0);
            setPageIndex(1);
            setTotalPages(1);
            setError(null);
        }
    }, [isAuthenticated, fetchNotifications]);

    const deleteNotificationById = async (id) => { // Parameter changed to id
        if (!isAuthenticated) return false;
        setError(null);
        const originalNotifications = [...notifications];
        setNotifications(prev => prev.filter(n => n.id !== id)); // Use 'id'
        try {
            const response = await notificationService.deleteNotification(id); // Pass 'id'
            if (response && response.status === 200) {
                return true;
            } else {
                setNotifications(originalNotifications);
                throw new Error(response?.message || "Không thể xóa thông báo.");
            }
        } catch (err) {
            console.error('Delete notification error:', err);
            setError(err.message);
            setNotifications(originalNotifications);
            return false;
        }
    };

    const deleteAllNotifications = async () => {
        if (!isAuthenticated || notifications.length === 0) return false;
        setError(null);
        setIsLoading(true);
        const originalNotifications = [...notifications];
        setNotifications([]);
        setUnreadCount(0);
        try {
            const response = await notificationService.deleteAllNotifications();
            if (response && response.status === 200) {
                setPageIndex(1);
                setTotalPages(1);
                return true;
            } else {
                setNotifications(originalNotifications);
                throw new Error(response?.message || "Không thể xóa tất cả thông báo.");
            }
        } catch (err) {
            console.error('Delete all notifications error:', err);
            setError(err.message || 'Lỗi xóa tất cả thông báo.');
            setNotifications(originalNotifications);
            return false;
        } finally {
            setIsLoading(false);
        }
    };

    const markAsRead = async (id) => { // Parameter changed to id
        if (!isAuthenticated) return false;
        const originalNotifications = [...notifications];
        setNotifications(prev => prev.map(n => n.id === id ? {...n, isRead: true} : n // Use 'id'
        ));
        try {
            const response = await notificationService.markNotificationAsRead(id); // Pass 'id'
            if (response && response.status === 200 && response.result) {
                setNotifications(prev => prev.map(n => n.id === id // Use 'id'
                    ? {...response.result, isRead: true} // Use the backend's updated object, ensure isRead
                    : n));
                return true;
            } else {
                setNotifications(originalNotifications);
                throw new Error(response?.message || "Không thể đánh dấu đã đọc.");
            }
        } catch (err) {
            console.error('Mark notification as read error:', err);
            setError(err.message);
            setNotifications(originalNotifications);
            return false;
        }
    };

    const markAllAsRead = async () => {
        if (!isAuthenticated || notifications.filter(n => !n.isRead).length === 0) return false;
        setError(null);
        setIsLoading(true);
        const originalNotifications = [...notifications];
        setNotifications(prev => prev.map(n => ({...n, isRead: true})));
        try {
            const response = await notificationService.markAllNotificationsAsRead();
            console.log(response)
            if (response && response.status === 200) {
                // If API returns list of updated notifications, update state with them
                // For now, assuming optimistic update is sufficient
                return true;
            } else {
                setNotifications(originalNotifications);
                throw new Error(response?.message || "Không thể đánh dấu tất cả đã đọc.");
            }
        } catch (err) {
            console.error('Mark all notifications as read error:', err);
            setError(err.message);
            setNotifications(originalNotifications);
            return false;
        } finally {
            setIsLoading(false);
        }
    };

    const value = {
        notifications,
        unreadCount,
        isLoading,
        loadingMore,
        error,
        pageIndex,
        totalPages,
        fetchNotifications,
        deleteNotificationById,
        deleteAllNotifications,
        markAsRead,
        markAllAsRead,
    };

    return (<NotificationContext.Provider value={value}>
        {children}
    </NotificationContext.Provider>);
};

export const useNotification = () => {
    const context = useContext(NotificationContext);
    if (!context) {
        throw new Error('useNotification must be used within a NotificationProvider');
    }
    return context;
};

export default NotificationContext;


/* ===== src\screens\account\AccountScreen.jsx ===== */
import {useAuth} from '@/contexts/AuthContext';
import {customerService} from '@/services';
import {Feather, Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import {useRouter} from 'expo-router';
import React, {useEffect, useState} from 'react';
import {
    ActivityIndicator,
    Alert,
    Image,
    KeyboardAvoidingView,
    Modal,
    Platform,
    SafeAreaView,
    ScrollView,
    StyleSheet,
    Text,
    TextInput,
    TouchableOpacity,
    View
} from 'react-native';

import {dataURIToBlob} from '@/utils/imageUtils';

const DEFAULT_AVATAR_URL = 'https://placehold.co/200x200/E2E8F0/A0AEC0?text=User';
const FILE_DOWNLOAD_PREFIX = 'http://172.20.64.1:8888/api/v1/file/media/download/';

const OptionItem = ({
                        iconName,
                        iconType = "MaterialCommunityIcons",
                        title,
                        onPress,
                        isDestructive = false,
                        disabled = false
                    }) => {
    const IconComponent = iconType === "Ionicons" ? Ionicons : (iconType === "Feather" ? Feather : MaterialCommunityIcons);
    return (<TouchableOpacity
        onPress={onPress}
        disabled={disabled}
        className={`flex-row items-center bg-white p-4 border-b border-gray-100 ${disabled ? 'opacity-50' : 'active:bg-gray-50'}`}
    >
        <IconComponent name={iconName} size={22}
                       color={isDestructive ? "#EF4444" : (disabled ? "#9CA3AF" : "#4B5563")}/>
        <Text
            className={`flex-1 ml-4 text-base ${isDestructive ? 'text-red-600' : (disabled ? 'text-gray-400' : 'text-gray-700')}`}>
            {title}
        </Text>
        {!isDestructive && !disabled && <Ionicons name="chevron-forward-outline" size={20} color="#9CA3AF"/>}
    </TouchableOpacity>);
};

const InfoModal = ({visible, title, content, onClose}) => (<Modal
    animationType="slide"
    transparent={true}
    visible={visible}
    onRequestClose={onClose}
>
    <View style={styles.modalOverlay}>
        <View className="bg-white w-11/12 max-w-md p-6 rounded-xl shadow-xl">
            <View className="flex-row justify-between items-center mb-4">
                <Text className="text-xl font-bold text-sky-700">{title}</Text>
                <TouchableOpacity onPress={onClose} className="p-1">
                    <Ionicons name="close-circle" size={28} color="#6B7280"/>
                </TouchableOpacity>
            </View>
            <ScrollView style={{maxHeight: 300}}>
                <Text className="text-gray-700 text-base leading-relaxed">{content}</Text>
            </ScrollView>
            <TouchableOpacity
                onPress={onClose}
                className="mt-6 bg-sky-500 py-3 rounded-lg shadow active:bg-sky-600"
            >
                <Text className="text-white text-center font-semibold text-base">Đã hiểu</Text>
            </TouchableOpacity>
        </View>
    </View>
</Modal>);

const CustomerCareModal = ({visible, onClose, onSubmit, isLoading}) => {
    const [name, setName] = useState('');
    const [phone, setPhone] = useState('');
    const [email, setEmail] = useState('');
    const [address, setAddress] = useState('');
    const [content, setContent] = useState('');
    const [formError, setFormError] = useState('');

    const handleSubmit = () => {
        setFormError('');
        if (!name.trim() || !phone.trim() || !email.trim() || !content.trim()) {
            setFormError("Vui lòng điền đầy đủ các trường bắt buộc: Họ tên, SĐT, Email và Nội dung.");
            return;
        }
        // Basic email validation
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            setFormError("Địa chỉ email không hợp lệ.");
            return;
        }
        // Basic phone validation (example: 10 digits)
        const phoneRegex = /^\d{10}$/;
        if (!phoneRegex.test(phone)) {
            setFormError("Số điện thoại không hợp lệ (yêu cầu 10 chữ số).");
            return;
        }

        onSubmit({name, phone, email, address: address.trim(), content});
    };

    return (<Modal
        animationType="slide"
        transparent={true}
        visible={visible}
        onRequestClose={onClose}
    >
        <KeyboardAvoidingView
            behavior={Platform.OS === "ios" ? "padding" : "height"}
            style={styles.modalOverlay}
        >
            <View className="bg-white w-11/12 max-w-lg p-5 rounded-xl shadow-xl">
                <View className="flex-row justify-between items-center mb-4">
                    <Text className="text-xl font-bold text-sky-700">Gửi Yêu Cầu Hỗ Trợ</Text>
                    <TouchableOpacity onPress={onClose} className="p-1" disabled={isLoading}>
                        <Ionicons name="close-circle" size={28} color="#6B7280"/>
                    </TouchableOpacity>
                </View>
                <ScrollView style={{maxHeight: Platform.OS === 'ios' ? 400 : 350}}
                            keyboardShouldPersistTaps="handled">
                    {formError ? (<View className="bg-red-100 p-3 rounded-md mb-3">
                        <Text className="text-red-700 text-sm">{formError}</Text>
                    </View>) : null}
                    <View className="space-y-3">
                        <TextInput value={name} onChangeText={setName} placeholder="Họ và tên (*)"
                                   className="border border-gray-300 p-3 rounded-lg text-base bg-white"
                                   editable={!isLoading}/>
                        <TextInput value={phone} onChangeText={setPhone} placeholder="Số điện thoại (*)"
                                   keyboardType="phone-pad"
                                   className="border border-gray-300 p-3 rounded-lg text-base bg-white"
                                   editable={!isLoading}/>
                        <TextInput value={email} onChangeText={setEmail} placeholder="Email (*)"
                                   keyboardType="email-address" autoCapitalize="none"
                                   className="border border-gray-300 p-3 rounded-lg text-base bg-white"
                                   editable={!isLoading}/>
                        <TextInput value={address} onChangeText={setAddress} placeholder="Địa chỉ (Không bắt buộc)"
                                   className="border border-gray-300 p-3 rounded-lg text-base bg-white"
                                   editable={!isLoading}/>
                        <TextInput value={content} onChangeText={setContent} placeholder="Nội dung yêu cầu (*)"
                                   multiline numberOfLines={4}
                                   className="border border-gray-300 p-3 rounded-lg text-base h-28 bg-white"
                                   textAlignVertical="top" editable={!isLoading}/>
                    </View>
                </ScrollView>
                <TouchableOpacity
                    onPress={handleSubmit}
                    disabled={isLoading}
                    className={`mt-5 py-3 rounded-lg shadow ${isLoading ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}
                >
                    {isLoading ? <ActivityIndicator color="white"/> :
                        <Text className="text-white text-center font-semibold text-base">Gửi Yêu Cầu</Text>}
                </TouchableOpacity>
            </View>
        </KeyboardAvoidingView>
    </Modal>);
};


function AccountScreen() {
    const router = useRouter();
    const {user, logout, updateMyProfileImage, isLoading: authIsLoading} = useAuth();
    const [isUpdatingProfileImage, setIsUpdatingProfileImage] = useState(false);
    const [localUser, setLocalUser] = useState(user);

    const [customerCareModalVisible, setCustomerCareModalVisible] = useState(false);
    const [isSubmittingContact, setIsSubmittingContact] = useState(false);

    const [infoModalVisible, setInfoModalVisible] = useState(false);
    const [infoModalContent, setInfoModalContent] = useState({title: '', content: ''});


    useEffect(() => {
        setLocalUser(user);
    }, [user]);

    const requestMediaLibraryPermissions = async () => {
        if (Platform.OS !== 'web') {
            const {status} = await ImagePicker.requestMediaLibraryPermissionsAsync();
            if (status !== 'granted') {
                Alert.alert('Quyền truy cập bị từ chối', 'Rất tiếc, chúng tôi cần quyền truy cập thư viện ảnh để bạn có thể thay đổi ảnh đại diện!');
                return false;
            }
        }
        return true;
    };

    const handlePickImage = async () => {
        const hasPermission = await requestMediaLibraryPermissions();
        if (!hasPermission && Platform.OS !== 'web') {
            return;
        }

        try {
            let result = await ImagePicker.launchImageLibraryAsync({
                mediaTypes: ImagePicker.MediaTypeOptions.Images, allowsEditing: true, aspect: [1, 1], quality: 0.5,
            });

            if (!result.canceled && result.assets && result.assets.length > 0) {
                const pickedImage = result.assets[0];
                let fileInput;
                let finalFileName = pickedImage.fileName;
                let finalMimeType = pickedImage.mimeType;

                if (!finalFileName) {
                    const uriParts = pickedImage.uri.split('.');
                    const extension = uriParts.length > 1 ? uriParts[uriParts.length - 1].split('?')[0].split('#')[0] : 'jpg';
                    finalFileName = `profile-${Date.now()}.${extension}`;
                }

                if (Platform.OS === 'web' && pickedImage.uri.startsWith('data:')) {
                    const blob = dataURIToBlob(pickedImage.uri);
                    if (blob) {
                        fileInput = blob;
                        finalMimeType = blob.type;
                    } else {
                        Alert.alert("Lỗi xử lý ảnh", "Không thể chuyển đổi ảnh để tải lên.");
                        return;
                    }
                } else {
                    fileInput = pickedImage.uri;
                    if (!finalMimeType) {
                        const uriParts = pickedImage.uri.split('.');
                        const extension = uriParts.length > 1 ? uriParts[uriParts.length - 1].toLowerCase().split('?')[0].split('#')[0] : '';
                        if (extension === 'jpg' || extension === 'jpeg') finalMimeType = 'image/jpeg'; else if (extension === 'png') finalMimeType = 'image/png'; else if (extension) finalMimeType = `image/${extension}`; else finalMimeType = 'application/octet-stream';
                    }
                }

                const imageFilePayload = {
                    fileInput: fileInput, fileName: finalFileName, mimeType: finalMimeType,
                };

                setIsUpdatingProfileImage(true);
                const response = await updateMyProfileImage(imageFilePayload);

                if (response && response.status === 200) {
                    Alert.alert("Thành công", response.message || "Ảnh đại diện đã được cập nhật.");
                } else {
                    Alert.alert("Lỗi cập nhật ảnh", response?.message || "Không thể cập nhật ảnh đại diện. Vui lòng thử lại.");
                }
            }
        } catch (error) {
            Alert.alert("Lỗi nghiêm trọng", error?.message || "Đã có lỗi xảy ra khi chọn hoặc tải ảnh lên.");
        } finally {
            setIsUpdatingProfileImage(false);
        }
    };

    const handleSubmitCustomerCare = async (contactData) => {
        setIsSubmittingContact(true);
        try {
            const response = await customerService.createContact(contactData);
            console.log(response)
            if (response && response.status === 201) { // Assuming 201 for successful creation
                Alert.alert("Thành công", "Yêu cầu hỗ trợ của bạn đã được gửi đi.");
                setCustomerCareModalVisible(false);
            } else {
                Alert.alert("Lỗi", response?.message || "Không thể gửi yêu cầu. Vui lòng thử lại.");
            }
        } catch (error) {
            Alert.alert("Lỗi", error?.message || "Đã xảy ra lỗi khi gửi yêu cầu hỗ trợ.");
        } finally {
            setIsSubmittingContact(false);
        }
    };


    const handleOpenInfoModal = (title, content) => {
        setInfoModalContent({title, content});
        setInfoModalVisible(true);
    };


    const handleEditProfile = () => router.push('/(app)/account/edit-profile');
    const handleOrderHistory = () => router.push('/(app)/account/order-history/');
    const handleShippingAddresses = () => router.push('/(app)/account/addresses');
    const handleChangePassword = () => router.push('/(app)/account/change-password');
    const handleNotificationSettings = () => router.push('/(app)/notification');

    const handleHelpCenter = () => handleOpenInfoModal("Trung Tâm Trợ Giúp", "Chào mừng bạn đến với Trung tâm Trợ giúp của BookStore!\n\n" + "Tại đây, bạn có thể tìm thấy câu trả lời cho các câu hỏi thường gặp về:\n" + "- Cách đặt hàng và thanh toán.\n" + "- Chính sách vận chuyển và giao nhận.\n" + "- Quy định đổi trả hàng hóa.\n" + "- Các vấn đề kỹ thuật và tài khoản.\n\n" + "Nếu không tìm thấy thông tin cần thiết, vui lòng liên hệ với chúng tôi qua mục 'Chăm sóc khách hàng' hoặc hotline 1900 1009.\n\n" + "Chúng tôi luôn sẵn sàng hỗ trợ bạn!");

    const handleAboutApp = () => handleOpenInfoModal("Về Ứng Dụng BookStore", "BookStore App - Phiên bản 1.0.0\n\n" + "© 2025 BookStore Inc. Mọi quyền được bảo lưu.\n\n" + "BookStore là ứng dụng mua sắm sách trực tuyến hàng đầu, mang đến cho bạn hàng ngàn đầu sách thuộc mọi thể loại với giá cả cạnh tranh và dịch vụ giao hàng nhanh chóng, tiện lợi.\n\n" + "Tính năng nổi bật:\n" + "- Tìm kiếm sách dễ dàng.\n" + "- Đặt hàng và thanh toán an toàn.\n" + "- Theo dõi đơn hàng trực tuyến.\n" + "- Nhận thông báo về sách mới và khuyến mãi.\n\n" + "Cảm ơn bạn đã tin tưởng và sử dụng BookStore!");

    const handleTermsAndPolicies = () => handleOpenInfoModal("Chính Sách & Điều Khoản", "Chào mừng bạn đến với các điều khoản và chính sách của BookStore.\n\n" + "1. Điều khoản sử dụng:\n" + "   - Vui lòng đọc kỹ các điều khoản trước khi sử dụng ứng dụng...\n\n" + "2. Chính sách bảo mật:\n" + "   - Chúng tôi cam kết bảo vệ thông tin cá nhân của bạn...\n\n" + "3. Chính sách đổi trả:\n" + "   - Sản phẩm được đổi trả trong vòng 7 ngày nếu có lỗi từ nhà sản xuất...\n\n" + "4. Chính sách vận chuyển:\n" + "   - Miễn phí vận chuyển cho đơn hàng từ 200.000đ...\n\n" + "Để biết thêm chi tiết, vui lòng truy cập website của chúng tôi hoặc liên hệ bộ phận hỗ trợ.");


    const handleLogout = () => {
        Alert.alert("Xác nhận Đăng xuất", "Bạn có chắc chắn muốn đăng xuất khỏi tài khoản này?", [{
            text: "Hủy", style: "cancel"
        }, {text: "Đăng xuất", onPress: async () => await logout(), style: "destructive"}]);
    };

    const accountOptions = [{
        title: "Chỉnh sửa thông tin", iconName: "account-edit-outline", onPress: handleEditProfile
    }, {title: "Lịch sử đơn hàng", iconName: "history", onPress: handleOrderHistory}, {
        title: "Địa chỉ giao hàng", iconName: "map-marker-outline", onPress: handleShippingAddresses
    }, {title: "Đổi mật khẩu", iconName: "lock-reset", onPress: handleChangePassword}, {
        title: "Cài đặt thông báo", iconName: "bell-outline", onPress: handleNotificationSettings
    },];

    const supportOptions = [{
        title: "Chăm sóc khách hàng", iconName: "face-agent", onPress: () => setCustomerCareModalVisible(true)
    }, {title: "Trung tâm trợ giúp", iconName: "help-circle-outline", onPress: handleHelpCenter}, {
        title: "Về ứng dụng", iconName: "information-outline", onPress: handleAboutApp
    }, {title: "Chính sách & Điều khoản", iconName: "shield-check-outline", onPress: handleTermsAndPolicies},];

    if (authIsLoading && !localUser) {
        return (<SafeAreaView className="flex-1 justify-center items-center bg-slate-100">
            <ActivityIndicator size="large" color="#0EA5E9"/>
        </SafeAreaView>);
    }

    const displayName = localUser?.username || localUser?.email || "Người dùng";
    const displayEmail = localUser?.email || "Không có email";
    const profileImageUrlToDisplay = localUser?.profileImage ? (localUser.profileImage.startsWith('http') ? localUser.profileImage : `${FILE_DOWNLOAD_PREFIX}${localUser.profileImage}`) : DEFAULT_AVATAR_URL;

    return (<SafeAreaView className="flex-1 bg-slate-100">
        <ScrollView showsVerticalScrollIndicator={false}>
            <View className="bg-sky-500 p-6 pt-10 items-center">
                <TouchableOpacity onPress={handlePickImage} disabled={isUpdatingProfileImage || authIsLoading}>
                    <Image
                        source={{uri: profileImageUrlToDisplay}}
                        className="w-24 h-24 rounded-full border-4 border-sky-400"
                        onError={(e) => console.warn("Failed to load profile image:", e.nativeEvent.error, profileImageUrlToDisplay)}
                    />
                    {isUpdatingProfileImage && (
                        <View className="absolute inset-0 justify-center items-center bg-black/30 rounded-full">
                            <ActivityIndicator color="#FFFFFF"/>
                        </View>)}
                </TouchableOpacity>
                <Text className="text-2xl font-bold text-white mt-3">{displayName}</Text>
                <Text className="text-sm text-sky-100 mt-1">{displayEmail}</Text>
            </View>

            <View className="mt-5">
                <Text className="text-xs font-semibold text-gray-500 uppercase px-4 pb-1">Tài khoản</Text>
                <View className="bg-white rounded-lg shadow-sm mx-2 overflow-hidden">
                    {accountOptions.map((item, index) => (<OptionItem key={index} {...item}
                                                                      disabled={(isUpdatingProfileImage || authIsLoading) && item.onPress !== handleEditProfile}/>))}
                </View>
            </View>

            <View className="mt-5">
                <Text className="text-xs font-semibold text-gray-500 uppercase px-4 pb-1">Hỗ trợ & Pháp lý</Text>
                <View className="bg-white rounded-lg shadow-sm mx-2 overflow-hidden">
                    {supportOptions.map((item, index) => (<OptionItem key={index} {...item}
                                                                      disabled={isUpdatingProfileImage || authIsLoading || isSubmittingContact}/>))}
                </View>
            </View>

            <View className="mt-6 mb-8 mx-2">
                <View className="bg-white rounded-lg shadow-sm overflow-hidden">
                    <OptionItem
                        iconName="log-out"
                        iconType="Feather"
                        title="Đăng xuất"
                        onPress={handleLogout}
                        isDestructive
                        disabled={isUpdatingProfileImage || authIsLoading || isSubmittingContact}
                    />
                </View>
            </View>
        </ScrollView>

        <CustomerCareModal
            visible={customerCareModalVisible}
            onClose={() => setCustomerCareModalVisible(false)}
            onSubmit={handleSubmitCustomerCare}
            isLoading={isSubmittingContact}
        />
        <InfoModal
            visible={infoModalVisible}
            title={infoModalContent.title}
            content={infoModalContent.content}
            onClose={() => setInfoModalVisible(false)}
        />

    </SafeAreaView>);
}

const styles = StyleSheet.create({
    modalOverlay: {
        flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center',
    },
});

export default AccountScreen;


/* ===== src\screens\account\ChangePasswordScreen.jsx ===== */
/* ===== src/screens/account/ChangePasswordScreen.jsx ===== */
import React, { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, ScrollView, SafeAreaView, ActivityIndicator, Alert } from 'react-native';
import { useAuth } from '@/contexts/AuthContext'; // Assuming updateMyPassword is in AuthContext
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';

function ChangePasswordScreen() {
    const { updateMyPassword, isLoading: authLoading } = useAuth();
    const router = useRouter();

    const [oldPassword, setOldPassword] = useState('');
    const [newPassword, setNewPassword] = useState('');
    const [confirmNewPassword, setConfirmNewPassword] = useState('');

    const [showOldPassword, setShowOldPassword] = useState(false);
    const [showNewPassword, setShowNewPassword] = useState(false);
    const [showConfirmNewPassword, setShowConfirmNewPassword] = useState(false);

    const [isSubmitting, setIsSubmitting] = useState(false);

    const handleChangePassword = async () => {
        if (!oldPassword.trim() || !newPassword.trim() || !confirmNewPassword.trim()) {
            Alert.alert("Lỗi", "Vui lòng nhập đầy đủ các trường mật khẩu.");
            return;
        }
        if (newPassword !== confirmNewPassword) {
            Alert.alert("Lỗi", "Mật khẩu mới và xác nhận mật khẩu không khớp.");
            return;
        }
        if (newPassword.length < 6) { // Example: Minimum password length
            Alert.alert("Lỗi", "Mật khẩu mới phải có ít nhất 6 ký tự.");
            return;
        }

        setIsSubmitting(true);
        try {
            // updateMyPassword from AuthContext should handle calling identityService.updateMyPassword
            const response = await updateMyPassword(oldPassword, newPassword);

            if (response && response.status === 200) { // Check based on your API's success response
                Alert.alert("Thành công", "Mật khẩu đã được thay đổi. Vui lòng đăng nhập lại nếu được yêu cầu.");
                // Optionally logout user or navigate them
                // router.back(); // Go back to account screen
                // Or, if API requires re-login after password change:
                // await logout(); 
                // router.replace('/(auth)/login');
                setOldPassword('');
                setNewPassword('');
                setConfirmNewPassword('');
            } else {
                Alert.alert("Lỗi", response?.message || "Không thể đổi mật khẩu. Vui lòng kiểm tra lại mật khẩu cũ.");
            }
        } catch (error) {
            console.error("Change password error:", error);
            Alert.alert("Lỗi", error?.message || "Đã xảy ra lỗi khi đổi mật khẩu.");
        } finally {
            setIsSubmitting(false);
        }
    };

    if (authLoading && !isSubmitting) { // Show general auth loading if not specifically submitting form
        return <View className="flex-1 justify-center items-center"><ActivityIndicator size="large" color="#0EA5E9" /></View>;
    }

    return (
        <SafeAreaView className="flex-1 bg-slate-100">
            <ScrollView className="flex-1" contentContainerStyle={{ paddingBottom: 20 }}>
                <View className="p-5 space-y-5">
                    <Text className="text-xl font-semibold text-gray-700 mb-2">Thay đổi mật khẩu</Text>

                    {/* Old Password */}
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Mật khẩu cũ</Text>
                        <View className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3.5 focus-within:border-sky-500">
                            <Ionicons name="lock-closed-outline" size={20} color="#6B7280" className="mr-2" />
                            <TextInput
                                className="flex-1 text-base text-gray-800"
                                placeholder="Nhập mật khẩu cũ"
                                value={oldPassword}
                                onChangeText={setOldPassword}
                                secureTextEntry={!showOldPassword}
                                editable={!isSubmitting}
                            />
                            <TouchableOpacity onPress={() => setShowOldPassword(!showOldPassword)}>
                                <Ionicons name={showOldPassword ? "eye-off-outline" : "eye-outline"} size={24} color="#6B7280" />
                            </TouchableOpacity>
                        </View>
                    </View>

                    {/* New Password */}
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Mật khẩu mới</Text>
                        <View className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3.5 focus-within:border-sky-500">
                            <Ionicons name="key-outline" size={20} color="#6B7280" className="mr-2" />
                            <TextInput
                                className="flex-1 text-base text-gray-800"
                                placeholder="Nhập mật khẩu mới (ít nhất 6 ký tự)"
                                value={newPassword}
                                onChangeText={setNewPassword}
                                secureTextEntry={!showNewPassword}
                                editable={!isSubmitting}
                            />
                            <TouchableOpacity onPress={() => setShowNewPassword(!showNewPassword)}>
                                <Ionicons name={showNewPassword ? "eye-off-outline" : "eye-outline"} size={24} color="#6B7280" />
                            </TouchableOpacity>
                        </View>
                    </View>

                    {/* Confirm New Password */}
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Xác nhận mật khẩu mới</Text>
                        <View className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3.5 focus-within:border-sky-500">
                            <Ionicons name="key-outline" size={20} color="#6B7280" className="mr-2" />
                            <TextInput
                                className="flex-1 text-base text-gray-800"
                                placeholder="Nhập lại mật khẩu mới"
                                value={confirmNewPassword}
                                onChangeText={setConfirmNewPassword}
                                secureTextEntry={!showConfirmNewPassword}
                                editable={!isSubmitting}
                            />
                            <TouchableOpacity onPress={() => setShowConfirmNewPassword(!showConfirmNewPassword)}>
                                <Ionicons name={showConfirmNewPassword ? "eye-off-outline" : "eye-outline"} size={24} color="#6B7280" />
                            </TouchableOpacity>
                        </View>
                    </View>

                    <TouchableOpacity
                        onPress={handleChangePassword}
                        disabled={isSubmitting || authLoading}
                        className={`py-4 rounded-lg shadow-md mt-5 ${isSubmitting || authLoading ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}
                    >
                        {isSubmitting ? (
                            <ActivityIndicator color="#FFFFFF" />
                        ) : (
                            <Text className="text-white text-center text-lg font-semibold">Lưu Mật Khẩu</Text>
                        )}
                    </TouchableOpacity>
                </View>
            </ScrollView>
        </SafeAreaView>
    );
}

export default ChangePasswordScreen;

/* ===== src\screens\account\EditProfileScreen.jsx ===== */

/* ===== src/screens/account/EditProfileScreen.jsx ===== */
import { useAuth } from '@/contexts/AuthContext';
import React, { useEffect, useState } from 'react';
import { ActivityIndicator, Alert, SafeAreaView, ScrollView, Text, TextInput, TouchableOpacity, View } from 'react-native';

// This screen will manage editing user's full name, phone, gender from the `Profiles` table.
// The `UserResponse` from `identityService` (in `AuthContext.user`) mainly has `username, email, profileImage`.
// We might need a separate fetch for the detailed profile if not already combined.
// For now, we'll focus on email update (via AuthContext) and placeholders for other fields.

function EditProfileScreen() {
    const { user, updateMyEmail, isLoading: authLoading } = useAuth();
    const [email, setEmail] = useState(user?.email || '');
    // Add states for other profile fields if you fetch/update them
    // e.g., const [fullName, setFullName] = useState('');
    // const [phone, setPhone] = useState('');

    const [isSubmitting, setIsSubmitting] = useState(false);
    const [screenLoading, setScreenLoading] = useState(true);
    const [userProfile, setUserProfile] = useState(null); // For detailed profile from /profile/my-profile

    useEffect(() => {
        if (user) {
            setEmail(user.email || '');
            // Fetch detailed shipping profile if needed
            const fetchProfileDetails = async () => {
                try {
                    // Assuming getMyShippingProfiles returns a PageResponse<ProfileResponse>
                    // And we might want the first/default profile or allow selection.
                    // For simplicity, let's assume we can get a primary profile.
                    // This part needs to be adjusted based on your actual API for fetching *the* user's profile details.
                    // If profileService.getMyInfo already contains everything, this fetch is not needed.
                    // Based on current profileService, there isn't a single "get my full profile" endpoint.
                    // We'll simulate or use placeholder for now for fullName, phone.
                    // const profileResponse = await profileService.getMyShippingProfiles({ pageIndex: 1, pageSize: 1 });
                    // if (profileResponse && profileResponse.result && profileResponse.result.data.length > 0) {
                    //     const mainProfile = profileResponse.result.data[0];
                    //     setFullName(mainProfile.fullName || '');
                    //     setPhone(mainProfile.phone || '');
                    //     // setGender(mainProfile.gender || '');
                    // }
                    setScreenLoading(false);
                } catch (error) {
                    console.error("Failed to fetch profile details:", error);
                    Alert.alert("Lỗi", "Không thể tải thông tin chi tiết hồ sơ.");
                    setScreenLoading(false);
                }
            };
            fetchProfileDetails();
        } else {
            setScreenLoading(false);
        }
    }, [user]);


    const handleSaveChanges = async () => {
        if (!email.trim()) {
            Alert.alert("Lỗi", "Email không được để trống.");
            return;
        }
        // Add validation for other fields if they are being edited.

        setIsSubmitting(true);
        try {
            // Update email via AuthContext
            if (email !== user?.email) {
                const emailUpdateResponse = await updateMyEmail(email); // updateMyEmail is from AuthContext
                if (!emailUpdateResponse || emailUpdateResponse.status !== 200) {
                    Alert.alert("Lỗi cập nhật Email", emailUpdateResponse?.message || "Không thể cập nhật email.");
                    setIsSubmitting(false);
                    return;
                }
            }

            // TODO: Update other profile details (fullName, phone) using profileService.updateShippingProfile
            // This would require knowing the profileId.
            // Example:
            // if (userProfile && (fullName !== userProfile.fullName || phone !== userProfile.phone)) {
            //    await profileService.updateShippingProfile(userProfile.id, { fullName, phone, address: userProfile.address, gender: userProfile.gender });
            // }

            Alert.alert("Thành công", "Thông tin cá nhân đã được cập nhật.");
            // Optionally navigate back or refresh data
        } catch (error) {
            console.error("Save profile error:", error);
            Alert.alert("Lỗi", error?.message || "Không thể lưu thay đổi. Vui lòng thử lại.");
        } finally {
            setIsSubmitting(false);
        }
    };

    if (screenLoading || (authLoading && !user)) {
        return <View className="flex-1 justify-center items-center"><ActivityIndicator size="large" color="#0EA5E9" /></View>;
    }

    return (
        <SafeAreaView className="flex-1 bg-slate-100">
            <ScrollView className="flex-1" contentContainerStyle={{ paddingBottom: 20 }}>
                <View className="p-5 space-y-5">
                    {/* Username (Display only) */}
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Tên đăng nhập</Text>
                        <TextInput
                            className="bg-gray-200 text-gray-700 p-3.5 rounded-lg text-base"
                            value={user?.username || ''}
                            editable={false} // Username usually not editable by user directly
                        />
                    </View>

                    {/* Email */}
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Email</Text>
                        <TextInput
                            className="bg-white border border-gray-300 text-gray-800 p-3.5 rounded-lg text-base focus:border-sky-500 focus:ring-1 focus:ring-sky-500"
                            placeholder="Nhập email của bạn"
                            value={email}
                            onChangeText={setEmail}
                            keyboardType="email-address"
                            autoCapitalize="none"
                            editable={!isSubmitting}
                        />
                    </View>

                    {/* Placeholder for Full Name - requires profileService integration */}
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Họ và Tên (Chức năng đang phát triển)</Text>
                        <TextInput
                            className="bg-gray-200 text-gray-700 p-3.5 rounded-lg text-base"
                            placeholder="Nguyễn Văn A"
                            // value={fullName}
                            // onChangeText={setFullName}
                            editable={false} // Enable when profileService for this is integrated
                        />
                    </View>

                    {/* Placeholder for Phone - requires profileService integration */}
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Số điện thoại (Chức năng đang phát triển)</Text>
                        <TextInput
                            className="bg-gray-200 text-gray-700 p-3.5 rounded-lg text-base"
                            placeholder="09xxxxxxxx"
                            // value={phone}
                            // onChangeText={setPhone}
                            keyboardType="phone-pad"
                            editable={false} // Enable when profileService for this is integrated
                        />
                    </View>

                    <TouchableOpacity
                        onPress={handleSaveChanges}
                        disabled={isSubmitting || authLoading}
                        className={`py-4 rounded-lg shadow-md mt-5 ${isSubmitting || authLoading ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}
                    >
                        {isSubmitting ? (
                            <ActivityIndicator color="#FFFFFF" />
                        ) : (
                            <Text className="text-white text-center text-lg font-semibold">Lưu Thay Đổi</Text>
                        )}
                    </TouchableOpacity>
                </View>
            </ScrollView>
        </SafeAreaView>
    );
}

export default EditProfileScreen;


/* ===== src\screens\account\OrderDetailScreen.jsx ===== */
import {orderService, productService} from '@/services';
import {FontAwesome, Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import {useRouter} from 'expo-router';
import React, {useCallback, useEffect, useState} from 'react';
import {
    ActivityIndicator,
    Alert,
    KeyboardAvoidingView,
    Modal,
    Platform,
    SafeAreaView,
    ScrollView,
    StyleSheet,
    Text,
    TextInput,
    TouchableOpacity,
    View,
    Image
} from 'react-native';
import {useAuth} from '@/contexts/AuthContext';

const OrderStatusMapping = {
    0: {
        text: 'Đã giao hàng',
        color: 'text-green-600',
        bg: 'bg-green-100',
        icon: 'package-variant-closed-check',
        isDelivered: true
    },
    1: {text: 'Chờ xác nhận', color: 'text-amber-600', bg: 'bg-amber-100', icon: 'timer-sand-outline'},
    2: {text: 'Chờ vận chuyển', color: 'text-blue-600', bg: 'bg-blue-100', icon: 'package-variant'},
    3: {text: 'Đang vận chuyển', color: 'text-indigo-600', bg: 'bg-indigo-100', icon: 'truck-delivery-outline'},
    4: {
        text: 'Đã giao', color: 'text-green-600', bg: 'bg-green-100', icon: 'check-decagram-outline', isDelivered: true
    },
    5: {text: 'Đã hủy', color: 'text-red-600', bg: 'bg-red-100', icon: 'cancel'},
    default: {text: 'Không xác định', color: 'text-gray-600', bg: 'bg-gray-100', icon: 'help-circle-outline'},
};

const PaymentMethodMapping = {
    0: {text: 'Thanh toán khi nhận hàng (COD)', icon: 'cash-multiple'},
    1: {text: 'Thanh toán qua VNPay', icon: 'credit-card-outline'},
    2: {text: 'Thanh toán qua MoMo', icon: 'cellphone-marker'},
    default: {text: 'Khác', icon: 'help-circle-outline'}
};

const PaymentStatusMapping = {
    0: {text: 'Đã thanh toán', color: 'text-green-600', icon: 'check-circle-outline'},
    1: {text: 'Chưa thanh toán', color: 'text-amber-600', icon: 'alert-circle-outline'},
    2: {text: 'Đã hoàn tiền', color: 'text-blue-600', icon: 'cash-refund'},
    3: {text: 'Thanh toán thất bại', color: 'text-red-500', icon: 'close-circle-outline'},
    default: {text: 'Không xác định', color: 'text-gray-500', icon: 'help-circle-outline'},
};

const StarRatingInput = ({rating, setRating, disabled}) => {
    return (<View className="flex-row justify-center my-3">
        {[1, 2, 3, 4, 5].map((star) => (
            <TouchableOpacity key={star} onPress={() => !disabled && setRating(star)} disabled={disabled}>
                <FontAwesome
                    name={star <= rating ? "star" : "star-o"}
                    size={32}
                    color={star <= rating ? "#FFC107" : "#CBD5E1"}
                    style={{marginRight: 10}}
                />
            </TouchableOpacity>))}
    </View>);
};

const ProductRatingModal = ({
                                visible,
                                onClose,
                                onSubmit,
                                productInfo,
                                initialRating = 0,
                                initialComment = '',
                                isLoading
                            }) => {
    const [rating, setRating] = useState(initialRating);
    const [comment, setComment] = useState(initialComment);
    const [formError, setFormError] = useState('');

    useEffect(() => {
        if (visible) {
            setRating(initialRating || 0);
            setComment(initialComment || '');
            setFormError('');
        }
    }, [visible, initialRating, initialComment]);

    const handleSubmit = () => {
        setFormError('');
        if (rating === 0) {
            setFormError("Vui lòng chọn số sao đánh giá.");
            return;
        }
        if (!comment.trim()) {
            setFormError("Vui lòng nhập bình luận của bạn.");
            return;
        }
        onSubmit(productInfo?.productId, rating, comment);
    };

    if (!productInfo) return null;

    return (<Modal
        animationType="slide"
        transparent={true}
        visible={visible}
        onRequestClose={onClose}
    >
        <KeyboardAvoidingView
            behavior={Platform.OS === "ios" ? "padding" : "height"}
            style={styles.modalOverlay}
        >
            <View className="bg-white w-11/12 max-w-lg p-5 rounded-xl shadow-xl">
                <View className="flex-row justify-between items-center mb-3">
                    <Text className="text-xl font-bold text-sky-700">Đánh giá sản phẩm</Text>
                    <TouchableOpacity onPress={onClose} className="p-1" disabled={isLoading}>
                        <Ionicons name="close-circle" size={28} color="#6B7280"/>
                    </TouchableOpacity>
                </View>
                <ScrollView style={{maxHeight: Platform.OS === 'ios' ? 450 : 400}}
                            keyboardShouldPersistTaps="handled">
                    <View className="items-center mb-3">
                        <Image source={{uri: productInfo.thumbnail || 'https://placehold.co/100x120'}}
                               className="w-20 h-28 rounded-md mb-2"/>
                        <Text className="text-base font-semibold text-gray-800 text-center"
                              numberOfLines={2}>{productInfo.productName}</Text>
                    </View>

                    {formError ? (<View className="bg-red-100 p-2.5 rounded-md mb-3">
                        <Text className="text-red-700 text-sm text-center">{formError}</Text>
                    </View>) : null}

                    <StarRatingInput rating={rating} setRating={setRating} disabled={isLoading}/>
                    <TextInput
                        value={comment}
                        onChangeText={setComment}
                        placeholder="Viết bình luận của bạn ở đây..."
                        multiline
                        numberOfLines={4}
                        className="border border-gray-300 p-3 rounded-lg text-base h-28 bg-white mt-2"
                        textAlignVertical="top"
                        editable={!isLoading}
                    />
                </ScrollView>
                <TouchableOpacity
                    onPress={handleSubmit}
                    disabled={isLoading}
                    className={`mt-5 py-3 rounded-lg shadow ${isLoading ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}
                >
                    {isLoading ? <ActivityIndicator color="white"/> :
                        <Text className="text-white text-center font-semibold text-base">Gửi Đánh Giá</Text>}
                </TouchableOpacity>
            </View>
        </KeyboardAvoidingView>
    </Modal>);
};


const OrderProductItem = ({item, onRatePress, orderStatusIsDelivered, userRating}) => (
    <View className="bg-slate-50 p-3 my-1.5 rounded-md border border-slate-200">
        <View className="flex-row items-center">
            <View className="w-16 h-20 rounded mr-3 bg-gray-200 items-center justify-center">
                <Image source={{uri: item.thumbnail || 'https://placehold.co/64x80'}} className="w-full h-full rounded"
                       resizeMode="cover"/>
            </View>
            <View className="flex-1">
                <Text className="text-sm font-medium text-gray-800" numberOfLines={2}>{item.productName}</Text>
                <Text className="text-xs text-gray-500 mt-0.5">Số lượng: {item.quantity}</Text>
                <Text className="text-xs text-gray-500">Đơn giá: {item.price?.toLocaleString('vi-VN')}₫</Text>
            </View>
            <Text className="text-sm font-semibold text-sky-700 ml-2">
                {(item.price * item.quantity).toLocaleString('vi-VN')}₫
            </Text>
        </View>
        {orderStatusIsDelivered && (<TouchableOpacity
            onPress={() => onRatePress(item)}
            className="mt-2 bg-sky-100 py-1.5 px-3 rounded-md self-start active:bg-sky-200"
        >
            <Text className="text-sky-600 font-medium text-xs">
                {userRating ? "Sửa đánh giá" : "Đánh giá sản phẩm"}
            </Text>
        </TouchableOpacity>)}
    </View>);

const InfoRow = ({icon, label, value, valueColor = 'text-gray-800', children}) => (
    <View className="flex-row items-start py-2 border-b border-slate-100">
        <MaterialCommunityIcons name={icon} size={20} color="#4B5563" className="mr-3 mt-0.5"/>
        <Text className="w-2/5 text-sm text-gray-600">{label}:</Text>
        {value !== undefined && <Text className={`flex-1 text-sm font-medium ${valueColor}`}>{value || 'N/A'}</Text>}
        {children}
    </View>);

function OrderDetailScreen({orderId}) {
    const {user} = useAuth();
    const [order, setOrder] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [isCancelling, setIsCancelling] = useState(false);
    const [error, setError] = useState(null);
    const router = useRouter();

    const [ratingModalVisible, setRatingModalVisible] = useState(false);
    const [selectedProductToRate, setSelectedProductToRate] = useState(null);
    const [isSubmittingRating, setIsSubmittingRating] = useState(false);
    const [userRatings, setUserRatings] = useState({}); // Stores { productId: rateObject }
    const [editingRateId, setEditingRateId] = useState(null);
    const [initialRatingForModal, setInitialRatingForModal] = useState(0);
    const [initialCommentForModal, setInitialCommentForModal] = useState('');


    const fetchOrderAndRatings = useCallback(async () => {
        if (!orderId) {
            setError("ID đơn hàng không hợp lệ.");
            setIsLoading(false);
            return;
        }
        setIsLoading(true);
        setError(null);
        try {
            const response = await orderService.getMyOrderById(orderId);
            if (response && response.status === 200 && response.result) {
                const fetchedOrder = response.result;
                setOrder(fetchedOrder);

                if (fetchedOrder.orderProducts && fetchedOrder.orderProducts.length > 0 && user?.id) {
                    const ratingsMap = {};
                    for (const productItem of fetchedOrder.orderProducts) {
                        try {
                            // Fetch all ratings for a product to find the current user's one
                            // Adjust pageSize if a user can have many ratings (though unlikely for this model)
                            const ratesResponse = await productService.getRatesByProductId(productItem.productId, 1, 100);
                            if (ratesResponse && ratesResponse.status === 200 && ratesResponse.result && ratesResponse.result.data) {
                                const currentUserRating = ratesResponse.result.data.find(rate => rate.userId === parseInt(user.id) // Ensure user.id is compared as a number
                                );
                                if (currentUserRating) {
                                    ratingsMap[productItem.productId] = currentUserRating;
                                }
                            }
                        } catch (rateError) {
                            console.warn(`Could not fetch ratings for product ${productItem.productId}:`, rateError);
                        }
                    }
                    setUserRatings(ratingsMap);
                }
            } else {
                throw new Error(response?.message || "Không thể tải chi tiết đơn hàng.");
            }
        } catch (err) {
            setError(err.message || "Đã có lỗi xảy ra.");
        } finally {
            setIsLoading(false);
        }
    }, [orderId, user?.id]);

    useEffect(() => {
        fetchOrderAndRatings();
    }, [fetchOrderAndRatings]);

    const handleCancelOrder = async () => {
        if (!order) return;
        Alert.alert("Xác nhận hủy đơn hàng", "Bạn có chắc chắn muốn hủy đơn hàng này không? Hành động này không thể hoàn tác.", [{
            text: "Không",
            style: "cancel"
        }, {
            text: "Có, hủy đơn", onPress: async () => {
                setIsCancelling(true);
                try {
                    const response = await orderService.cancelOrder(order.id, {note: "Khách hàng tự hủy đơn."});
                    if (response && response.status === 200) {
                        Alert.alert("Thành công", response.message || "Đơn hàng đã được hủy.");
                        fetchOrderAndRatings();
                    } else {
                        Alert.alert("Lỗi hủy đơn", response?.message || "Không thể hủy đơn hàng.");
                    }
                } catch (err) {
                    Alert.alert("Lỗi hủy đơn", err?.message || "Đã xảy ra lỗi khi cố gắng hủy đơn hàng.");
                } finally {
                    setIsCancelling(false);
                }
            }, style: "destructive",
        },]);
    };

    const handleOpenRatingModal = (productItem) => {
        setSelectedProductToRate(productItem);
        const existingRating = userRatings[productItem.productId];
        if (existingRating) {
            setEditingRateId(existingRating.id);
            setInitialRatingForModal(existingRating.vote);
            setInitialCommentForModal(existingRating.comment);
        } else {
            setEditingRateId(null);
            setInitialRatingForModal(0);
            setInitialCommentForModal('');
        }
        setRatingModalVisible(true);
    };

    const handleSubmitRating = async (productId, vote, comment) => {
        setIsSubmittingRating(true);
        try {
            if (editingRateId) {
                // Delete the old rating first
                const deleteResponse = await productService.deleteRate(editingRateId);
                if (!deleteResponse || deleteResponse.status !== 200) { // Adjust status check as per your API
                    Alert.alert("Lỗi", "Không thể xóa đánh giá cũ. Vui lòng thử lại.");
                    setIsSubmittingRating(false);
                    return;
                }
            }

            const rateData = {productId, vote, comment};
            const response = await productService.createRate(rateData);

            if (response && response.status === 201) {
                Alert.alert("Thành công", "Cảm ơn bạn đã đánh giá sản phẩm!");
                setRatingModalVisible(false);
                fetchOrderAndRatings(); // Refresh to show updated rating status
            } else {
                Alert.alert("Lỗi", response?.message || "Không thể gửi đánh giá. Vui lòng thử lại.");
            }
        } catch (err) {
            Alert.alert("Lỗi", err?.message || "Đã xảy ra lỗi khi gửi đánh giá.");
        } finally {
            setIsSubmittingRating(false);
            setEditingRateId(null); // Reset editing state
        }
    };

    if (isLoading) {
        return <View className="flex-1 justify-center items-center bg-slate-50"><ActivityIndicator size="large"
                                                                                                   color="#0EA5E9"/></View>;
    }

    if (error) {
        return (<SafeAreaView className="flex-1 justify-center items-center bg-slate-100 p-5">
            <Ionicons name="alert-circle-outline" size={70} color="#F87171"/>
            <Text className="text-xl font-semibold text-gray-700 mt-4">Lỗi tải đơn hàng</Text>
            <Text className="text-gray-500 mt-1 text-center mb-3">{error}</Text>
            <TouchableOpacity onPress={fetchOrderAndRatings}
                              className="bg-sky-500 px-5 py-2.5 rounded-lg shadow active:bg-sky-600">
                <Text className="text-white font-medium">Thử lại</Text>
            </TouchableOpacity>
        </SafeAreaView>);
    }

    if (!order) {
        return <View className="flex-1 justify-center items-center bg-slate-100"><Text>Không tìm thấy đơn
            hàng.</Text></View>;
    }

    const statusInfo = OrderStatusMapping[order.status] || OrderStatusMapping.default;
    const paymentMethodInfo = PaymentMethodMapping[order.paymentMethod] || PaymentMethodMapping.default;
    const paymentStatusInfo = PaymentStatusMapping[order.paymentStatus] || PaymentStatusMapping.default;
    const createdAtDate = order.createdAt ? new Date(order.createdAt).toLocaleString('vi-VN', {
        day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
    }) : 'N/A';
    const canCancelOrder = order.status === 1 || order.status === 2;
    const orderIsDelivered = statusInfo.isDelivered === true;

    return (<SafeAreaView className="flex-1 bg-slate-100">
        <ScrollView contentContainerStyle={{paddingBottom: 20}}>
            <View className="bg-white m-3 p-4 rounded-lg shadow-sm">
                <View className="flex-row justify-between items-center mb-3 pb-3 border-b border-gray-200">
                    <Text className="text-lg font-bold text-sky-600">Đơn hàng #{order.id}</Text>
                    <View className={`px-2.5 py-1 rounded-full flex-row items-center ${statusInfo.bg}`}>
                        <MaterialCommunityIcons name={statusInfo.icon} size={16}
                                                color={statusInfo.color.replace('text-', '')}/>
                        <Text className={`text-sm font-medium ml-1.5 ${statusInfo.color}`}>{statusInfo.text}</Text>
                    </View>
                </View>

                <InfoRow icon="calendar-clock-outline" label="Ngày đặt" value={createdAtDate}/>
                <InfoRow icon="account-circle-outline" label="Người nhận" value={order.fullName}/>
                <InfoRow icon="phone-outline" label="Số điện thoại" value={order.phone}/>
                <InfoRow icon="map-marker-outline" label="Địa chỉ giao" value={order.address}/>
                <InfoRow icon={paymentMethodInfo.icon} label="Phương thức TT">
                    <Text className={`flex-1 text-sm font-medium text-gray-800`}>{paymentMethodInfo.text}</Text>
                </InfoRow>
                <InfoRow icon={paymentStatusInfo.icon} label="Trạng thái TT">
                    <Text
                        className={`flex-1 text-sm font-medium ${paymentStatusInfo.color}`}>{paymentStatusInfo.text}</Text>
                </InfoRow>
                {order.note && <InfoRow icon="note-text-outline" label="Ghi chú" value={order.note}/>}
            </View>

            <View className="bg-white m-3 p-4 rounded-lg shadow-sm">
                <Text className="text-lg font-semibold text-gray-800 mb-2">Sản phẩm</Text>
                {order.orderProducts?.map(item => (<OrderProductItem
                    key={item.id.toString()}
                    item={item}
                    onRatePress={handleOpenRatingModal}
                    orderStatusIsDelivered={orderIsDelivered}
                    userRating={userRatings[item.productId]}
                />))}
            </View>

            <View className="bg-white m-3 p-4 rounded-lg shadow-sm">
                <Text className="text-lg font-semibold text-gray-800 mb-2">Thanh toán</Text>
                <View className="flex-row justify-between mb-1">
                    <Text className="text-sm text-gray-600">Tổng tiền hàng:</Text>
                    <Text
                        className="text-sm text-gray-800 font-medium">{order.totalPrice?.toLocaleString('vi-VN')}₫</Text>
                </View>
                <View className="flex-row justify-between mb-1">
                    <Text className="text-sm text-gray-600">Phí vận chuyển:</Text>
                    <Text className="text-sm text-gray-800 font-medium">0₫</Text>
                </View>
                <View className="border-t border-gray-200 pt-2 mt-1 flex-row justify-between items-center">
                    <Text className="text-base font-bold text-gray-800">Thành tiền:</Text>
                    <Text
                        className="text-xl font-bold text-red-600">{order.totalPrice?.toLocaleString('vi-VN')}₫</Text>
                </View>
            </View>

            {canCancelOrder && (<View className="m-3 mt-4">
                <TouchableOpacity
                    onPress={handleCancelOrder}
                    disabled={isCancelling}
                    className={`py-3.5 rounded-lg shadow ${isCancelling ? 'bg-gray-400' : 'bg-red-500 active:bg-red-600'}`}
                >
                    {isCancelling ? (<ActivityIndicator color="#FFFFFF"/>) : (
                        <Text className="text-white text-center text-base font-semibold">Hủy Đơn Hàng</Text>)}
                </TouchableOpacity>
            </View>)}
        </ScrollView>
        <ProductRatingModal
            visible={ratingModalVisible}
            onClose={() => setRatingModalVisible(false)}
            onSubmit={handleSubmitRating}
            productInfo={selectedProductToRate}
            initialRating={initialRatingForModal}
            initialComment={initialCommentForModal}
            isLoading={isSubmittingRating}
        />
    </SafeAreaView>);
}

const styles = StyleSheet.create({
    modalOverlay: {
        flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center',
    },
});

export default OrderDetailScreen;


/* ===== src\screens\account\OrderHistoryScreen.jsx ===== */
// src/screens/account/OrderHistoryScreen.jsx
import { orderService } from '@/services';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useCallback, useEffect, useState } from 'react';
import { ActivityIndicator, Alert, FlatList, RefreshControl, SafeAreaView, Text, TouchableOpacity, View } from 'react-native';

const OrderStatusMapping = {
    0: { text: 'Đã giao hàng', color: 'text-green-600', bg: 'bg-green-100' }, // Giao hàng thành công
    1: { text: 'Chờ xác nhận', color: 'text-amber-600', bg: 'bg-amber-100' },
    2: { text: 'Chờ vận chuyển', color: 'text-blue-600', bg: 'bg-blue-100' }, // Chờ đơn vị vận chuyển
    3: { text: 'Đang vận chuyển', color: 'text-indigo-600', bg: 'bg-indigo-100' },
    4: { text: 'Đã giao', color: 'text-green-600', bg: 'bg-green-100' }, // Giống 0, có thể cần làm rõ hơn
    5: { text: 'Đã hủy', color: 'text-red-600', bg: 'bg-red-100' },
    default: { text: 'Không xác định', color: 'text-gray-600', bg: 'bg-gray-100' },
};

const PaymentMethodMapping = {
    0: 'Thanh toán khi nhận hàng (COD)',
    1: 'Thanh toán qua VNPay',
    2: 'Thanh toán qua MoMo',
    default: 'Phương thức khác'
};

// PaymentStatus không trực tiếp hiển thị trong list item, nhưng có thể dùng trong OrderDetail
// const PaymentStatusMapping = {
//     0: { text: 'Đã thanh toán', color: 'text-green-600' },
//     1: { text: 'Chưa thanh toán', color: 'text-red-600' },
//     2: { text: 'Đã hoàn tiền', color: 'text-blue-600' },
//     3: { text: 'Thanh toán thất bại', color: 'text-orange-600' },
//     5: { text: 'Đã huỷ thanh toán', color: 'text-gray-500' },
//     default: { text: 'Không xác định', color: 'text-gray-500' },
// };


const InfoRow = ({ icon, label, value, isCurrency = false }) => (
    <View className="flex-row items-center mt-1">
        <Ionicons name={icon} size={14} color="#6B7280" />
        <Text className="text-sm text-gray-600 ml-1.5 w-24">{label}</Text>
        <Text className={`text-sm ${isCurrency ? 'font-semibold text-sky-700' : 'text-gray-800'}`}>{value}</Text>
    </View>
);

function OrderHistoryScreen() {
    const router = useRouter();
    const [orders, setOrders] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [isRefreshing, setIsRefreshing] = useState(false);
    const [pageIndex, setPageIndex] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const pageSize = 10;

    const fetchOrders = useCallback(async (page = 1, refreshing = false) => {
        if (!refreshing && page > 1 && page > totalPages) return;
        if (refreshing || page === 1) setIsLoading(true);

        try {
            // API GET /order/my-orders?pageIndex={pageIndex}&pageSize={pageSize}
            const response = await orderService.getMyOrders(page, pageSize);
            // Backend OrderService.getOrdersByUserId trả về ApiResponse<PageResponse<OrderResponse>>
            // PageResponse: { currentPage, totalPages, totalElements, pageSize, data: List<OrderResponse> }
            // OrderResponse: { id, userId, profileId, fullName, phone, address, status, paymentMethod, paymentStatus, totalPrice, note, createdAt, orderProducts: Set<OrderProductResponse> }
            if (response && response.status === 200 && response.result) {
                const newOrders = response.result.data || [];
                setOrders(prevOrders => (page === 1 ? newOrders : [...prevOrders, ...newOrders]));
                setTotalPages(response.result.totalPages || 1);
                setPageIndex(page); // Cập nhật pageIndex hiện tại
            } else {
                Alert.alert("Lỗi", response?.message || "Không thể tải lịch sử đơn hàng.");
            }
        } catch (error) {
            console.error("Fetch orders error:", error);
            Alert.alert("Lỗi", error?.message || "Đã có lỗi xảy ra khi tải đơn hàng.");
        } finally {
            setIsLoading(false);
            if (refreshing) setIsRefreshing(false);
        }
    }, [totalPages]); // Thêm totalPages vào dependencies

    useEffect(() => {
        // console.log("OrderHistoryScreen mounted or fetchOrders changed");
        fetchOrders(1, true);
    }, [fetchOrders]);

    const onRefresh = () => {
        // console.log("Refreshing orders...");
        setIsRefreshing(true);
        setPageIndex(1); // Reset page index khi refresh
        fetchOrders(1, true);
    };

    const loadMoreOrders = () => {
        // console.log(`Attempting to load more: isLoading=${isLoading}, isRefreshing=${isRefreshing}, pageIndex=${pageIndex}, totalPages=${totalPages}`);
        if (!isLoading && !isRefreshing && pageIndex < totalPages) {
            // console.log(`Loading page ${pageIndex + 1}`);
            fetchOrders(pageIndex + 1);
        }
    };

    const handleOrderItemPress = (orderId) => {
        router.push(`/account/order-history/${orderId}`);
    };

    const renderOrderItem = ({ item }) => {
        const statusInfo = OrderStatusMapping[item.status] || OrderStatusMapping.default;
        const paymentMethodText = PaymentMethodMapping[item.paymentMethod] || PaymentMethodMapping.default;
        const createdAtDate = item.createdAt ? new Date(item.createdAt).toLocaleDateString('vi-VN', {
            day: '2-digit', month: '2-digit', year: 'numeric'
        }) : 'N/A';

        return (
            <TouchableOpacity
                className="bg-white p-4 mb-3 mx-3 rounded-lg shadow-md active:bg-gray-50"
                onPress={() => handleOrderItemPress(item.id)}
            >
                <View className="flex-row justify-between items-center mb-2">
                    <Text className="text-base font-semibold text-gray-800">Đơn hàng #{item.id}</Text>
                    <View className={`px-2 py-0.5 rounded-full ${statusInfo.bg}`}>
                        <Text className={`text-xs font-medium ${statusInfo.color}`}>{statusInfo.text}</Text>
                    </View>
                </View>
                <InfoRow icon="calendar-outline" label="Ngày đặt:" value={createdAtDate} />
                <InfoRow icon="person-outline" label="Người nhận:" value={item.fullName} />
                <InfoRow icon="pricetags-outline" label="Tổng tiền:" value={`${item.totalPrice?.toLocaleString('vi-VN')}₫`} isCurrency />
                <InfoRow icon="card-outline" label="Thanh toán:" value={paymentMethodText} />
                {item.orderProducts && item.orderProducts.length > 0 && (
                    <Text className="text-xs text-gray-500 mt-1.5">
                        {item.orderProducts.length} sản phẩm: {item.orderProducts.map(p => p.productName).slice(0, 2).join(', ')}{item.orderProducts.length > 2 ? '...' : ''}
                    </Text>
                )}
            </TouchableOpacity>
        );
    };

    if (isLoading && pageIndex === 1 && !isRefreshing) {
        return <View className="flex-1 justify-center items-center"><ActivityIndicator size="large" color="#0EA5E9" /></View>;
    }

    return (
        <SafeAreaView className="flex-1 bg-slate-100">
            {orders.length === 0 && !isLoading ? (
                <View className="flex-1 justify-center items-center p-5">
                    <MaterialCommunityIcons name="history" size={70} color="#CBD5E1" />
                    <Text className="text-xl font-semibold text-gray-500 mt-4">Chưa có đơn hàng nào</Text>
                    <Text className="text-gray-400 mt-1 text-center">
                        Tất cả các đơn hàng của bạn sẽ được hiển thị ở đây.
                    </Text>
                    <TouchableOpacity
                        onPress={() => router.push('/(app)/(home)/')}
                        className="mt-6 bg-sky-500 px-6 py-3 rounded-lg shadow-md active:bg-sky-600"
                    >
                        <Text className="text-white font-semibold text-base">Bắt đầu mua sắm</Text>
                    </TouchableOpacity>
                </View>
            ) : (
                <FlatList
                    data={orders}
                    renderItem={renderOrderItem}
                    keyExtractor={item => item.id.toString()}
                    contentContainerStyle={{ paddingTop: 10, paddingBottom: 20 }}
                    onEndReached={loadMoreOrders}
                    onEndReachedThreshold={0.5}
                    ListFooterComponent={isLoading && pageIndex > 1 && pageIndex < totalPages ? <ActivityIndicator size="small" color="#0EA5E9" style={{ marginVertical: 20 }} /> : null}
                    refreshControl={
                        <RefreshControl refreshing={isRefreshing} onRefresh={onRefresh} colors={["#0EA5E9"]} tintColor={"#0EA5E9"} />
                    }
                />
            )}
        </SafeAreaView>
    );
}

export default OrderHistoryScreen;

/* ===== src\screens\account\ShippingAddressesScreen.jsx ===== */
// src/screens/account/ShippingAddressesScreen.jsx
import { profileService } from '@/services';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useCallback, useEffect, useState } from 'react';
import { ActivityIndicator, Alert, FlatList, Modal, RefreshControl, SafeAreaView, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';

// Component Form thêm/sửa địa chỉ
const AddEditAddressForm = ({ initialData, onSave, onCancel, isSaving }) => {
    const [fullName, setFullName] = useState(initialData?.fullName || '');
    const [phone, setPhone] = useState(initialData?.phone || '');
    const [address, setAddress] = useState(initialData?.address || '');
    const [gender, setGender] = useState(initialData?.gender || 'MALE'); // Default MALE
    const [isDefault, setIsDefault] = useState(initialData?.isDefault || false); // Thêm isDefault

    const handleSubmit = () => {
        if (!fullName.trim() || !phone.trim() || !address.trim()) {
            Alert.alert("Thông tin bắt buộc", "Vui lòng điền đầy đủ họ tên, số điện thoại và địa chỉ.");
            return;
        }
        if (!/^\d{10}$/.test(phone.trim())) {
            Alert.alert("Số điện thoại không hợp lệ", "Vui lòng nhập số điện thoại gồm 10 chữ số.");
            return;
        }
        onSave({
            fullName: fullName.trim(),
            phone: phone.trim(),
            address: address.trim(),
            gender,
            isDefault // Truyền isDefault
        });
    };

    return (
        <View className="bg-white w-full p-5 rounded-t-xl max-h-[90%]">
            <Text className="text-xl font-semibold text-gray-800 mb-5">
                {initialData?.id ? "Chỉnh sửa địa chỉ" : "Thêm địa chỉ mới"}
            </Text>
            <ScrollView showsVerticalScrollIndicator={false} className="mb-3">
                <View className="space-y-4">
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Họ và tên người nhận</Text>
                        <TextInput value={fullName} onChangeText={setFullName} placeholder="Ví dụ: Nguyễn Văn A" className="border border-gray-300 p-3 rounded-lg text-base bg-white" />
                    </View>
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Số điện thoại</Text>
                        <TextInput value={phone} onChangeText={setPhone} placeholder="Ví dụ: 09xxxxxxxx" keyboardType="phone-pad" className="border border-gray-300 p-3 rounded-lg text-base bg-white" />
                    </View>
                    <View>
                        <Text className="text-sm font-medium text-gray-500 mb-1">Địa chỉ chi tiết</Text>
                        <TextInput value={address} onChangeText={setAddress} placeholder="Số nhà, đường, phường/xã, quận/huyện, tỉnh/TP" multiline className="border border-gray-300 p-3 rounded-lg text-base h-24 bg-white" textAlignVertical="top" />
                    </View>
                    <View className="flex-row justify-start space-x-4 items-center py-2">
                        <Text className="text-base text-gray-700">Giới tính:</Text>
                        <TouchableOpacity onPress={() => setGender('MALE')} className="flex-row items-center">
                            <MaterialCommunityIcons name={gender === 'MALE' ? 'radiobox-marked' : 'radiobox-blank'} size={24} color={gender === 'MALE' ? '#0EA5E9' : '#6B7280'} />
                            <Text className="ml-1.5 text-base">Nam</Text>
                        </TouchableOpacity>
                        <TouchableOpacity onPress={() => setGender('FEMALE')} className="flex-row items-center">
                            <MaterialCommunityIcons name={gender === 'FEMALE' ? 'radiobox-marked' : 'radiobox-blank'} size={24} color={gender === 'FEMALE' ? '#0EA5E9' : '#6B7280'} />
                            <Text className="ml-1.5 text-base">Nữ</Text>
                        </TouchableOpacity>
                    </View>
                    <TouchableOpacity onPress={() => setIsDefault(!isDefault)} className="flex-row items-center py-2">
                        <MaterialCommunityIcons name={isDefault ? 'checkbox-marked-outline' : 'checkbox-blank-outline'} size={24} color={isDefault ? '#0EA5E9' : '#6B7280'} />
                        <Text className="ml-2 text-base text-gray-700">Đặt làm địa chỉ mặc định</Text>
                    </TouchableOpacity>
                </View>
            </ScrollView>
            <View className="flex-row mt-auto space-x-3 border-t border-gray-200 pt-4">
                <TouchableOpacity onPress={onCancel} className="flex-1 bg-gray-200 py-3 rounded-lg active:bg-gray-300">
                    <Text className="text-center text-gray-700 font-semibold">Hủy</Text>
                </TouchableOpacity>
                <TouchableOpacity onPress={handleSubmit} disabled={isSaving} className={`flex-1 py-3 rounded-lg ${isSaving ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}>
                    {isSaving ? <ActivityIndicator color="white" /> : <Text className="text-center text-white font-semibold">Lưu địa chỉ</Text>}
                </TouchableOpacity>
            </View>
        </View>
    );
};


function ShippingAddressesScreen() {
    const router = useRouter();
    const [addresses, setAddresses] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [isSubmitting, setIsSubmitting] = useState(false); // For add/edit/delete operations
    const [isRefreshing, setIsRefreshing] = useState(false);
    const [pageIndex, setPageIndex] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const pageSize = 10;

    const [modalVisible, setModalVisible] = useState(false);
    const [currentAddress, setCurrentAddress] = useState(null); // For editing, null for adding

    const fetchAddresses = useCallback(async (page = 1, refreshing = false) => {
        if (!refreshing && page > 1 && page > totalPages) return;
        if (refreshing || page === 1) setIsLoading(true); // Main loading for first fetch or refresh
        else setIsSubmitting(true); // Use isSubmitting for subsequent page loads to show footer loader

        try {
            const response = await profileService.getMyShippingProfiles(page, pageSize);
            if (response && response.status === 200 && response.result) {
                const newAddresses = response.result.data || [];
                setAddresses(prev => (page === 1 ? newAddresses : [...prev, ...newAddresses]));
                setTotalPages(response.result.totalPages || 1);
                setPageIndex(page);
            } else {
                Alert.alert("Lỗi", response?.message || "Không thể tải danh sách địa chỉ.");
            }
        } catch (error) {
            console.error("Fetch addresses error:", error);
            Alert.alert("Lỗi", error?.message || "Đã có lỗi xảy ra khi tải địa chỉ.");
        } finally {
            setIsLoading(false);
            setIsSubmitting(false);
            if (refreshing) setIsRefreshing(false);
        }
    }, [totalPages]);

    useEffect(() => {
        fetchAddresses(1, true);
    }, [fetchAddresses]);

    const onRefresh = () => {
        setIsRefreshing(true);
        fetchAddresses(1, true);
    };

    const loadMoreAddresses = () => {
        if (!isLoading && !isSubmitting && pageIndex < totalPages) {
            fetchAddresses(pageIndex + 1);
        }
    };

    const handleAddNewAddress = () => {
        setCurrentAddress(null);
        setModalVisible(true);
    };

    const handleEditAddress = (address) => {
        setCurrentAddress(address);
        setModalVisible(true);
    };

    const handleSaveAddress = async (addressData) => {
        setIsSubmitting(true);
        try {
            if (currentAddress && currentAddress.id) {
                await profileService.updateShippingProfile(currentAddress.id, addressData);
            } else {
                await profileService.createShippingProfile(addressData);
            }
            setModalVisible(false);
            Alert.alert("Thành công", `Địa chỉ đã được ${currentAddress ? 'cập nhật' : 'thêm mới'}.`);
            fetchAddresses(1, true); // Refresh list from page 1
        } catch (error) {
            Alert.alert("Lỗi", error?.message || "Không thể lưu địa chỉ.");
        } finally {
            setIsSubmitting(false);
        }
    };

    const handleDeleteAddress = (profileId) => {
        Alert.alert(
            "Xác nhận xóa", "Bạn có chắc chắn muốn xóa địa chỉ này?",
            [
                { text: "Hủy", style: "cancel" },
                {
                    text: "Xóa",
                    onPress: async () => {
                        setIsSubmitting(true);
                        try {
                            const response = await profileService.deleteShippingProfile(profileId);
                            if (response && response.status === 200) {
                                Alert.alert("Thành công", "Địa chỉ đã được xóa.");
                                fetchAddresses(1, true);
                            } else {
                                Alert.alert("Lỗi", response?.message || "Không thể xóa địa chỉ.");
                            }
                        } catch (error) {
                            Alert.alert("Lỗi", error?.message || "Đã xảy ra lỗi khi xóa.");
                        } finally {
                            setIsSubmitting(false);
                        }
                    },
                    style: "destructive"
                }
            ]
        );
    };

    const renderAddressItem = ({ item }) => (
        <View className={`bg-white p-4 mb-3 mx-3 rounded-lg shadow-md ${item.isDefault ? 'border-2 border-sky-500' : ''}`}>
            <View className="flex-row justify-between items-start">
                <View className="flex-1">
                    <View className="flex-row items-center">
                        <Text className="text-base font-semibold text-gray-800">{item.fullName}</Text>
                        {item.isDefault && <View className="ml-2 bg-sky-100 px-2 py-0.5 rounded-full"><Text className="text-xs text-sky-600 font-medium">Mặc định</Text></View>}
                    </View>
                    <Text className="text-sm text-gray-600 mt-0.5">{item.phone}</Text>
                    <Text className="text-sm text-gray-600 mt-0.5" numberOfLines={2}>{item.address}</Text>
                    {item.gender && <Text className="text-xs text-gray-500 mt-1">Giới tính: {item.gender === 'MALE' ? 'Nam' : 'Nữ'}</Text>}
                </View>
                <View className="flex-row space-x-1">
                    <TouchableOpacity onPress={() => handleEditAddress(item)} className="p-1.5">
                        <MaterialCommunityIcons name="pencil-outline" size={22} color="#3B82F6" />
                    </TouchableOpacity>
                    {!item.isDefault && ( // Chỉ cho phép xóa nếu không phải mặc định, hoặc cần logic phức tạp hơn
                        <TouchableOpacity onPress={() => handleDeleteAddress(item.id)} className="p-1.5">
                            <MaterialCommunityIcons name="trash-can-outline" size={22} color="#EF4444" />
                        </TouchableOpacity>
                    )}
                </View>
            </View>
        </View>
    );

    if (isLoading && pageIndex === 1 && !isRefreshing) {
        return <View className="flex-1 justify-center items-center"><ActivityIndicator size="large" color="#0EA5E9" /></View>;
    }

    return (
        <SafeAreaView className="flex-1 bg-slate-100">
            <TouchableOpacity
                onPress={handleAddNewAddress}
                className="bg-sky-500 m-3 py-3.5 rounded-lg shadow-md active:bg-sky-600 flex-row justify-center items-center"
            >
                <Ionicons name="add-circle-outline" size={22} color="white" />
                <Text className="text-white text-center text-base font-semibold ml-2">Thêm Địa Chỉ Mới</Text>
            </TouchableOpacity>

            {addresses.length === 0 && !isLoading ? (
                <View className="flex-1 justify-center items-center p-5 -mt-16">
                    <MaterialCommunityIcons name="map-marker-off-outline" size={70} color="#CBD5E1" />
                    <Text className="text-xl font-semibold text-gray-500 mt-4">Chưa có địa chỉ nào</Text>
                    <Text className="text-gray-400 mt-1 text-center">
                        Thêm địa chỉ giao hàng để việc mua sắm nhanh chóng hơn.
                    </Text>
                </View>
            ) : (
                <FlatList
                    data={addresses}
                    renderItem={renderAddressItem}
                    keyExtractor={item => item.id.toString()}
                    contentContainerStyle={{ paddingTop: 6, paddingBottom: 20 }}
                    onEndReached={loadMoreAddresses}
                    onEndReachedThreshold={0.5}
                    ListFooterComponent={isSubmitting && pageIndex > 1 ? <ActivityIndicator size="small" color="#0EA5E9" style={{ marginVertical: 20 }} /> : null}
                    refreshControl={
                        <RefreshControl refreshing={isRefreshing} onRefresh={onRefresh} colors={["#0EA5E9"]} tintColor={"#0EA5E9"} />
                    }
                />
            )}
            <Modal
                animationType="slide"
                transparent={true}
                visible={modalVisible}
                onRequestClose={() => {
                    setModalVisible(false);
                    setCurrentAddress(null); // Reset current address khi đóng modal
                }}
            >
                <View style={styles.modalOverlay}>
                    <AddEditAddressForm
                        initialData={currentAddress}
                        onSave={handleSaveAddress}
                        onCancel={() => {
                            setModalVisible(false);
                            setCurrentAddress(null);
                        }}
                        isSaving={isSubmitting}
                    />
                </View>
            </Modal>
        </SafeAreaView>
    );
}
const styles = StyleSheet.create({
    modalOverlay: {
        flex: 1,
        backgroundColor: 'rgba(0,0,0,0.5)',
        justifyContent: 'flex-end', // Hiển thị modal từ dưới lên
    },
});

export default ShippingAddressesScreen;

/* ===== src\screens\auth\ForgotPasswordScreen.jsx ===== */
import {useAuth} from '@/contexts/AuthContext';
import {Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import {useRouter} from 'expo-router';
import React, {useState} from 'react';
import {
    ActivityIndicator,
    Alert,
    KeyboardAvoidingView,
    Platform,
    SafeAreaView,
    ScrollView,
    Text,
    TextInput,
    TouchableOpacity,
    View
} from 'react-native';

function ForgotPasswordScreen() {
    const router = useRouter();
    const {sendOtpForgotPassword, verifyOtpAndGetResetToken} = useAuth();
    const [username, setUsername] = useState('');
    const [otp, setOtp] = useState('');
    const [isOtpSent, setIsOtpSent] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [successMessage, setSuccessMessage] = useState('');

    const handleSendOtp = async () => {
        setError('');
        setSuccessMessage('');
        if (!username.trim()) {
            setError("Vui lòng nhập tên đăng nhập hoặc email.");
            return;
        }
        setIsLoading(true);
        try {
            const response = await sendOtpForgotPassword(username);
            if (response && response.status === 200) {
                setIsOtpSent(true);
                setSuccessMessage(response.result || "Mã OTP đã được gửi thành công. Vui lòng kiểm tra email của bạn.");
                Alert.alert("Thành công", response.result || "Mã OTP đã được gửi. Vui lòng kiểm tra email.");
            } else {
                setError(response?.message || "Không thể gửi OTP. Vui lòng thử lại.");
            }
        } catch (err) {
            setError(err?.message || "Đã xảy ra lỗi khi gửi OTP.");
        } finally {
            setIsLoading(false);
        }
    };

    const handleVerifyOtp = async () => {
        setError('');
        setSuccessMessage('');
        if (!otp.trim() || otp.length !== 6) {
            setError("Vui lòng nhập mã OTP hợp lệ (6 chữ số).");
            return;
        }
        setIsLoading(true);
        try {
            const response = await verifyOtpAndGetResetToken(username, otp);
            if (response && response.status === 200 && response.result && response.result.verificationToken) {
                Alert.alert("Xác thực thành công", "Mã OTP hợp lệ.");
                router.push({
                    pathname: '/(auth)/reset-password',
                    params: {username: username, verificationToken: response.result.verificationToken}
                });
            } else {
                setError(response?.message || "Mã OTP không hợp lệ hoặc đã hết hạn.");
            }
        } catch (err) {
            setError(err?.message || "Đã xảy ra lỗi khi xác thực OTP.");
        } finally {
            setIsLoading(false);
        }
    };

    const handleResendOtp = async () => {
        setError('');
        setSuccessMessage('');
        setIsLoading(true);
        try {
            const response = await sendOtpForgotPassword(username);
            if (response && response.status === 200) {
                setSuccessMessage(response.result || "Mã OTP mới đã được gửi. Vui lòng kiểm tra email.");
                Alert.alert("Thành công", response.result || "Mã OTP mới đã được gửi.");
            } else {
                setError(response?.message || "Không thể gửi lại OTP. Vui lòng thử lại.");
            }
        } catch (err) {
            setError(err?.message || "Đã xảy ra lỗi khi gửi lại OTP.");
        } finally {
            setIsLoading(false);
        }
    };

    return (<SafeAreaView className="flex-1 bg-slate-50">
        <KeyboardAvoidingView
            behavior={Platform.OS === "ios" ? "padding" : "height"}
            className="flex-1"
        >
            <ScrollView
                contentContainerStyle={{flexGrow: 1, justifyContent: 'center'}}
                className="px-6"
                keyboardShouldPersistTaps="handled"
            >
                <View className="items-center mb-8">
                    <MaterialCommunityIcons name="lock-question" size={80} color="#0EA5E9"/>
                    <Text className="text-3xl font-bold text-sky-600 mt-4">
                        {isOtpSent ? "Nhập Mã Xác Thực" : "Quên Mật Khẩu"}
                    </Text>
                    <Text className="text-gray-600 mt-2 text-center px-4">
                        {isOtpSent ? `Một mã OTP đã được gửi đến email liên kết với tài khoản '${username}'.` : "Nhập tên đăng nhập hoặc email của bạn để nhận mã xác thực."}
                    </Text>
                </View>

                {error ? (<View className="bg-red-100 border border-red-400 p-3 rounded-md mb-4">
                    <Text className="text-red-700 text-center">{error}</Text>
                </View>) : null}
                {successMessage && !error ? (
                    <View className="bg-green-100 border border-green-400 p-3 rounded-md mb-4">
                        <Text className="text-green-700 text-center">{successMessage}</Text>
                    </View>) : null}

                {!isOtpSent ? (<>
                    <View className="mb-5">
                        <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Tên đăng nhập hoặc
                            Email</Text>
                        <View
                            className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                            <Ionicons name="person-outline" size={20} color="#6B7280" className="mr-2"/>
                            <TextInput
                                className="flex-1 text-base text-gray-800"
                                placeholder="Nhập tên đăng nhập hoặc email"
                                placeholderTextColor="#9CA3AF"
                                value={username}
                                onChangeText={setUsername}
                                autoCapitalize="none"
                                editable={!isLoading}
                            />
                        </View>
                    </View>

                    <TouchableOpacity
                        onPress={handleSendOtp}
                        disabled={isLoading}
                        className={`py-4 rounded-lg shadow-md mb-6 ${isLoading ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}
                    >
                        {isLoading ? (<ActivityIndicator color="#FFFFFF"/>) : (
                            <Text className="text-white text-center text-lg font-semibold">Gửi Mã Xác
                                Thực</Text>)}
                    </TouchableOpacity>
                </>) : (<>
                    <View className="mb-5">
                        <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Mã OTP</Text>
                        <View
                            className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                            <MaterialCommunityIcons name="numeric" size={20} color="#6B7280" className="mr-2"/>
                            <TextInput
                                className="flex-1 text-base text-gray-800"
                                placeholder="Nhập mã OTP (6 chữ số)"
                                placeholderTextColor="#9CA3AF"
                                value={otp}
                                onChangeText={setOtp}
                                keyboardType="number-pad"
                                maxLength={6}
                                editable={!isLoading}
                            />
                        </View>
                    </View>

                    <TouchableOpacity
                        onPress={handleVerifyOtp}
                        disabled={isLoading || otp.length !== 6}
                        className={`py-4 rounded-lg shadow-md mb-4 ${(isLoading || otp.length !== 6) ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}
                    >
                        {isLoading && otp.length === 6 ? (<ActivityIndicator color="#FFFFFF"/>) : (
                            <Text className="text-white text-center text-lg font-semibold">Xác Nhận</Text>)}
                    </TouchableOpacity>

                    <TouchableOpacity onPress={handleResendOtp} disabled={isLoading} className="mb-6">
                        <Text className="text-sky-600 text-center text-sm font-medium">
                            {isLoading ? 'Đang gửi...' : 'Gửi lại mã OTP'}
                        </Text>
                    </TouchableOpacity>
                </>)}

                <TouchableOpacity onPress={() => router.back()} disabled={isLoading} className="mt-4">
                    <Text className="text-gray-600 text-center text-sm">Quay lại Đăng nhập</Text>
                </TouchableOpacity>
            </ScrollView>
        </KeyboardAvoidingView>
    </SafeAreaView>);
}

export default ForgotPasswordScreen;


/* ===== src\screens\auth\LoginScreen.jsx ===== */
// src/screens/auth/LoginScreen.jsx
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useEffect, useState } from 'react';
import {
    ActivityIndicator,
    KeyboardAvoidingView,
    Platform,
    ScrollView,
    Text,
    TextInput,
    TouchableOpacity,
    View
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';

function LoginScreen() {
    const router = useRouter();
    const { login } = useAuth();
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [showPassword, setShowPassword] = useState(false);
    const [isLoading, setIsLoading] = useState(false); // State cho loading
    const [error, setError] = useState(''); // State cho thông báo lỗi

    useEffect(() => {
        console.log("Login Screen mounted");
    }, []);

    const handleLogin = async () => {
        if (!username.trim() || !password.trim()) {
            setError("Tên đăng nhập và mật khẩu không được để trống.");
            return;
        }
        setError(''); // Xóa lỗi cũ
        setIsLoading(true);
        try {
            const response = await login(username, password);
            // AuthProvider sẽ tự động điều hướng nếu login thành công
            // response ở đây là ApiResponse từ backend (thông qua identityService và AuthProvider)
            console.log('Login response in screen:', response);
            if (response && response.status === 200 && response.result && response.result.authenticated) {
                // Đăng nhập thành công, AuthProvider sẽ xử lý điều hướng
                // Không cần router.replace ở đây nữa
            } else {
                // Xử lý trường hợp API trả về success nhưng không authenticated, hoặc message lỗi cụ thể
                setError(response?.message || "Đăng nhập thất bại. Vui lòng thử lại.");
            }
        } catch (err) {
            // Lỗi đã được console.error trong service hoặc AuthProvider
            // err ở đây là lỗi đã được xử lý (ví dụ: data từ error.response)
            setError(err?.message || "Đã có lỗi xảy ra. Vui lòng thử lại.");
        } finally {
            setIsLoading(false);
        }
    };

    const navigateToForgotPassword = () => {
        router.push('/(auth)/forgot-password');
    };

    const navigateToRegister = () => {
        router.push('/(auth)/register');
    };

    return (
        <SafeAreaView className="flex-1 bg-slate-50">
            <KeyboardAvoidingView
                behavior={Platform.OS === "ios" ? "padding" : "height"}
                className="flex-1"
            >
                <ScrollView
                    contentContainerStyle={{ flexGrow: 1, justifyContent: 'center' }}
                    className="px-6"
                    keyboardShouldPersistTaps="handled"
                >
                    <View className="items-center mb-10">
                        <MaterialCommunityIcons name="book-open-page-variant-outline" size={80} color="#0EA5E9" />
                        <Text className="text-4xl font-bold text-sky-600 mt-4">BookStore</Text>
                        <Text className="text-2xl font-semibold text-gray-700 mt-2">Đăng Nhập</Text>
                    </View>

                    {error ? (
                        <View className="bg-red-100 border border-red-400 p-3 rounded-md mb-4">
                            <Text className="text-red-700 text-center">{error}</Text>
                        </View>
                    ) : null}

                    {/* Username Input */}
                    <View className="mb-5">
                        <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Tên đăng nhập</Text>
                        <View
                            className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                            <Ionicons name="person-outline" size={20} color="#6B7280" className="mr-2" />
                            <TextInput
                                className="flex-1 text-base text-gray-800"
                                placeholder="Nhập tên đăng nhập"
                                placeholderTextColor="#9CA3AF"
                                value={username}
                                onChangeText={setUsername}
                                autoCapitalize="none"
                                keyboardType="default"
                                editable={!isLoading}
                            />
                        </View>
                    </View>

                    {/* Password Input */}
                    <View className="mb-6">
                        <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Mật khẩu</Text>
                        <View
                            className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                            <Ionicons name="lock-closed-outline" size={20} color="#6B7280" className="mr-2" />
                            <TextInput
                                className="flex-1 text-base text-gray-800"
                                placeholder="Nhập mật khẩu"
                                placeholderTextColor="#9CA3AF"
                                value={password}
                                onChangeText={setPassword}
                                secureTextEntry={!showPassword}
                                editable={!isLoading}
                            />
                            <TouchableOpacity onPress={() => setShowPassword(!showPassword)} disabled={isLoading}>
                                <Ionicons name={showPassword ? "eye-off-outline" : "eye-outline"} size={24}
                                    color="#6B7280" />
                            </TouchableOpacity>
                        </View>
                    </View>

                    <TouchableOpacity
                        onPress={handleLogin}
                        disabled={isLoading}
                        className={`py-4 rounded-lg shadow-md mb-4 ${isLoading ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}
                    >
                        {isLoading ? (
                            <ActivityIndicator color="#FFFFFF" />
                        ) : (
                            <Text className="text-white text-center text-lg font-semibold">Đăng Nhập</Text>
                        )}
                    </TouchableOpacity>

                    <TouchableOpacity onPress={navigateToForgotPassword} disabled={isLoading} className="mb-6">
                        <Text className="text-sky-600 text-center text-sm font-medium">Quên mật khẩu?</Text>
                    </TouchableOpacity>

                    <View className="flex-row justify-center items-center">
                        <Text className="text-gray-600 text-sm">Chưa có tài khoản? </Text>
                        <TouchableOpacity onPress={navigateToRegister} disabled={isLoading}>
                            <Text className="text-sky-600 font-semibold text-sm">Đăng ký ngay</Text>
                        </TouchableOpacity>
                    </View>
                </ScrollView>
            </KeyboardAvoidingView>
        </SafeAreaView>
    );
}

export default LoginScreen;


/* ===== src\screens\auth\RegisterScreen.jsx ===== */
import {useAuth} from '@/contexts/AuthContext';
import {Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import {useRouter} from 'expo-router';
import React, {useState} from 'react';
import {
    ActivityIndicator,
    Alert,
    KeyboardAvoidingView,
    Platform,
    SafeAreaView,
    ScrollView,
    Text,
    TextInput,
    TouchableOpacity,
    View
} from 'react-native';

function RegisterScreen() {
    const router = useRouter();
    const {register} = useAuth();
    const [username, setUsername] = useState('');
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [showPassword, setShowPassword] = useState(false);
    const [showConfirmPassword, setShowConfirmPassword] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    const isValidEmail = (emailToTest) => {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(emailToTest);
    };

    const handleRegister = async () => {
        setError('');
        if (!username.trim() || !email.trim() || !password.trim() || !confirmPassword.trim()) {
            setError("Vui lòng điền đầy đủ thông tin.");
            return;
        }
        if (!isValidEmail(email)) {
            setError("Địa chỉ email không hợp lệ.");
            return;
        }
        if (password.length < 6) {
            setError("Mật khẩu phải có ít nhất 6 ký tự.");
            return;
        }
        if (password !== confirmPassword) {
            setError("Mật khẩu xác nhận không khớp.");
            return;
        }

        setIsLoading(true);
        try {
            const userData = {username, email, password};
            const response = await register(userData);

            console.log(response)

            if (response && response.status === 201) {
                Alert.alert("Đăng ký thành công!", response.message || "Tài khoản của bạn đã được tạo. Vui lòng đăng nhập.", [{
                    text: "OK", onPress: () => router.replace('/(auth)/login')
                }]);
            } else {
                // Ưu tiên hiển thị lỗi chi tiết từ backend nếu có
                if (response && response.error && Array.isArray(response.error) && response.error.length > 0) {
                    const firstError = response.error[0];
                    setError(`${firstError.field}: ${firstError.message}`);
                } else {
                    setError(response?.message || "Đăng ký không thành công. Vui lòng thử lại.");
                }
            }
        } catch (err) {
            // Xử lý lỗi chi tiết từ err.error nếu có
            if (err && err.error && Array.isArray(err.error) && err.error.length > 0) {
                const firstError = err.error[0];
                // Hiển thị lỗi cụ thể hơn, ví dụ: "username: Username chỉ được chứa chữ cái thường..."
                setError(`Lỗi trường ${firstError.field}: ${firstError.message}`);
            } else {
                setError(err?.message || "Đã có lỗi xảy ra trong quá trình đăng ký.");
            }
        } finally {
            setIsLoading(false);
        }
    };

    const navigateToLogin = () => {
        if (!isLoading) {
            router.replace('/(auth)/login');
        }
    };

    return (<SafeAreaView className="flex-1 bg-slate-50">
        <KeyboardAvoidingView
            behavior={Platform.OS === "ios" ? "padding" : "height"}
            className="flex-1"
        >
            <ScrollView
                contentContainerStyle={{flexGrow: 1, justifyContent: 'center'}}
                className="px-6"
                keyboardShouldPersistTaps="handled"
            >
                <View className="items-center mb-8">
                    <MaterialCommunityIcons name="account-plus-outline" size={80} color="#0EA5E9"/>
                    <Text className="text-3xl font-bold text-sky-600 mt-4">Tạo Tài Khoản</Text>
                </View>

                {error ? (<View className="bg-red-100 border border-red-400 p-3 rounded-md mb-4">
                    <Text className="text-red-700 text-center">{error}</Text>
                </View>) : null}

                <View className="mb-4">
                    <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Tên đăng nhập</Text>
                    <View
                        className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                        <Ionicons name="person-outline" size={20} color="#6B7280" className="mr-2"/>
                        <TextInput
                            className="flex-1 text-base text-gray-800"
                            placeholder="Nhập tên đăng nhập (chữ thường, số)"
                            placeholderTextColor="#9CA3AF"
                            value={username}
                            onChangeText={setUsername}
                            autoCapitalize="none"
                            editable={!isLoading}
                        />
                    </View>
                </View>

                <View className="mb-4">
                    <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Email</Text>
                    <View
                        className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                        <Ionicons name="mail-outline" size={20} color="#6B7280" className="mr-2"/>
                        <TextInput
                            className="flex-1 text-base text-gray-800"
                            placeholder="Nhập địa chỉ email"
                            placeholderTextColor="#9CA3AF"
                            value={email}
                            onChangeText={setEmail}
                            keyboardType="email-address"
                            autoCapitalize="none"
                            editable={!isLoading}
                        />
                    </View>
                </View>

                <View className="mb-4">
                    <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Mật khẩu</Text>
                    <View
                        className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                        <Ionicons name="lock-closed-outline" size={20} color="#6B7280" className="mr-2"/>
                        <TextInput
                            className="flex-1 text-base text-gray-800"
                            placeholder="Nhập mật khẩu (ít nhất 6 ký tự)"
                            placeholderTextColor="#9CA3AF"
                            value={password}
                            onChangeText={setPassword}
                            secureTextEntry={!showPassword}
                            editable={!isLoading}
                        />
                        <TouchableOpacity onPress={() => setShowPassword(!showPassword)} disabled={isLoading}>
                            <Ionicons name={showPassword ? "eye-off-outline" : "eye-outline"} size={24}
                                      color="#6B7280"/>
                        </TouchableOpacity>
                    </View>
                </View>

                <View className="mb-6">
                    <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Xác nhận mật khẩu</Text>
                    <View
                        className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                        <Ionicons name="lock-closed-outline" size={20} color="#6B7280" className="mr-2"/>
                        <TextInput
                            className="flex-1 text-base text-gray-800"
                            placeholder="Nhập lại mật khẩu"
                            placeholderTextColor="#9CA3AF"
                            value={confirmPassword}
                            onChangeText={setConfirmPassword}
                            secureTextEntry={!showConfirmPassword}
                            editable={!isLoading}
                        />
                        <TouchableOpacity onPress={() => setShowConfirmPassword(!showConfirmPassword)}
                                          disabled={isLoading}>
                            <Ionicons name={showConfirmPassword ? "eye-off-outline" : "eye-outline"} size={24}
                                      color="#6B7280"/>
                        </TouchableOpacity>
                    </View>
                </View>

                <TouchableOpacity
                    onPress={handleRegister}
                    disabled={isLoading}
                    className={`py-4 rounded-lg shadow-md mb-6 ${isLoading ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}
                >
                    {isLoading ? (<ActivityIndicator color="#FFFFFF"/>) : (
                        <Text className="text-white text-center text-lg font-semibold">Đăng Ký</Text>)}
                </TouchableOpacity>

                <View className="flex-row justify-center items-center">
                    <Text className="text-gray-600 text-sm">Đã có tài khoản? </Text>
                    <TouchableOpacity onPress={navigateToLogin} disabled={isLoading}>
                        <Text className="text-sky-600 font-semibold text-sm">Đăng nhập</Text>
                    </TouchableOpacity>
                </View>
            </ScrollView>
        </KeyboardAvoidingView>
    </SafeAreaView>);
}

export default RegisterScreen;


/* ===== src\screens\auth\ResetPasswordScreen.jsx ===== */
import {useAuth} from '@/contexts/AuthContext';
import {Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import {useLocalSearchParams, useRouter} from 'expo-router';
import React, {useState} from 'react';
import {
    ActivityIndicator,
    Alert,
    KeyboardAvoidingView,
    Platform,
    SafeAreaView,
    ScrollView,
    Text,
    TextInput,
    TouchableOpacity,
    View
} from 'react-native';

function ResetPasswordScreen() {
    const router = useRouter();
    const {resetPasswordWithVerificationToken} = useAuth();
    const params = useLocalSearchParams();
    const {username, verificationToken} = params;

    const [newPassword, setNewPassword] = useState('');
    const [confirmNewPassword, setConfirmNewPassword] = useState('');
    const [showNewPassword, setShowNewPassword] = useState(false);
    const [showConfirmNewPassword, setShowConfirmNewPassword] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [successMessage, setSuccessMessage] = useState('');

    const handleResetPassword = async () => {
        setError('');
        setSuccessMessage('');
        if (!newPassword || !confirmNewPassword) {
            setError("Vui lòng nhập đầy đủ mật khẩu mới và xác nhận mật khẩu.");
            return;
        }
        if (newPassword.length < 6) {
            setError("Mật khẩu mới phải có ít nhất 6 ký tự.");
            return;
        }
        if (newPassword !== confirmNewPassword) {
            setError("Mật khẩu mới và xác nhận mật khẩu không khớp.");
            return;
        }
        if (!verificationToken) {
            setError("Thiếu mã xác thực để đặt lại mật khẩu. Vui lòng thử lại quy trình quên mật khẩu.");
            setTimeout(() => router.replace('/(auth)/forgot-password'), 3000);
            return;
        }

        setIsLoading(true);
        try {
            const response = await resetPasswordWithVerificationToken(newPassword, verificationToken);
            if (response && response.status === 200) {
                setSuccessMessage(response.result || "Mật khẩu đã được đặt lại thành công!");
                Alert.alert("Thành công!", response.result || "Mật khẩu của bạn đã được đặt lại. Vui lòng đăng nhập bằng mật khẩu mới.", [{
                    text: "OK",
                    onPress: () => router.replace('/(auth)/login')
                }]);
            } else {
                setError(response?.message || "Không thể đặt lại mật khẩu. Vui lòng thử lại.");
            }
        } catch (err) {
            setError(err?.message || "Đã xảy ra lỗi khi đặt lại mật khẩu.");
        } finally {
            setIsLoading(false);
        }
    };

    return (<SafeAreaView className="flex-1 bg-slate-50">
        <KeyboardAvoidingView
            behavior={Platform.OS === "ios" ? "padding" : "height"}
            className="flex-1"
        >
            <ScrollView
                contentContainerStyle={{flexGrow: 1, justifyContent: 'center'}}
                className="px-6"
                keyboardShouldPersistTaps="handled"
            >
                <View className="items-center mb-8">
                    <MaterialCommunityIcons name="lock-reset" size={80} color="#0EA5E9"/>
                    <Text className="text-3xl font-bold text-sky-600 mt-4">Đặt Lại Mật Khẩu</Text>
                    {username && (<Text className="text-gray-600 mt-2 text-center">
                        Đặt lại mật khẩu cho tài khoản: <Text className="font-semibold">{username}</Text>
                    </Text>)}
                </View>

                {error ? (<View className="bg-red-100 border border-red-400 p-3 rounded-md mb-4">
                    <Text className="text-red-700 text-center">{error}</Text>
                </View>) : null}
                {successMessage && !error ? (
                    <View className="bg-green-100 border border-green-400 p-3 rounded-md mb-4">
                        <Text className="text-green-700 text-center">{successMessage}</Text>
                    </View>) : null}

                <View className="mb-4">
                    <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Mật khẩu mới</Text>
                    <View
                        className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3.5 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                        <Ionicons name="key-outline" size={20} color="#6B7280" className="mr-2"/>
                        <TextInput
                            className="flex-1 text-base text-gray-800"
                            placeholder="Nhập mật khẩu mới (ít nhất 6 ký tự)"
                            placeholderTextColor="#9CA3AF"
                            value={newPassword}
                            onChangeText={setNewPassword}
                            secureTextEntry={!showNewPassword}
                            editable={!isLoading}
                        />
                        <TouchableOpacity onPress={() => setShowNewPassword(!showNewPassword)} disabled={isLoading}>
                            <Ionicons name={showNewPassword ? "eye-off-outline" : "eye-outline"} size={24}
                                      color="#6B7280"/>
                        </TouchableOpacity>
                    </View>
                </View>

                <View className="mb-6">
                    <Text className="text-sm font-medium text-gray-600 mb-1 ml-1">Xác nhận mật khẩu mới</Text>
                    <View
                        className="flex-row items-center bg-white border border-gray-300 rounded-lg p-3.5 focus-within:border-sky-500 focus-within:ring-1 focus-within:ring-sky-500">
                        <Ionicons name="key-outline" size={20} color="#6B7280" className="mr-2"/>
                        <TextInput
                            className="flex-1 text-base text-gray-800"
                            placeholder="Nhập lại mật khẩu mới"
                            placeholderTextColor="#9CA3AF"
                            value={confirmNewPassword}
                            onChangeText={setConfirmNewPassword}
                            secureTextEntry={!showConfirmNewPassword}
                            editable={!isLoading}
                        />
                        <TouchableOpacity onPress={() => setShowConfirmNewPassword(!showConfirmNewPassword)}
                                          disabled={isLoading}>
                            <Ionicons name={showConfirmNewPassword ? "eye-off-outline" : "eye-outline"} size={24}
                                      color="#6B7280"/>
                        </TouchableOpacity>
                    </View>
                </View>

                <TouchableOpacity
                    onPress={handleResetPassword}
                    disabled={isLoading}
                    className={`py-4 rounded-lg shadow-md mb-6 ${isLoading ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}
                >
                    {isLoading ? (<ActivityIndicator color="#FFFFFF"/>) : (
                        <Text className="text-white text-center text-lg font-semibold">Đặt Lại Mật Khẩu</Text>)}
                </TouchableOpacity>
                <TouchableOpacity onPress={() => router.replace('/(auth)/login')} disabled={isLoading}
                                  className="mt-2">
                    <Text className="text-gray-600 text-center text-sm">Quay lại Đăng nhập</Text>
                </TouchableOpacity>
            </ScrollView>
        </KeyboardAvoidingView>
    </SafeAreaView>);
}

export default ResetPasswordScreen;


/* ===== src\screens\blog\BlogDetailScreen.jsx ===== */
// src/screens/blog/BlogDetailScreen.jsx
import {blogService} from '@/services'; // Import blogService
import {Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import {Stack, useRouter} from 'expo-router';
import React, {useCallback, useEffect, useState} from 'react';
import {ActivityIndicator, Alert, Image, ScrollView, Share, Text, TouchableOpacity, View} from 'react-native';

const formatDate = (isoString) => {
    if (!isoString) return 'N/A';
    try {
        const date = new Date(isoString);
        const day = date.getDate();
        const month = date.getMonth() + 1;
        const year = date.getFullYear();
        return `${day} tháng ${month}, ${year}`;
    } catch (e) {
        return 'N/A';
    }
};

function BlogDetailScreen({id: blogId}) { // id từ route params được truyền vào là blogId
    const [blog, setBlog] = useState(null);
    const [categoryName, setCategoryName] = useState('Chưa phân loại');
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const router = useRouter();

    const fetchBlogDetails = useCallback(async () => {
        if (!blogId) {
            setError("Không có ID bài viết.");
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        try {
            const response = await blogService.getBlogById(blogId);
            if (response && response.status === 200 && response.result) {
                setBlog(response.result);
                // Fetch category name if categoryId exists
                if (response.result.categoryId) {
                    const catResponse = await blogService.getAllBlogCategories(); // This fetches all, not ideal but works for now
                    if (catResponse && catResponse.status === 200 && catResponse.result) {
                        const foundCategory = catResponse.result.find(c => c.id === response.result.categoryId);
                        if (foundCategory) {
                            setCategoryName(foundCategory.name);
                        }
                    }
                }
            } else {
                throw new Error(response?.message || "Không tìm thấy bài viết.");
            }
        } catch (err) {
            console.error("Error fetching blog details:", err);
            setError(err.message);
        } finally {
            setLoading(false);
        }
    }, [blogId]);

    useEffect(() => {
        fetchBlogDetails();
    }, [fetchBlogDetails]);

    const handleShare = async () => {
        if (!blog) return;
        try {
            await Share.share({
                message: `Đọc bài viết thú vị này: ${blog.title} | BookStore App`, // Nên có một domain thực tế hoặc sử dụng deeplink
                url: `https://mybookstore.app/blog/${blog.slug || blog.id}`, title: blog.title,
            });
        } catch (error) {
            Alert.alert("Lỗi", "Không thể chia sẻ bài viết.");
            console.error('Error sharing:', error.message);
        }
    };

    if (loading) {
        return (<View className="flex-1 justify-center items-center bg-white">
                <ActivityIndicator size="large" color="#0EA5E9"/>
            </View>);
    }

    if (error || !blog) {
        return (<View className="flex-1 justify-center items-center bg-slate-50 p-6">
                <Stack.Screen options={{title: 'Lỗi'}}/>
                <MaterialCommunityIcons name="alert-circle-outline" size={72} color="#EF4444"/>
                <Text className="text-2xl font-semibold text-gray-700 mt-5">
                    {error ? "Lỗi tải bài viết" : "Không tìm thấy bài viết"}
                </Text>
                <Text className="text-gray-500 mt-2.5 text-center">
                    {error || "Bài viết bạn đang tìm không còn tồn tại hoặc đường dẫn đã bị thay đổi."}
                </Text>
                <TouchableOpacity
                    onPress={() => router.canGoBack() ? router.back() : router.replace('/(app)/blog/')}
                    className="mt-6 bg-sky-500 px-6 py-3 rounded-lg shadow active:bg-sky-600"
                >
                    <Text className="text-white font-semibold">Quay lại Blog</Text>
                </TouchableOpacity>
            </View>);
    }
    // Author and View Count: Not available in current BlogResponse from blog-service
    // const authorName = blog.author_name || "Người viết ẩn danh";
    // const viewCount = blog.view_count || 0;

    return (<ScrollView className="flex-1 bg-white" showsVerticalScrollIndicator={false}>
            {/* Sử dụng thumbnail vì API hiện tại chỉ có trường này */}
            <Image
                source={{uri: blog.thumbnail}}
                className="w-full h-72"
                contentFit="cover"
                placeholder={{uri: 'https://via.placeholder.com/800x400/e0e0e0/999999?text=Blog+Image'}}
                transition={300}
            />

            <View className="p-5 lg:p-8">
                {/* Category Badge */}
                <View className="flex-row justify-between items-center mb-4">
                    <Text
                        className="text-sm text-sky-600 font-semibold bg-sky-100 px-3.5 py-1.5 rounded-full self-start uppercase tracking-wider">
                        {categoryName}
                    </Text>
                    <TouchableOpacity onPress={handleShare} className="p-2">
                        <Ionicons name="share-social-outline" size={24} color="#4B5563"/>
                    </TouchableOpacity>
                </View>


                {/* Title */}
                <Text className="text-3xl lg:text-4xl font-extrabold text-gray-900 leading-tight mb-3">
                    {blog.title}
                </Text>

                {/* Date Info - Author and View Count removed as not in API response */}
                <View className="flex-row flex-wrap items-center my-4 text-gray-600 space-x-2 sm:space-x-5">
                    <View className="flex-row items-center mb-2 sm:mb-0">
                        <MaterialCommunityIcons name="calendar-month-outline" size={18} color="#4B5563"/>
                        <Text className="text-sm text-gray-700 ml-1.5">{formatDate(blog.createdAt)}</Text>
                    </View>
                    {/* <View className="flex-row items-center mb-2 sm:mb-0">
                        <MaterialCommunityIcons name="account-circle-outline" size={18} color="#4B5563" />
                        <Text className="text-sm text-gray-700 ml-1.5">{authorName}</Text>
                    </View>
                    <View className="flex-row items-center mb-2 sm:mb-0">
                        <Ionicons name="eye-outline" size={18} color="#4B5563" />
                        <Text className="text-sm text-gray-700 ml-1.5">{viewCount.toLocaleString()} lượt xem</Text>
                    </View> */}
                </View>

                {/* Content Separator */}
                <View className="border-b border-gray-200 my-6"/>

                {/* Content - Render HTML if content is HTML, otherwise render as plain text */}
                {/* For now, assuming plain text or simple HTML that React Native Text can handle.
                    If complex HTML, a WebView or html-renderer library would be needed.
                */}
                <Text className="text-lg text-justify text-gray-800 leading-relaxed whitespace-pre-line">
                    {blog.content.replace(/<[^>]+>/g, '')} {/* Basic HTML tag removal */}
                </Text>


                {/* Tags Example (nếu có) - Placeholder for now */}
                <View className="mt-8 pt-6 border-t border-gray-200">
                    <Text className="text-base font-semibold text-gray-500 mb-3">CHỦ ĐỀ LIÊN QUAN:</Text>
                    <View className="flex-row flex-wrap">
                        {[categoryName, "Bài Viết Hay", "Chia Sẻ"].map(tag => (
                            <View key={tag} className="bg-gray-100 rounded-full px-4 py-1.5 mr-2 mb-2 shadow-sm">
                                <Text className="text-xs text-gray-700 font-medium">{tag.toUpperCase()}</Text>
                            </View>))}
                    </View>
                </View>
            </View>
        </ScrollView>);
}

export default BlogDetailScreen;

/* ===== src\screens\blog\BlogScreen.jsx ===== */
// src/screens/blog/BlogScreen.jsx
import { blogService } from '@/services'; // Chỉ cần blogService
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useCallback, useEffect, useState } from 'react';
import { ActivityIndicator, FlatList, Image, RefreshControl, SafeAreaView, Text, TextInput, TouchableOpacity, View } from 'react-native';

const createExcerpt = (content, maxLength = 100) => {
    if (!content) return "";
    // Remove HTML tags for excerpt
    const plainText = content.replace(/<[^>]+>/g, '');
    if (plainText.length <= maxLength) return plainText;
    return plainText.substring(0, maxLength).trim() + "...";
};

const formatDate = (isoString) => {
    if (!isoString) return 'N/A';
    try {
        const date = new Date(isoString);
        return `${date.getDate()}/${date.getMonth() + 1}/${date.getFullYear()}`;
    } catch (e) {
        return 'N/A';
    }
};

const BlogListItem = ({ blog, onPress, categoryName }) => {
    return (
        <TouchableOpacity
            onPress={onPress}
            className="bg-white rounded-xl shadow-lg overflow-hidden mx-4 my-3 active:opacity-80"
        >
            <Image
                source={{ uri: blog.thumbnail }} // API đã trả về URL đầy đủ
                className="w-full h-52"
                contentFit="cover"
                placeholder={{ uri: 'https://via.placeholder.com/400x250/e0e0e0/999999?text=Blog' }}
                transition={300}
            />
            <View className="p-4">
                {categoryName && (
                    <Text className="text-xs text-sky-600 font-semibold uppercase tracking-wide mb-1">
                        {categoryName}
                    </Text>
                )}
                <Text className="text-xl font-bold text-gray-800 mt-1 leading-tight" numberOfLines={2}>
                    {blog.title}
                </Text>
                <Text className="text-sm text-gray-600 mt-2" numberOfLines={3}>
                    {createExcerpt(blog.content)}
                </Text>
                <View className="flex-row justify-between items-center mt-4 pt-3 border-t border-gray-200">
                    <View className="flex-row items-center">
                        <MaterialCommunityIcons name="calendar-clock-outline" size={16} color="#4B5563" />
                        <Text className="text-xs text-gray-700 ml-1.5">{formatDate(blog.createdAt)}</Text>
                    </View>
                    {/* Author and View Count can be added if API provides them */}
                </View>
            </View>
        </TouchableOpacity>
    );
};

const CategoryFilterChip = ({ category, onPress, isSelected }) => (
    <TouchableOpacity
        onPress={onPress}
        className={`px-4 py-2 rounded-full m-1.5 border ${isSelected ? 'bg-sky-500 border-sky-500' : 'bg-white border-sky-300 active:bg-sky-100'}`}
    >
        <Text className={`font-medium text-sm ${isSelected ? 'text-white' : 'text-sky-700'}`}>{category.name}</Text>
    </TouchableOpacity>
);


function BlogScreen() {
    const router = useRouter();
    const [blogs, setBlogs] = useState([]);
    const [categories, setCategories] = useState([]);
    const [loading, setLoading] = useState(false);
    const [loadingMore, setLoadingMore] = useState(false);
    const [refreshing, setRefreshing] = useState(false);
    const [error, setError] = useState(null);

    const [pageIndex, setPageIndex] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const pageSize = 10;

    const [searchQuery, setSearchQuery] = useState('');
    const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
    const [selectedCategoryId, setSelectedCategoryId] = useState(null); // null means all categories


    // Debounce search query
    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedSearchQuery(searchQuery);
        }, 500); // 500ms delay

        return () => {
            clearTimeout(handler);
        };
    }, [searchQuery]);

    const fetchCategories = useCallback(async () => {
        // No separate loading state for categories, assumed to be quick
        try {
            const response = await blogService.getAllBlogCategories();
            if (response && response.status === 200 && response.result) {
                setCategories([{ id: null, name: 'Tất cả' }, ...response.result]); // Add "All" option
            } else {
                console.warn("Could not fetch blog categories:", response?.message);
            }
        } catch (err) {
            console.error("Error fetching blog categories:", err);
        }
    }, []);

    const fetchBlogs = useCallback(async (page = 1, isRefreshing = false, newSearch = false, newCategory = false) => {
        if (loadingMore && !isRefreshing) return;
        if (page === 1) setLoading(true);
        else if (!isRefreshing) setLoadingMore(true);

        setError(null);

        const filter = {};
        if (debouncedSearchQuery.trim()) {
            filter.title = debouncedSearchQuery.trim();
        }
        if (selectedCategoryId) {
            filter.categoryId = selectedCategoryId;
        }

        try {
            const response = await blogService.getAllBlogs(filter, page, pageSize);
            if (response && response.status === 200 && response.result) {
                const newBlogs = response.result.data || [];
                if (isRefreshing || page === 1 || newSearch || newCategory) {
                    setBlogs(newBlogs);
                } else {
                    setBlogs(prevBlogs => [...prevBlogs, ...newBlogs]);
                }
                setTotalPages(response.result.totalPages || 1);
                setPageIndex(page);
            } else {
                throw new Error(response?.message || "Không thể tải danh sách bài viết.");
            }
        } catch (err) {
            console.error("Error fetching blogs:", err);
            setError(err.message);
            if (page === 1) setBlogs([]); // Clear blogs on initial load error
        } finally {
            setLoading(false);
            setLoadingMore(false);
            if (isRefreshing) setRefreshing(false);
        }
    }, [debouncedSearchQuery, selectedCategoryId, pageSize, loadingMore]);

    useEffect(() => {
        fetchCategories();
    }, [fetchCategories]);

    useEffect(() => {
        // Fetch blogs when debounced search query or category changes
        fetchBlogs(1, false, true, true); // isNewSearch = true, isNewCategory = true to reset list
    }, [debouncedSearchQuery, selectedCategoryId, fetchBlogs]);


    const handleRefresh = () => {
        setRefreshing(true);
        fetchBlogs(1, true);
    };

    const handleLoadMore = () => {
        if (!loadingMore && pageIndex < totalPages) {
            fetchBlogs(pageIndex + 1);
        }
    };

    const handleBlogPostPress = (blog) => {
        router.push(`/blog/${blog.id}`); // API get by ID
    };

    const getCategoryNameById = useCallback((categoryId) => {
        const category = categories.find(cat => cat.id === categoryId);
        return category ? category.name : 'Chưa phân loại';
    }, [categories]);

    const renderFooter = () => {
        if (!loadingMore) return null;
        return <ActivityIndicator style={{ marginVertical: 20 }} size="large" color="#0EA5E9" />;
    };


    return (
        <SafeAreaView className="flex-1 bg-slate-100">
            {/* Search Bar */}
            <View className="bg-white p-3 border-b border-gray-200 shadow-sm">
                <View className="flex-row items-center bg-slate-100 rounded-lg px-3 py-2.5">
                    <Ionicons name="search-outline" size={22} color="#6B7280" className="mr-2" />
                    <TextInput
                        className="flex-1 text-base text-gray-800"
                        placeholder="Tìm kiếm bài viết..."
                        placeholderTextColor="#9CA3AF"
                        value={searchQuery}
                        onChangeText={setSearchQuery}
                    />
                    {searchQuery ? (
                        <TouchableOpacity onPress={() => setSearchQuery('')}>
                            <Ionicons name="close-circle" size={20} color="#9CA3AF" />
                        </TouchableOpacity>
                    ) : null}
                </View>
            </View>

            {/* Category Filters */}
            {categories.length > 1 && ( // Show if more than "All" category exists
                <View className="py-2 bg-white border-b border-gray-200">
                    <FlatList
                        data={categories}
                        renderItem={({ item }) => (
                            <CategoryFilterChip
                                category={item}
                                onPress={() => {
                                    setSelectedCategoryId(item.id);
                                    setPageIndex(1); // Reset page index on category change
                                }}
                                isSelected={selectedCategoryId === item.id}
                            />
                        )}
                        keyExtractor={item => item.id ? item.id.toString() : 'all_categories'}
                        horizontal
                        showsHorizontalScrollIndicator={false}
                        contentContainerStyle={{ paddingHorizontal: 10 }}
                    />
                </View>
            )}


            {loading && pageIndex === 1 && !refreshing ? (
                <View className="flex-1 justify-center items-center">
                    <ActivityIndicator size="large" color="#0EA5E9" />
                </View>
            ) : error && blogs.length === 0 ? ( // Show error only if no blogs are displayed
                <View className="flex-1 justify-center items-center p-5">
                    <Ionicons name="cloud-offline-outline" size={70} color="#CBD5E1" />
                    <Text className="text-lg font-semibold text-gray-500 mt-4">Lỗi tải dữ liệu</Text>
                    <Text className="text-gray-400 mt-1 text-center mb-3">{error}</Text>
                    <TouchableOpacity
                        onPress={() => fetchBlogs(1, true)}
                        className="bg-sky-500 px-5 py-2.5 rounded-lg shadow active:bg-sky-600"
                    >
                        <Text className="text-white font-medium">Thử lại</Text>
                    </TouchableOpacity>
                </View>
            ) : blogs.length === 0 && !loading ? (
                <View className="flex-1 justify-center items-center p-5">
                    <MaterialCommunityIcons name="text-box-search-outline" size={70} color="#CBD5E1" />
                    <Text className="text-xl font-semibold text-gray-500 mt-4">Không tìm thấy bài viết</Text>
                    <Text className="text-gray-400 mt-1 text-center">
                        Vui lòng thử với từ khóa hoặc bộ lọc khác.
                    </Text>
                </View>
            ) : (
                <FlatList
                    data={blogs}
                    renderItem={({ item }) => (
                        <BlogListItem
                            blog={item}
                            onPress={() => handleBlogPostPress(item)}
                            categoryName={getCategoryNameById(item.categoryId)}
                        />
                    )}
                    keyExtractor={item => item.id.toString()}
                    contentContainerStyle={{ paddingVertical: 12 }}
                    onEndReached={handleLoadMore}
                    onEndReachedThreshold={0.5}
                    ListFooterComponent={renderFooter}
                    refreshControl={
                        <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} colors={["#0EA5E9"]} />
                    }
                />
            )}
        </SafeAreaView>
    );
}

export default BlogScreen;

/* ===== src\screens\cart\CartScreen.jsx ===== */
// src/screens/cart/CartScreen.jsx
import { useAuth } from '@/contexts/AuthContext';
import { useCart } from '@/contexts/CartContext';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import {
    ActivityIndicator,
    Alert,
    FlatList,
    Image,
    RefreshControl,
    SafeAreaView, // For potential top shadow if Tailwind custom class isn't used
    Text,
    TouchableOpacity,
    View
} from 'react-native';

const CartItem = ({ item, isSelected, onToggleSelect, onUpdateQuantity, onRemove, isUpdatingCart }) => {

    const productDetail = item.productDetails;

    if (!productDetail) {
        // Fallback if productDetails couldn't be fetched for some reason
        return (
            <View className="bg-white p-3 mb-3 rounded-lg shadow flex-row items-center">
                <Text className="text-red-500">Thông tin sản phẩm ID {item.productId} không khả dụng.</Text>
                <TouchableOpacity onPress={() => onRemove(item.id, item.productId)} className="p-2 ml-auto self-start">
                    <Ionicons name="trash-outline" size={22} color="#EF4444" />
                </TouchableOpacity>
            </View>
        );
    }
    const currentPrice = productDetail.discount || productDetail.price || 0;
    const originalPrice = productDetail.price || 0;
    const stockQuantity = productDetail.quantity || 0;

    return (
        <View className="bg-white p-3 mb-3 rounded-lg shadow flex-row items-center">
            {/* Checkbox */}
            <TouchableOpacity onPress={() => onToggleSelect(item.id)} className="p-2 mr-2" disabled={isUpdatingCart}>
                <MaterialCommunityIcons
                    name={isSelected ? "checkbox-marked-outline" : "checkbox-blank-outline"}
                    size={26}
                    color={isSelected ? "#0EA5E9" : (isUpdatingCart ? "#D1D5DB" : "#6B7280")}
                />
            </TouchableOpacity>

            {/* Product Image */}
            <Image
                source={{ uri: productDetail.thumbnail }}
                className="w-20 h-28 rounded-md mr-3"
                resizeMode="cover"
                onError={() => console.log(`Failed to load image for product ${productDetail.title}`)}
            />

            {/* Product Details */}
            <View className="flex-1 space-y-1">
                <Text className="text-sm font-semibold text-gray-800" numberOfLines={2}>{productDetail.title}</Text>
                <Text className="text-xs text-gray-500">Tác giả: {productDetail.author || 'N/A'}</Text>
                <Text className="text-sm font-bold text-sky-600">{currentPrice.toLocaleString('vi-VN')}₫</Text>
                {originalPrice > currentPrice && (
                    <Text className="text-xs text-gray-400 line-through">
                        {originalPrice.toLocaleString('vi-VN')}₫
                    </Text>
                )}

                {/* Quantity Selector */}
                <View className="flex-row items-center mt-1">
                    <TouchableOpacity
                        onPress={() => onUpdateQuantity(item.id, item.productId, -1)}
                        disabled={isUpdatingCart || item.quantity <= 1}
                        className={`p-1.5 border border-gray-300 rounded-l-md ${(isUpdatingCart || item.quantity <= 1) ? 'bg-gray-100' : 'active:bg-gray-100'}`}
                    >
                        <Ionicons name="remove" size={18} color={(isUpdatingCart || item.quantity <= 1) ? "#9CA3AF" : "#4B5563"} />
                    </TouchableOpacity>
                    <Text className="px-3 py-1 border-t border-b border-gray-300 text-sm font-medium text-gray-700">
                        {item.quantity}
                    </Text>
                    <TouchableOpacity
                        onPress={() => onUpdateQuantity(item.id, item.productId, 1)}
                        disabled={isUpdatingCart || item.quantity >= stockQuantity}
                        className={`p-1.5 border border-gray-300 rounded-r-md ${(isUpdatingCart || item.quantity >= stockQuantity) ? 'bg-gray-100' : 'active:bg-gray-100'}`}
                    >
                        <Ionicons name="add" size={18} color={(isUpdatingCart || item.quantity >= stockQuantity) ? "#9CA3AF" : "#4B5563"} />
                    </TouchableOpacity>
                </View>
                {item.quantity >= stockQuantity && stockQuantity > 0 && (
                    <Text className="text-xs text-red-500 mt-0.5">Đã đạt tối đa tồn kho</Text>
                )}
                {stockQuantity === 0 && (
                    <Text className="text-xs text-red-500 mt-0.5 font-semibold">HẾT HÀNG</Text>
                )}
            </View>

            {/* Remove Button */}
            <TouchableOpacity onPress={() => onRemove(item.id, item.productId)} className="p-2 ml-2 self-start" disabled={isUpdatingCart}>
                <Ionicons name="trash-outline" size={22} color={isUpdatingCart ? "#D1D5DB" : "#EF4444"} />
            </TouchableOpacity>
        </View>
    )
};


function CartScreen() {
    const router = useRouter();
    const { isAuthenticated } = useAuth();
    const {
        cart, // This is CartResponse { id, userId, cartProducts: List<CartProductResponseWithDetails> }
        isLoading: cartLoading, // Renamed to avoid conflict with local isLoading
        error: cartError,       // Renamed
        fetchCart,
        updateCartItemQuantity,
        removeProductFromCartByProductId,
    } = useCart();

    const [selectedItems, setSelectedItems] = useState(new Set());
    const [isRefreshing, setIsRefreshing] = useState(false);
    const [isUpdatingCartItem, setIsUpdatingCartItem] = useState(false); // General loading state for cart item operations

    // Effect to initialize/update selected items when cart changes
    useEffect(() => {
        if (cart && cart.cartProducts) {
            // Select all items by default when cart loads or changes
            // You can change this logic if you prefer items to be unselected by default
            const newSelectedItems = new Set(cart.cartProducts.map(item => item.id));
            setSelectedItems(newSelectedItems);
        } else {
            setSelectedItems(new Set()); // Clear selection if cart is null or empty
        }
    }, [cart]);


    const handleUpdateQuantity = useCallback(async (cartProductId, productId, newQuantity) => {
        // if (newQuantity <= 0) {
        //     handleRemoveItem(cartProductId, productId); // cartProductId is the cart item ID, productId is the product's actual ID
        //     return;
        // }
        setIsUpdatingCartItem(true);
        await updateCartItemQuantity(productId, newQuantity);
        // fetchCart(true) is called within updateCartItemQuantity in CartContext
        setIsUpdatingCartItem(false);
    }, [updateCartItemQuantity, removeProductFromCartByProductId]);


    const handleRemoveItem = useCallback(async (cartProductId, productId) => {
        Alert.alert(
            "Xóa sản phẩm",
            "Bạn có chắc muốn xóa sản phẩm này khỏi giỏ hàng?",
            [
                { text: "Hủy", style: "cancel" },
                {
                    text: "Xóa",
                    onPress: async () => {
                        setIsUpdatingCartItem(true);
                        await removeProductFromCartByProductId(productId);
                        // fetchCart(true) is called within removeProductFromCartByProductId
                        // Local state 'selectedItems' will be updated by the useEffect hook watching 'cart'
                        // Or, more imperatively:
                        setSelectedItems(prevSelected => {
                            const newSelected = new Set(prevSelected);
                            newSelected.delete(cartProductId); // cartProductId is item.id
                            return newSelected;
                        });
                        setIsUpdatingCartItem(false);
                    },
                    style: "destructive"
                }
            ]
        );
    }, [removeProductFromCartByProductId]);

    const handleToggleSelectItem = useCallback((cartProductId) => {
        setSelectedItems(prevSelected => {
            const newSelected = new Set(prevSelected);
            if (newSelected.has(cartProductId)) {
                newSelected.delete(cartProductId);
            } else {
                newSelected.add(cartProductId);
            }
            return newSelected;
        });
    }, []);

    const handleToggleSelectAll = () => {
        if (!cart || !cart.cartProducts || cart.cartProducts.length === 0) return;
        if (selectedItems.size === cart.cartProducts.length) {
            setSelectedItems(new Set());
        } else {
            setSelectedItems(new Set(cart.cartProducts.map(item => item.id)));
        }
    };

    const subtotal = useMemo(() => {
        if (!cart || !cart.cartProducts) return 0;
        return cart.cartProducts.reduce((sum, item) => {
            if (selectedItems.has(item.id) && item.productDetails) {
                const price = item.productDetails.discount || item.productDetails.price || 0;
                return sum + price * item.quantity;
            }
            return sum;
        }, 0);
    }, [cart, selectedItems]);

    const totalSelectedCount = useMemo(() => {
        if (!cart || !cart.cartProducts) return 0;
        return cart.cartProducts.reduce((count, item) => {
            if (selectedItems.has(item.id)) {
                return count + item.quantity;
            }
            return count;
        }, 0);
    }, [cart, selectedItems]);

    const handleCheckout = () => {
        if (selectedItems.size === 0) {
            Alert.alert("Giỏ hàng trống", "Vui lòng chọn ít nhất một sản phẩm để thanh toán.");
            return;
        }

        const itemsToCheckout = cart.cartProducts
            .filter(item => selectedItems.has(item.id) && item.productDetails && item.productDetails.quantity > 0) // Only checkout available items
            .map(item => ({
                productId: item.productId,
                quantity: item.quantity,
                productName: item.productDetails.title,
                price: item.productDetails.discount || item.productDetails.price, // price per unit at checkout
                thumbnail: item.productDetails.thumbnail
            }));

        if (itemsToCheckout.length === 0) {
            Alert.alert("Sản phẩm không hợp lệ", "Các sản phẩm bạn chọn không còn hàng hoặc đã hết. Vui lòng kiểm tra lại giỏ hàng.");
            return;
        }

        console.log("Tiến hành thanh toán với các sản phẩm:", itemsToCheckout);


        router.push({
            pathname: '/(app)/checkout',
            params: {
                checkoutItems: JSON.stringify(itemsToCheckout), // Stringify for navigation
                subtotalAmount: subtotal,
            }
        });
    };

    const onRefresh = useCallback(async () => {
        setIsRefreshing(true);
        await fetchCart(true); // Force refresh
        setIsRefreshing(false);
    }, [fetchCart]);


    if (!isAuthenticated) {
        return (
            <SafeAreaView className="flex-1 bg-slate-100 justify-center items-center p-5">
                <Ionicons name="lock-closed-outline" size={80} color="#CBD5E1" />
                <Text className="text-xl font-semibold text-gray-500 mt-4">Vui lòng đăng nhập</Text>
                <Text className="text-gray-400 mt-1 text-center mb-6">
                    Bạn cần đăng nhập để xem và quản lý giỏ hàng của mình.
                </Text>
                <TouchableOpacity
                    onPress={() => router.replace('/(auth)/login')}
                    className="bg-sky-500 px-6 py-3 rounded-lg shadow-md active:bg-sky-600"
                >
                    <Text className="text-white font-semibold text-base">Đăng Nhập</Text>
                </TouchableOpacity>
            </SafeAreaView>
        );
    }

    if (cartLoading && (!cart || isRefreshing)) { // Show loading if cart data is not yet available OR refreshing
        return (
            <SafeAreaView className="flex-1 justify-center items-center bg-slate-100">
                <ActivityIndicator size="large" color="#0EA5E9" />
            </SafeAreaView>
        );
    }

    if (cartError) {
        return (
            <SafeAreaView className="flex-1 bg-slate-100 justify-center items-center p-5">
                <MaterialCommunityIcons name="alert-circle-outline" size={80} color="#EF4444" />
                <Text className="text-xl font-semibold text-red-500 mt-4">Lỗi tải giỏ hàng</Text>
                <Text className="text-gray-500 mt-1 text-center mb-6">{cartError}</Text>
                <TouchableOpacity
                    onPress={onRefresh}
                    className="bg-sky-500 px-6 py-3 rounded-lg shadow-md active:bg-sky-600"
                >
                    <Text className="text-white font-semibold text-base">Thử lại</Text>
                </TouchableOpacity>
            </SafeAreaView>
        );
    }

    if (!cart || !cart.cartProducts || cart.cartProducts.length === 0) {
        return (
            <SafeAreaView className="flex-1 bg-slate-100 justify-center items-center p-5">
                <MaterialCommunityIcons name="cart-off" size={80} color="#CBD5E1" />
                <Text className="text-xl font-semibold text-gray-500 mt-4">Giỏ hàng của bạn đang trống</Text>
                <Text className="text-gray-400 mt-1 text-center mb-6">
                    Hãy khám phá và thêm những cuốn sách yêu thích vào giỏ nhé!
                </Text>
                <TouchableOpacity
                    onPress={() => router.push('/(app)/product/')}
                    className="bg-sky-500 px-6 py-3 rounded-lg shadow-md active:bg-sky-600"
                >
                    <Text className="text-white font-semibold text-base">Tiếp tục mua sắm</Text>
                </TouchableOpacity>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView className="flex-1 bg-slate-100">
            <View className="px-4 py-3 bg-white border-b border-gray-200 flex-row justify-between items-center">
                <TouchableOpacity onPress={handleToggleSelectAll} className="flex-row items-center" disabled={isUpdatingCartItem}>
                    <MaterialCommunityIcons
                        name={selectedItems.size === cart.cartProducts.length && cart.cartProducts.length > 0 ? "checkbox-multiple-marked-outline" : "checkbox-multiple-blank-outline"}
                        size={24}
                        color={isUpdatingCartItem ? "#D1D5DB" : (selectedItems.size === cart.cartProducts.length && cart.cartProducts.length > 0 ? "#0EA5E9" : "#6B7280")}
                    />
                    <Text className={`ml-2 text-sm ${isUpdatingCartItem ? "text-gray-400" : "text-gray-700"}`}>
                        {selectedItems.size === cart.cartProducts.length && cart.cartProducts.length > 0 ? "Bỏ chọn tất cả" : "Chọn tất cả"} ({cart.cartProducts.length} sản phẩm)
                    </Text>
                </TouchableOpacity>
            </View>

            <FlatList
                data={cart.cartProducts}
                renderItem={({ item }) => (
                    <CartItem
                        item={item}
                        isSelected={selectedItems.has(item.id)}
                        onToggleSelect={handleToggleSelectItem}
                        onUpdateQuantity={handleUpdateQuantity}
                        onRemove={handleRemoveItem}
                        isUpdatingCart={isUpdatingCartItem}
                    />
                )}
                keyExtractor={item => item.id.toString()} // cartProduct.id is unique
                contentContainerStyle={{ paddingHorizontal: 10, paddingTop: 10, paddingBottom: 100 }}
                showsVerticalScrollIndicator={false}
                refreshControl={
                    <RefreshControl refreshing={isRefreshing} onRefresh={onRefresh} colors={["#0EA5E9"]} />
                }
            />

            <View className="absolute bottom-0 left-0 right-0 bg-white border-t border-gray-200 p-3 shadow-top-md">
                <View className="flex-row justify-between items-center mb-2">
                    <Text className="text-sm text-gray-600">Tạm tính ({totalSelectedCount} sản phẩm):</Text>
                    <Text className="text-lg font-bold text-sky-600">
                        {subtotal.toLocaleString('vi-VN')}₫
                    </Text>
                </View>
                <TouchableOpacity
                    onPress={handleCheckout}
                    disabled={selectedItems.size === 0 || isUpdatingCartItem || cartLoading}
                    className={`py-3.5 rounded-lg shadow ${(selectedItems.size > 0 && !isUpdatingCartItem && !cartLoading) ? 'bg-sky-500 active:bg-sky-600' : 'bg-gray-300'}`}
                >
                    {(isUpdatingCartItem || cartLoading) ? (
                        <ActivityIndicator color="#FFFFFF" />
                    ) : (
                        <Text className="text-white text-center text-base font-semibold">
                            Tiến hành thanh toán
                        </Text>
                    )}
                </TouchableOpacity>
            </View>
        </SafeAreaView>
    );
}

export default CartScreen;

/* ===== src\screens\checkout\CheckoutScreen.jsx ===== */
// src/screens/checkout/CheckoutScreen.jsx
import {useAuth} from '@/contexts/AuthContext';
import {useCart} from '@/contexts/CartContext';
import {orderService, paymentService, profileService} from '@/services';
import {Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import {useLocalSearchParams, useRouter} from 'expo-router';
import React, {useCallback, useEffect, useMemo, useState} from 'react';
import {
    ActivityIndicator,
    Alert,
    FlatList,
    Image,
    Modal,
    SafeAreaView,
    ScrollView,
    StyleSheet,
    Text,
    TextInput,
    TouchableOpacity,
    View
} from 'react-native';
import WebView from 'react-native-webview';

const CheckoutItem = ({item}) => (<View className="flex-row items-center bg-white p-3 my-1.5 rounded-lg shadow-sm">
    <Image source={{uri: item.thumbnail}} className="w-16 h-20 rounded-md mr-3"/>
    <View className="flex-1">
        <Text className="text-sm font-semibold text-gray-800" numberOfLines={2}>{item.productName}</Text>
        <Text className="text-xs text-gray-500 mt-0.5">Số lượng: {item.quantity}</Text>
        <Text className="text-sm font-medium text-sky-600 mt-0.5">
            {(item.price * item.quantity).toLocaleString('vi-VN')}₫
        </Text>
    </View>
</View>);

const AddressItem = ({address, onPress, isSelected}) => (<TouchableOpacity
    onPress={onPress}
    className={`p-4 border rounded-lg mb-3 ${isSelected ? 'border-sky-500 bg-sky-50' : 'border-gray-200 bg-white'}`}
>
    <View className="flex-row justify-between items-center">
        <Text
            className={`text-base font-semibold ${isSelected ? 'text-sky-700' : 'text-gray-800'}`}>{address.fullName}</Text>
        {isSelected && <Ionicons name="checkmark-circle" size={22} color="#0EA5E9"/>}
    </View>
    <Text className="text-sm text-gray-600 mt-0.5">{address.phone}</Text>
    <Text className="text-sm text-gray-600 mt-0.5" numberOfLines={2}>{address.address}</Text>
    {address.gender &&
        <Text className="text-xs text-gray-500 mt-1">Giới tính: {address.gender === 'MALE' ? 'Nam' : 'Nữ'}</Text>}
</TouchableOpacity>);

const PAYMENT_METHODS = [{
    id: 'COD',
    label: 'Thanh toán khi nhận hàng (COD)',
    value: 0,
    icon: 'cash-outline'
}, {id: 'VNPAY', label: 'Thanh toán qua VNPay', value: 1, icon: 'wallet-outline'}, {
    id: 'MOMO',
    label: 'Thanh toán qua MoMo',
    value: 2,
    icon: 'apps-outline'
}, // Giả sử MoMo có giá trị 2
];

function CheckoutScreen() {
    const router = useRouter();
    const {user} = useAuth();
    const {removeProductFromCartByProductId} = useCart();
    const params = useLocalSearchParams();

    const parsedCheckoutItems = useMemo(() => {
        try {
            return params.checkoutItems ? JSON.parse(params.checkoutItems) : [];
        } catch (e) {
            console.error("Failed to parse checkoutItems:", e);
            return [];
        }
    }, [params.checkoutItems]);

    const subtotalAmount = useMemo(() => parseFloat(params.subtotalAmount || 0), [params.subtotalAmount]);

    // State để lưu trữ orderId khi tạo đơn hàng thành công, dùng cho điều hướng sau thanh toán
    const [currentOrderId, setCurrentOrderId] = useState(null);


    const [shippingAddresses, setShippingAddresses] = useState([]);
    const [selectedAddress, setSelectedAddress] = useState(null);
    const [selectedPaymentMethod, setSelectedPaymentMethod] = useState(PAYMENT_METHODS[0].value);
    const [note, setNote] = useState('');

    const [addressModalVisible, setAddressModalVisible] = useState(false);
    const [editAddressModalVisible, setEditAddressModalVisible] = useState(false);
    const [currentEditingAddress, setCurrentEditingAddress] = useState(null);

    const [isFetchingAddresses, setIsFetchingAddresses] = useState(true);
    const [isPlacingOrder, setIsPlacingOrder] = useState(false);

    const [paymentUrl, setPaymentUrl] = useState('');
    const [showWebViewModal, setShowWebViewModal] = useState(false);

    const shippingFee = 0; // Tạm thời
    const totalAmount = subtotalAmount + shippingFee;

    const fetchShippingAddresses = useCallback(async () => {
        setIsFetchingAddresses(true);
        try {
            const response = await profileService.getMyShippingProfiles(1, 50);
            if (response && response.status === 200 && response.result && response.result.data) {
                const fetchedAddresses = response.result.data;
                setShippingAddresses(fetchedAddresses);
                if (fetchedAddresses.length > 0) {
                    const defaultAddress = fetchedAddresses.find(addr => addr.isDefault) || fetchedAddresses[0];
                    setSelectedAddress(defaultAddress);
                } else {
                    setSelectedAddress(null); // Không có địa chỉ nào
                }
            } else {
                setShippingAddresses([]);
                setSelectedAddress(null);
            }
        } catch (error) {
            Alert.alert("Lỗi", "Không thể tải danh sách địa chỉ giao hàng.");
        } finally {
            setIsFetchingAddresses(false);
        }
    }, []);

    useEffect(() => {
        fetchShippingAddresses();
    }, [fetchShippingAddresses]);

    const handleSelectAddress = (address) => {
        setSelectedAddress(address);
        setAddressModalVisible(false);
    };

    const handleOpenEditAddressModal = (address = null) => {
        setCurrentEditingAddress(address);
        setEditAddressModalVisible(true);
    };

    const handleSaveAddress = async (addressData) => {
        try {
            setIsFetchingAddresses(true);
            if (currentEditingAddress && currentEditingAddress.id) {
                await profileService.updateShippingProfile(currentEditingAddress.id, addressData);
            } else {
                await profileService.createShippingProfile(addressData);
            }
            await fetchShippingAddresses();
            setEditAddressModalVisible(false);
            setCurrentEditingAddress(null);
            Alert.alert("Thành công", "Địa chỉ đã được lưu.");
        } catch (error) {
            Alert.alert("Lỗi", error?.message || "Không thể lưu địa chỉ.");
        } finally {
            setIsFetchingAddresses(false);
        }
    };

    const handlePlaceOrder = async () => {
        if (!selectedAddress) {
            Alert.alert("Thiếu thông tin", "Vui lòng chọn địa chỉ giao hàng.");
            return;
        }
        if (parsedCheckoutItems.length === 0) {
            Alert.alert("Giỏ hàng trống", "Không có sản phẩm nào để đặt hàng.");
            return;
        }

        setIsPlacingOrder(true);
        const orderData = {
            profileId: selectedAddress.id,
            paymentMethod: selectedPaymentMethod,
            note: note.trim(),
            orderProducts: parsedCheckoutItems.map(item => ({
                productId: item.productId, quantity: item.quantity,
            })),
        };

        try {
            const orderResponse = await orderService.createOrder(orderData);

            if (orderResponse && orderResponse.status === 201 && orderResponse.result) {
                const createdOrder = orderResponse.result;
                setCurrentOrderId(createdOrder.id); // ⭐ Lưu orderId

                parsedCheckoutItems.forEach(item => {
                    removeProductFromCartByProductId(item.productId);
                });

                if (selectedPaymentMethod === 0) { // COD
                    Alert.alert("Đặt hàng thành công!", `Đơn hàng #${createdOrder.id} của bạn đã được tạo. Chúng tôi sẽ sớm liên hệ với bạn.`);
                    router.replace({pathname: '/(app)/account/order-history'});
                } else { // Online payment
                    let paymentApiResponse;
                    try {
                        if (selectedPaymentMethod === 1) { // VNPay
                            paymentApiResponse = await paymentService.getVNPayPaymentUrl(createdOrder.id);
                        } else if (selectedPaymentMethod === 2) { // MoMo
                            paymentApiResponse = await paymentService.createMomoPayment(createdOrder.id);
                        }

                        console.log("Payment API Response:", paymentApiResponse);

                        if (paymentApiResponse && paymentApiResponse.status === 200 && paymentApiResponse.result && paymentApiResponse.result.payUrl) {
                            setPaymentUrl(paymentApiResponse.result.payUrl);
                            setShowWebViewModal(true);
                        } else {
                            Alert.alert("Lỗi thanh toán", paymentApiResponse?.message || "Không thể tạo yêu cầu thanh toán. Đơn hàng của bạn (#" + createdOrder.id + ") đã được ghi nhận, vui lòng thử thanh toán lại hoặc liên hệ CSKH.");
                            router.replace({
                                pathname: '/(app)/account/order-details', params: {orderId: createdOrder.id}
                            });
                        }
                    } catch (paymentError) {
                        console.error("Payment initiation error:", paymentError);
                        Alert.alert("Lỗi khởi tạo thanh toán", paymentError?.message || "Không thể khởi tạo thanh toán. Đơn hàng (#" + createdOrder.id + ") đã được tạo.");
                        router.replace({pathname: '/(app)/account/order-details', params: {orderId: createdOrder.id}});
                    }
                }
            } else {
                Alert.alert("Đặt hàng thất bại", orderResponse?.message || "Đã có lỗi xảy ra, vui lòng thử lại.");
            }
        } catch (error) {
            console.error("Place order error:", error);
            Alert.alert("Lỗi đặt hàng", error?.message || "Không thể đặt hàng. Vui lòng kiểm tra lại thông tin.");
        } finally {
            setIsPlacingOrder(false);
        }
    };

    const handleWebViewNavigation = (navState) => {
        const {url} = navState;

        console.log("WebView Navigating to (QUAN TRỌNG):", url);

        const isVNPayReturn = url.includes('vnpay_return'); // Điều chỉnh cho đúng path của bạn

        const isMoMoReturn = url.includes('momo_return');   // Điều chỉnh cho đúng path của bạn

        const isLocalRedirectSuccess = url.startsWith('http://localhost:3000');

        if (isLocalRedirectSuccess) {
            console.log("✅ Matched a payment completion URL. Closing WebView.");
            console.log("   isLocalRedirectSuccess:", isLocalRedirectSuccess, "isVNPayReturn:", isVNPayReturn, "isMoMoReturn:", isMoMoReturn);

            setShowWebViewModal(false);
            setPaymentUrl(''); // Dọn dẹp URL thanh toán

            Alert.alert("Hoàn tất thanh toán", "Giao dịch của bạn đã được xử lý. Chúng tôi sẽ chuyển bạn đến chi tiết đơn hàng.", [{
                text: "OK", onPress: () => {
                    router.replace('/(app)/account/order-history');
                }
            }]);
        }
    };

    if (isFetchingAddresses && shippingAddresses.length === 0 && !selectedAddress) {
        return <View className="flex-1 justify-center items-center"><ActivityIndicator size="large"
                                                                                       color="#0EA5E9"/></View>;
    }

    return (<SafeAreaView className="flex-1 bg-slate-100">
        <ScrollView showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
            {/* Address Section */}
            <View className="p-4 bg-white m-3 rounded-lg shadow-sm">
                <Text className="text-lg font-semibold text-gray-800 mb-2">Địa chỉ giao hàng</Text>
                {isFetchingAddresses && !selectedAddress ? (
                    <ActivityIndicator color="#0EA5E9"/>) : selectedAddress ? (<View>
                    <Text
                        className="text-base font-medium text-gray-700">{selectedAddress.fullName} - {selectedAddress.phone}</Text>
                    <Text className="text-sm text-gray-600 mt-0.5"
                          numberOfLines={2}>{selectedAddress.address}</Text>
                </View>) : (
                    <Text className="text-gray-500">Chưa có địa chỉ nào được chọn hoặc không tải được địa
                        chỉ.</Text>)}
                <TouchableOpacity
                    onPress={() => setAddressModalVisible(true)}
                    className="mt-2 bg-sky-100 py-2 px-3 rounded-md self-start active:bg-sky-200"
                    disabled={isFetchingAddresses}
                >
                    <Text className="text-sky-600 font-medium text-sm">
                        {selectedAddress ? "Thay đổi địa chỉ" : "Chọn hoặc thêm địa chỉ"}
                    </Text>
                </TouchableOpacity>
            </View>

            {/* Product List */}
            <View className="m-3">
                <Text className="text-lg font-semibold text-gray-800 mb-1 ml-1">Sản phẩm đặt mua</Text>
                {parsedCheckoutItems.length > 0 ? parsedCheckoutItems.map(item => <CheckoutItem
                        key={item.productId?.toString() || Math.random().toString()} item={item}/>) :
                    <Text className="text-gray-500 bg-white p-3 rounded-lg shadow-sm">Không có sản phẩm nào trong
                        giỏ hàng.</Text>}
            </View>

            {/* Payment Method */}
            <View className="p-4 bg-white m-3 rounded-lg shadow-sm">
                <Text className="text-lg font-semibold text-gray-800 mb-3">Phương thức thanh toán</Text>
                {PAYMENT_METHODS.map(method => (<TouchableOpacity
                    key={method.id}
                    onPress={() => setSelectedPaymentMethod(method.value)}
                    className={`flex-row items-center p-3 border rounded-lg mb-2 ${selectedPaymentMethod === method.value ? 'border-sky-500 bg-sky-50' : 'border-gray-200 bg-white'}`}
                >
                    <Ionicons name={method.icon} size={22}
                              color={selectedPaymentMethod === method.value ? "#0EA5E9" : "#4B5563"}/>
                    <Text
                        className={`ml-3 text-sm font-medium ${selectedPaymentMethod === method.value ? 'text-sky-700' : 'text-gray-700'}`}>{method.label}</Text>
                </TouchableOpacity>))}
            </View>

            {/* Note */}
            <View className="p-4 bg-white m-3 rounded-lg shadow-sm">
                <Text className="text-lg font-semibold text-gray-800 mb-2">Ghi chú cho đơn hàng</Text>
                <TextInput
                    value={note}
                    onChangeText={setNote}
                    placeholder="Ví dụ: Giao hàng giờ hành chính..."
                    className="h-24 border border-gray-300 rounded-lg p-3 text-base text-gray-800 bg-white"
                    multiline
                    textAlignVertical="top"
                />
            </View>

            {/* Order Summary */}
            <View className="p-4 bg-white m-3 mt-0 rounded-lg shadow-sm">
                <Text className="text-lg font-semibold text-gray-800 mb-3">Tổng kết đơn hàng</Text>
                <View className="flex-row justify-between mb-1.5">
                    <Text className="text-sm text-gray-600">Tổng tiền hàng:</Text>
                    <Text
                        className="text-sm text-gray-800 font-medium">{subtotalAmount.toLocaleString('vi-VN')}₫</Text>
                </View>
                <View className="flex-row justify-between mb-2">
                    <Text className="text-sm text-gray-600">Phí vận chuyển:</Text>
                    <Text
                        className="text-sm text-gray-800 font-medium">{shippingFee.toLocaleString('vi-VN')}₫</Text>
                </View>
                <View className="border-t border-gray-200 pt-2 mt-1 flex-row justify-between items-center">
                    <Text className="text-base font-bold text-gray-800">Tổng thanh toán:</Text>
                    <Text className="text-xl font-bold text-sky-600">{totalAmount.toLocaleString('vi-VN')}₫</Text>
                </View>
            </View>
        </ScrollView>

        {/* Place Order Button */}
        <View className="p-3 bg-white border-t border-gray-200 shadow-top-md">
            <TouchableOpacity
                onPress={handlePlaceOrder}
                disabled={isPlacingOrder || isFetchingAddresses || parsedCheckoutItems.length === 0}
                className={`py-3.5 rounded-lg shadow ${isPlacingOrder || isFetchingAddresses || parsedCheckoutItems.length === 0 ? 'bg-gray-300' : 'bg-red-500 active:bg-red-600'}`}
            >
                {isPlacingOrder ? (<ActivityIndicator color="#FFFFFF"/>) : (
                    <Text className="text-white text-center text-base font-semibold">Đặt Hàng</Text>)}
            </TouchableOpacity>
        </View>

        {/* Address Selection Modal */}
        <Modal
            animationType="slide"
            transparent={true}
            visible={addressModalVisible}
            onRequestClose={() => setAddressModalVisible(false)}
        >
            <View style={styles.modalOverlay}>
                <View className="bg-white w-full max-h-[75%] p-5 rounded-t-xl">
                    <View className="flex-row justify-between items-center mb-4">
                        <Text className="text-xl font-semibold text-gray-800">Chọn địa chỉ giao hàng</Text>
                        <TouchableOpacity onPress={() => setAddressModalVisible(false)} className="p-1">
                            <Ionicons name="close-circle" size={28} color="#6B7280"/>
                        </TouchableOpacity>
                    </View>
                    {isFetchingAddresses ? <ActivityIndicator/> : (<FlatList
                        data={shippingAddresses}
                        renderItem={({item}) => (<AddressItem
                            address={item}
                            onPress={() => handleSelectAddress(item)}
                            isSelected={selectedAddress?.id === item.id}
                        />)}
                        keyExtractor={item => item.id.toString()}
                        ListEmptyComponent={<Text className="text-center text-gray-500 my-5">Không có địa chỉ
                            nào. Vui lòng thêm địa chỉ mới.</Text>}
                    />)}
                    <TouchableOpacity
                        onPress={() => {
                            setAddressModalVisible(false);
                            handleOpenEditAddressModal(null);
                        }}
                        className="bg-sky-500 py-3 rounded-lg mt-4 active:bg-sky-600"
                    >
                        <Text className="text-white text-center font-semibold">Thêm địa chỉ mới</Text>
                    </TouchableOpacity>
                </View>
            </View>
        </Modal>

        {/* Add/Edit Address Modal */}
        <Modal
            animationType="slide"
            transparent={true}
            visible={editAddressModalVisible}
            onRequestClose={() => {
                setEditAddressModalVisible(false);
                setCurrentEditingAddress(null);
            }}
        >
            <View style={styles.modalOverlay}>
                <AddEditAddressForm
                    initialData={currentEditingAddress}
                    onSave={handleSaveAddress}
                    onCancel={() => {
                        setEditAddressModalVisible(false);
                        setCurrentEditingAddress(null);
                    }}
                    isSaving={isFetchingAddresses}
                />
            </View>
        </Modal>

        {/* Payment WebView Modal */}
        <Modal
            visible={showWebViewModal}
            onRequestClose={() => { // Xử lý khi người dùng nhấn nút back cứng trên Android
                Alert.alert("Hủy thanh toán?", "Bạn có chắc muốn hủy quá trình thanh toán và quay lại?", [{
                    text: "Tiếp tục thanh toán", style: "cancel", onPress: () => { /* Để modal mở */
                    }
                }, {
                    text: "Hủy và Thoát", style: "destructive", onPress: () => {
                        setShowWebViewModal(false);
                        setPaymentUrl('');
                        // Chuyển về chi tiết đơn hàng vừa tạo hoặc lịch sử đơn hàng
                        if (currentOrderId) {
                            router.replace({
                                pathname: '/(app)/account/order-details', params: {orderId: currentOrderId}
                            });
                        } else {
                            router.replace('/(app)/account/order-history/');
                        }
                    }
                }], {cancelable: true});
            }}
            animationType="slide"
        >
            <SafeAreaView style={{flex: 1, backgroundColor: '#FFFFFF'}}>
                <View style={{
                    flexDirection: 'row',
                    justifyContent: 'flex-end',
                    paddingVertical: 8,
                    paddingHorizontal: 12,
                    borderBottomWidth: 1,
                    borderBottomColor: '#e5e7eb'
                }}>
                    <TouchableOpacity onPress={() => { // Nút X để đóng WebView
                        Alert.alert("Đóng thanh toán?", "Bạn có muốn đóng cửa sổ thanh toán này không? Đơn hàng của bạn đã được tạo.", [{
                            text: "Tiếp tục thanh toán",
                            style: "cancel"
                        }, {
                            text: "Đóng", style: "default", onPress: () => {
                                setShowWebViewModal(false);
                                setPaymentUrl('');
                                router.replace('/(app)/account/order-history');
                            }
                        }]);
                    }}>
                        <Ionicons name="close" size={30} color="#374151"/>
                    </TouchableOpacity>
                </View>
                {paymentUrl ? (<WebView
                        source={{uri: paymentUrl}}
                        onNavigationStateChange={handleWebViewNavigation}
                        startInLoadingState={true}
                        renderLoading={() => <ActivityIndicator size="large" style={StyleSheet.absoluteFill}
                                                                color="#0EA5E9"/>}
                        // Thêm các props cần thiết khác cho WebView
                        // originWhitelist={['*']} // Cẩn thận khi dùng wildcard
                        // javaScriptEnabled={true}
                        // domStorageEnabled={true}
                    />) :
                    <ActivityIndicator size="large" style={{flex: 1, justifyContent: 'center'}} color="#0EA5E9"/>}
            </SafeAreaView>
        </Modal>
    </SafeAreaView>);
}

const AddEditAddressForm = ({initialData, onSave, onCancel, isSaving}) => {
    const [fullName, setFullName] = useState(initialData?.fullName || '');
    const [phone, setPhone] = useState(initialData?.phone || '');
    const [address, setAddress] = useState(initialData?.address || '');
    const [gender, setGender] = useState(initialData?.gender || 'MALE');

    const handleSubmit = () => {
        if (!fullName.trim() || !phone.trim() || !address.trim()) {
            Alert.alert("Thông tin bắt buộc", "Vui lòng điền đầy đủ họ tên, số điện thoại và địa chỉ.");
            return;
        }
        if (!/^\d{10}$/.test(phone.trim())) {
            Alert.alert("Số điện thoại không hợp lệ", "Vui lòng nhập số điện thoại gồm 10 chữ số.");
            return;
        }
        onSave({fullName: fullName.trim(), phone: phone.trim(), address: address.trim(), gender});
    };

    return (<View className="bg-white w-full p-5 rounded-t-xl max-h-[90%]">
        <View className="flex-row justify-between items-center mb-4">
            <Text className="text-xl font-semibold text-gray-800">
                {initialData ? "Chỉnh sửa địa chỉ" : "Thêm địa chỉ mới"}
            </Text>
            <TouchableOpacity onPress={onCancel} className="p-1">
                <Ionicons name="close-circle" size={28} color="#6B7280"/>
            </TouchableOpacity>
        </View>
        <ScrollView showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
            <View className="space-y-4">
                <TextInput value={fullName} onChangeText={setFullName} placeholder="Họ và tên người nhận"
                           className="border border-gray-300 p-3 rounded-lg text-base bg-white"/>
                <TextInput value={phone} onChangeText={setPhone} placeholder="Số điện thoại"
                           keyboardType="phone-pad"
                           className="border border-gray-300 p-3 rounded-lg text-base bg-white"/>
                <TextInput value={address} onChangeText={setAddress}
                           placeholder="Địa chỉ chi tiết (số nhà, đường, phường/xã, quận/huyện, tỉnh/TP)" multiline
                           className="border border-gray-300 p-3 rounded-lg text-base h-28 bg-white"
                           textAlignVertical="top"/>
                <View className="flex-row justify-start space-x-4 items-center py-2">
                    <Text className="text-base text-gray-700">Giới tính:</Text>
                    <TouchableOpacity onPress={() => setGender('MALE')} className="flex-row items-center">
                        <MaterialCommunityIcons name={gender === 'MALE' ? 'radiobox-marked' : 'radiobox-blank'}
                                                size={24} color={gender === 'MALE' ? '#0EA5E9' : '#6B7280'}/>
                        <Text className="ml-1.5 text-base">Nam</Text>
                    </TouchableOpacity>
                    <TouchableOpacity onPress={() => setGender('FEMALE')} className="flex-row items-center">
                        <MaterialCommunityIcons name={gender === 'FEMALE' ? 'radiobox-marked' : 'radiobox-blank'}
                                                size={24} color={gender === 'FEMALE' ? '#0EA5E9' : '#6B7280'}/>
                        <Text className="ml-1.5 text-base">Nữ</Text>
                    </TouchableOpacity>
                </View>
            </View>
        </ScrollView>
        <View className="flex-row mt-6 space-x-3 pt-2 border-t border-gray-200">
            <TouchableOpacity onPress={onCancel} className="flex-1 bg-gray-200 py-3 rounded-lg active:bg-gray-300">
                <Text className="text-center text-gray-700 font-semibold">Hủy</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={handleSubmit} disabled={isSaving}
                              className={`flex-1 py-3 rounded-lg ${isSaving ? 'bg-sky-300' : 'bg-sky-500 active:bg-sky-600'}`}>
                {isSaving ? <ActivityIndicator color="white"/> :
                    <Text className="text-center text-white font-semibold">Lưu địa chỉ</Text>}
            </TouchableOpacity>
        </View>
    </View>);
};

const styles = StyleSheet.create({
    modalOverlay: {
        flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'flex-end',
    },
});

export default CheckoutScreen;

/* ===== src\screens\home\HomeScreen.jsx ===== */
import {blogService, productService} from '@/services';
import {FontAwesome, Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import {useRouter} from 'expo-router';
import React, {useEffect, useState} from 'react';
import {ActivityIndicator, Alert, FlatList, Image, ScrollView, Text, TouchableOpacity, View} from 'react-native';

const StarRating = ({rating, size = 14, reviewCount = 0}) => {
    const fullStars = Math.floor(rating);
    const halfStar = rating % 1 >= 0.5;
    const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);
    return (<View className="flex-row items-center">
        {[...Array(fullStars)].map((_, i) => <FontAwesome key={`full_${i}`} name="star" size={size}
                                                          color="#FFC107"/>)}
        {halfStar && <FontAwesome name="star-half-empty" size={size} color="#FFC107"/>}
        {[...Array(emptyStars)].map((_, i) => <FontAwesome key={`empty_${i}`} name="star-o" size={size}
                                                           color="#FFC107"/>)}
        <Text
            className="text-xs text-gray-600 ml-1">{rating ? rating.toFixed(1) : 'Mới'}{reviewCount > 0 ? ` (${reviewCount})` : ''}</Text>
    </View>);
};

const ProductCard = ({product, onPress}) => {
    return (<TouchableOpacity onPress={onPress}
                              className="bg-white rounded-lg shadow-md p-3 m-2 w-40 overflow-hidden active:opacity-80">
        <Image
            source={{uri: product.thumbnail}}
            className="w-full h-48 rounded-md"
            contentFit="cover"
            placeholder={{uri: 'https://via.placeholder.com/200x300/e0e0e0/999999?text=Book'}}
            transition={300}
        />
        <Text className="text-sm font-semibold mt-2 text-gray-800" numberOfLines={2}>{product.title}</Text>
        <Text className="text-xs text-gray-500 mt-0.5" numberOfLines={1}>{product.author}</Text>
        <View className="mt-1">
            <Text className="text-sm font-bold text-sky-600">
                {product.discount?.toLocaleString('vi-VN')}₫
            </Text>
            {product.price > product.discount && (<Text className="text-xs text-gray-400 line-through">
                {product.price?.toLocaleString('vi-VN')}₫
            </Text>)}
        </View>
        {product.discountPercent > 0 && (<View className="absolute top-1 right-1 bg-red-500 px-1.5 py-0.5 rounded-full">
            <Text
                className="text-white text-[10px] font-semibold">-{Math.round(product.discountPercent)}%</Text>
        </View>)}
        <View className="mt-1">
            <StarRating rating={product.averageRate} reviewCount={product.rates?.length || 0}/>
        </View>
    </TouchableOpacity>);
};

const categoryIcons = {
    "Văn Học": "book-open-page-variant-outline",
    "Kinh Tế": "finance",
    "Kỹ Năng Sống": "account-heart-outline",
    "Thiếu Nhi": "human-child",
    "Sách Nước Ngoài": "translate",
    "Lịch Sử": "bank",
    "Công nghệ": "laptop-chromebook",
    "Lập trình": "code-tags",
    "Phát triển Web": "web",
    "Mobile App": "cellphone",
    "Dữ liệu": "database-search-outline",
    "Default": "tag-outline"
};

const CategoryChip = ({category, onPress}) => {
    const iconName = categoryIcons[category.name] || categoryIcons["Default"];
    return (<TouchableOpacity
        onPress={onPress}
        className="bg-sky-100 rounded-lg p-3 m-1.5 items-center w-24 h-24 justify-center shadow active:bg-sky-200"
    >
        <MaterialCommunityIcons name={iconName} size={28} color="#0369A1"/>
        <Text className="text-xs text-sky-700 font-medium mt-1.5 text-center" numberOfLines={2}>
            {category.name}
        </Text>
    </TouchableOpacity>);
};

const createExcerpt = (content, maxLength = 100) => {
    if (!content) return "";
    const plainText = content.replace(/<[^>]+>/g, '');
    if (plainText.length <= maxLength) return plainText;
    return plainText.substring(0, maxLength).trim() + "...";
};

const BlogPostItem = ({post, onPress}) => {
    return (<TouchableOpacity
        onPress={onPress}
        className="bg-white rounded-lg shadow p-3 mx-4 mb-3 flex-row items-start active:bg-gray-50"
    >
        <Image
            source={{uri: post.thumbnail}}
            className="w-24 h-24 rounded-md mr-3"
            contentFit="cover"
            placeholder={{uri: 'https://via.placeholder.com/200x200/e0e0e0/999999?text=Blog'}}
            transition={300}
        />
        <View className="flex-1">
            <Text className="text-md font-semibold text-gray-800" numberOfLines={2}>{post.title}</Text>
            <Text className="text-xs text-gray-600 mt-1" numberOfLines={3}>{createExcerpt(post.content)}</Text>
            <Text className="text-xs text-sky-600 mt-1.5 font-medium">Đọc thêm</Text>
        </View>
    </TouchableOpacity>);
};

const PromotionalBanner = ({title, subtitle, imageUrl, ctaText, onPress}) => {
    return (<TouchableOpacity onPress={onPress}
                              className="mx-4 my-4 rounded-xl overflow-hidden shadow-lg aspect-[16/7] active:opacity-90">
        <Image source={{uri: imageUrl}} className="absolute inset-0 w-full h-full" contentFit="cover"/>
        <View className="absolute inset-0 bg-black/40 p-4 flex justify-end">
            <Text className="text-white text-xl font-bold" style={{
                textShadowColor: 'rgba(0, 0, 0, 0.75)', textShadowOffset: {width: 0, height: 1}, textShadowRadius: 2
            }}>
                {title}
            </Text>
            <Text className="text-gray-200 text-sm mt-0.5" style={{
                textShadowColor: 'rgba(0, 0, 0, 0.75)', textShadowOffset: {width: 0, height: 1}, textShadowRadius: 2
            }}>
                {subtitle}
            </Text>
            {ctaText && (<View className="mt-2 self-start bg-white/90 px-3 py-1.5 rounded-md shadow">
                <Text className="text-sky-700 font-semibold text-xs">{ctaText}</Text>
            </View>)}
        </View>
    </TouchableOpacity>);
};

const SectionLoading = () => (<View className="h-48 justify-center items-center">
    <ActivityIndicator size="large" color="#0EA5E9"/>
</View>);

const SectionError = ({message, onRetry}) => (
    <View className="h-48 justify-center items-center p-4 bg-red-50 rounded-md mx-4 my-2 border border-red-200">
        <Ionicons name="alert-circle-outline" size={32} color="#EF4444"/>
        <Text className="text-red-600 text-center mt-2 mb-3">{message || "Không thể tải dữ liệu."}</Text>
        {onRetry && (<TouchableOpacity onPress={onRetry} className="bg-red-500 px-4 py-2 rounded-md">
            <Text className="text-white font-semibold text-sm">Thử lại</Text>
        </TouchableOpacity>)}
    </View>);


function HomeScreen() {
    const router = useRouter();

    const [newestProducts, setNewestProducts] = useState([]);
    const [featuredCategories, setFeaturedCategories] = useState([]);
    const [bestSellerProducts, setBestSellerProducts] = useState([]);
    const [discountedProducts, setDiscountedProducts] = useState([]);
    const [latestBlogs, setLatestBlogs] = useState([]);

    const [loading, setLoading] = useState({
        newest: true, categories: true, bestSellers: true, blogs: true, discounted: true,
    });
    const [error, setError] = useState({
        newest: null, categories: null, bestSellers: null, blogs: null, discounted: null,
    });

    const fetchNewestProducts = async () => {
        setLoading(prev => ({...prev, newest: true}));
        setError(prev => ({...prev, newest: null}));
        try {
            const response = await productService.getActiveProducts({sortBy: 'createdAt', sortDir: 'DESC'}, 1, 6);
            if (response && response.status === 200 && response.result && response.result.data) {
                setNewestProducts(response.result.data);
            } else {
                throw new Error(response?.message || "Không thể tải sách mới nhất");
            }
        } catch (err) {
            setError(prev => ({...prev, newest: err.message || "Lỗi tải sách mới"}));
        } finally {
            setLoading(prev => ({...prev, newest: false}));
        }
    };

    const fetchFeaturedCategories = async () => {
        setLoading(prev => ({...prev, categories: true}));
        setError(prev => ({...prev, categories: null}));
        try {
            const response = await productService.getProductCategories();
            if (response && response.status === 200 && response.result) {
                const sortedCategories = response.result
                    .sort((a, b) => (a.priority || 0) - (b.priority || 0))
                    .slice(0, 6);
                setFeaturedCategories(sortedCategories);
            } else {
                throw new Error(response?.message || "Không thể tải danh mục");
            }
        } catch (err) {
            setError(prev => ({...prev, categories: err.message || "Lỗi tải danh mục"}));
        } finally {
            setLoading(prev => ({...prev, categories: false}));
        }
    };

    const fetchBestSellerProducts = async () => {
        setLoading(prev => ({...prev, bestSellers: true}));
        setError(prev => ({...prev, bestSellers: null}));
        try {
            const response = await productService.getTopRatingProducts();
            if (response && response.status === 200 && response.result) {
                setBestSellerProducts(response.result.slice(0, 6));
            } else {
                throw new Error(response?.message || "Không thể tải sách bán chạy");
            }
        } catch (err) {
            setError(prev => ({...prev, bestSellers: err.message || "Lỗi tải sách bán chạy"}));
        } finally {
            setLoading(prev => ({...prev, bestSellers: false}));
        }
    };

    const fetchDiscountedProducts = async () => {
        setLoading(prev => ({...prev, discounted: true}));
        setError(prev => ({...prev, discounted: null}));
        try {
            const response = await productService.getTopDiscountProducts();
            if (response && response.status === 200 && response.result) {
                setDiscountedProducts(response.result.slice(0, 6));
            } else {
                throw new Error(response?.message || "Không thể tải sản phẩm khuyến mãi");
            }
        } catch (err) {
            setError(prev => ({...prev, discounted: err.message || "Lỗi tải sản phẩm khuyến mãi"}));
        } finally {
            setLoading(prev => ({...prev, discounted: false}));
        }
    };


    const fetchLatestBlogs = async () => {
        setLoading(prev => ({...prev, blogs: true}));
        setError(prev => ({...prev, blogs: null}));
        try {
            const response = await blogService.getAllBlogs({sortDirection: 'DESC'}, 1, 3);
            if (response && response.status === 200 && response.result && response.result.data) {
                setLatestBlogs(response.result.data);
            } else {
                throw new Error(response?.message || "Không thể tải bài viết mới");
            }
        } catch (err) {
            setError(prev => ({...prev, blogs: err.message || "Lỗi tải bài viết"}));
        } finally {
            setLoading(prev => ({...prev, blogs: false}));
        }
    };

    useEffect(() => {
        fetchNewestProducts();
        fetchFeaturedCategories();
        fetchBestSellerProducts();
        fetchDiscountedProducts();
        fetchLatestBlogs();
    }, []);

    const handleProductPress = (product) => router.push(`/(app)/product/${product.id}`);
    const handleCategoryPress = (category) => router.push(`/(app)/product?category_id=${category.id}&category_name=${encodeURIComponent(category.name)}`);
    const handleBlogPostPress = (post) => router.push(`/(app)/blog/${post.id || post.id}`);
    const handleBannerPress = () => Alert.alert("Khuyến mãi", "Xem chi tiết các chương trình khuyến mãi (đang phát triển).");


    return (<ScrollView className="flex-1 bg-slate-50" showsVerticalScrollIndicator={false}>
        <View className="p-5 bg-sky-600">
            <Text className="text-2xl font-bold text-white">Chào mừng trở lại!</Text>
            <Text className="text-sm text-sky-100 mt-1">Khám phá những cuốn sách yêu thích của bạn.</Text>
        </View>

        <PromotionalBanner
            title="Ưu Đãi Giữa Năm!"
            subtitle="Giảm giá đến 50% cho hàng ngàn đầu sách."
            imageUrl="https://picsum.photos/seed/midyearbooks/800/350"
            ctaText="Xem Ngay"
            onPress={handleBannerPress}
        />

        <View className="my-3">
            <View className="flex-row justify-between items-center px-4 mb-1">
                <Text className="text-xl font-semibold text-gray-800">Sách Mới Nhất</Text>
                <TouchableOpacity onPress={() => router.push('/(app)/product?sort_by=createdAt&sort_dir=DESC')}>
                    <Text className="text-sm text-sky-600 font-medium">Xem tất cả</Text>
                </TouchableOpacity>
            </View>
            {loading.newest ? <SectionLoading/> : error.newest ?
                <SectionError message={error.newest} onRetry={fetchNewestProducts}/> : (<FlatList
                    data={newestProducts}
                    renderItem={({item}) => <ProductCard product={item}
                                                         onPress={() => handleProductPress(item)}/>}
                    keyExtractor={item => `newest_${item.id.toString()}`}
                    horizontal
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={{paddingHorizontal: 10, paddingVertical: 8}}
                />)}
        </View>

        <View className="my-3">
            <View className="flex-row justify-between items-center px-4 mb-1">
                <Text className="text-xl font-semibold text-gray-800">Danh Mục Nổi Bật</Text>
                <TouchableOpacity onPress={() => router.push('/(app)/product/')}>
                    <Text className="text-sm text-sky-600 font-medium">Xem tất cả</Text>
                </TouchableOpacity>
            </View>
            {loading.categories ? <SectionLoading/> : error.categories ?
                <SectionError message={error.categories} onRetry={fetchFeaturedCategories}/> : (<FlatList
                    data={featuredCategories}
                    renderItem={({item}) => <CategoryChip category={item}
                                                          onPress={() => handleCategoryPress(item)}/>}
                    keyExtractor={item => `cat_${item.id.toString()}`}
                    horizontal
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={{paddingHorizontal: 10, paddingVertical: 8}}
                />)}
        </View>

        <View className="my-3">
            <View className="flex-row justify-between items-center px-4 mb-1">
                <Text className="text-xl font-semibold text-gray-800">Sách Bán Chạy</Text>
                <TouchableOpacity onPress={() => router.push('/(app)/product?sort_by=averageRate&sort_dir=DESC')}>
                    <Text className="text-sm text-sky-600 font-medium">Xem tất cả</Text>
                </TouchableOpacity>
            </View>
            {loading.bestSellers ? <SectionLoading/> : error.bestSellers ?
                <SectionError message={error.bestSellers} onRetry={fetchBestSellerProducts}/> : (<FlatList
                    data={bestSellerProducts}
                    renderItem={({item}) => <ProductCard product={item}
                                                         onPress={() => handleProductPress(item)}/>}
                    keyExtractor={item => `bestseller_${item.id.toString()}`}
                    horizontal
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={{paddingHorizontal: 10, paddingVertical: 8}}
                />)}
        </View>

        <View className="my-3">
            <View className="flex-row justify-between items-center px-4 mb-1">
                <Text className="text-xl font-semibold text-gray-800">Sản Phẩm Khuyến Mãi</Text>
                <TouchableOpacity onPress={() => router.push('/(app)/product?sort_by=discountPercent&sort_dir=DESC')}>
                    <Text className="text-sm text-sky-600 font-medium">Xem tất cả</Text>
                </TouchableOpacity>
            </View>
            {loading.discounted ? <SectionLoading/> : error.discounted ?
                <SectionError message={error.discounted} onRetry={fetchDiscountedProducts}/> : (<FlatList
                    data={discountedProducts}
                    renderItem={({item}) => <ProductCard product={item}
                                                         onPress={() => handleProductPress(item)}/>}
                    keyExtractor={item => `discounted_${item.id.toString()}`}
                    horizontal
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={{paddingHorizontal: 10, paddingVertical: 8}}
                />)}
        </View>

        <View className="my-3 pb-4">
            <View className="flex-row justify-between items-center px-4 mb-2">
                <Text className="text-xl font-semibold text-gray-800">Tin Tức & Bài Viết</Text>
                <TouchableOpacity onPress={() => router.push('/(app)/blog/')}>
                    <Text className="text-sm text-sky-600 font-medium">Xem tất cả</Text>
                </TouchableOpacity>
            </View>
            {loading.blogs ? <SectionLoading/> : error.blogs ?
                <SectionError message={error.blogs} onRetry={fetchLatestBlogs}/> : (latestBlogs.map(post => (
                    <BlogPostItem key={post.id.toString()} post={post}
                                  onPress={() => handleBlogPostPress(post)}/>)))}
        </View>
    </ScrollView>);
}

export default HomeScreen;


/* ===== src\screens\notification\NotificationScreen.jsx ===== */
/* ===== NotificationScreen.jsx ===== */
// src/screens/notification/NotificationScreen.jsx
import {useNotification} from '@/contexts/NotificationContext';
import {Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import React, {useCallback, useState, useEffect} from 'react';
import {
    ActivityIndicator, FlatList, RefreshControl, SafeAreaView, Text, TouchableOpacity, View, Alert, ScrollView
} from 'react-native';

const timeAgo = (isoString) => {
    if (!isoString) return '';
    const date = new Date(isoString);
    const seconds = Math.floor((new Date() - date) / 1000);
    let interval = seconds / 31536000;
    if (interval > 1) return Math.floor(interval) + " năm trước";
    interval = seconds / 2592000;
    if (interval > 1) return Math.floor(interval) + " tháng trước";
    interval = seconds / 86400;
    if (interval > 1) return Math.floor(interval) + " ngày trước";
    interval = seconds / 3600;
    if (interval > 1) return Math.floor(interval) + " giờ trước";
    interval = seconds / 60;
    if (interval > 1) return Math.floor(interval) + " phút trước";
    return Math.floor(seconds) + " giây trước";
};

const NotificationIcon = ({channel, templateCode}) => {
    let iconName = "bell-outline";
    let iconColor = "#6B7280";

    if (channel === 'EMAIL') {
        iconName = "email-outline";
        iconColor = "#0284c7";
    } else if (channel === 'PUSH_NOTIFICATION') {
        iconName = "bell-ring-outline";
        iconColor = "#fb923c";
    } else if (channel === 'SMS') {
        iconName = "message-text-outline";
        iconColor = "#3b82f6";
    }

    if (templateCode) {
        if (templateCode.includes("order")) {
            iconName = "cart-check";
            iconColor = "#16a34a";
        } else if (templateCode.includes("otp")) {
            iconName = "key-variant";
            iconColor = "#f59e0b";
        }
    }
    return <MaterialCommunityIcons name={iconName} size={28} color={iconColor}/>;
};

function NotificationScreen() {
    const {
        notifications,
        unreadCount,
        isLoading,
        loadingMore,
        error,
        pageIndex,
        totalPages,
        fetchNotifications,
        deleteNotificationById,
        deleteAllNotifications,
        markAsRead,
        markAllAsRead,
    } = useNotification();

    const [isRefreshing, setIsRefreshing] = useState(false);

    const handleNotificationPress = useCallback(async (item) => {
        // Use 'id' as the primary identifier for the notification item
        if (item && !item.isRead && item.id) {
            await markAsRead(item.id);
        }
        Alert.alert(item.title, item.body || "Không có nội dung chi tiết.");
    }, [markAsRead]);

    const handleClearAllNotifications = () => {
        if (notifications.length === 0 || isLoading) return;
        Alert.alert("Xác nhận", "Bạn có chắc chắn muốn xóa tất cả thông báo không?", [{text: "Hủy", style: "cancel"}, {
            text: "Xóa Tất Cả", onPress: async () => {
                const success = await deleteAllNotifications();
                if (!success && !isLoading) {
                    Alert.alert("Lỗi", "Không thể xóa tất cả thông báo. Vui lòng thử lại.");
                }
            }, style: "destructive"
        }]);
    };

    const handleMarkAllAsRead = async () => {
        if (unreadCount === 0 || isLoading) return;
        const success = await markAllAsRead();
        if (!success && !isLoading) {
            Alert.alert("Lỗi", "Không thể đánh dấu tất cả đã đọc. Vui lòng thử lại.");
        }
    };

    const handleDeleteOneNotification = useCallback(async (id) => { // Parameter changed to id
        if (!id || isLoading) return;
        const success = await deleteNotificationById(id); // Pass 'id'
        if (!success && !isLoading) {
            Alert.alert("Lỗi", "Không thể xóa thông báo. Vui lòng thử lại.");
        }
    }, [deleteNotificationById, isLoading]);

    const onRefresh = useCallback(async () => {
        setIsRefreshing(true);
        await fetchNotifications(1, true);
        setIsRefreshing(false);
    }, [fetchNotifications]);

    const loadMore = () => {
        if (!loadingMore && !isLoading && pageIndex < totalPages) {
            fetchNotifications(pageIndex + 1);
        }
    };

    const NotificationItem = React.memo(({item}) => {
        console.log(item)
        return (<TouchableOpacity
            onPress={() => handleNotificationPress(item)}
            className={`p-4 border-b border-gray-200 flex-row items-start ${!item.isRead ? 'bg-sky-50' : 'bg-white'}`}
        >
            {!item.isRead && <View className="w-2.5 h-2.5 rounded-full bg-sky-500 mr-2 mt-1.5"/>}
            <View className="mr-3 mt-1">
                <NotificationIcon channel={item.channel} templateCode={item.template_code}/>
            </View>
            <View className="flex-1">
                <Text
                    className={`text-base ${!item.isRead ? 'font-bold text-gray-900' : 'font-semibold text-gray-700'}`}>{item.title}</Text>
                <Text className="text-sm text-gray-600 mt-0.5" numberOfLines={2}>{item.body}</Text>
                <Text className="text-xs text-gray-400 mt-1.5">{timeAgo(item.sent_at || item.createdAt)}</Text>
            </View>
            <TouchableOpacity
                onPress={() => handleDeleteOneNotification(item.id)} // Use 'id'
                className="p-1 ml-2 self-center"
            >
                <Ionicons name="trash-bin-outline" size={20} color="#EF4444"/>
            </TouchableOpacity>
        </TouchableOpacity>)
    });

    if (isLoading && notifications.length === 0 && !isRefreshing) {
        return (<SafeAreaView className="flex-1 justify-center items-center bg-slate-100">
            <ActivityIndicator size="large" color="#0EA5E9"/>
        </SafeAreaView>);
    }

    if (error && notifications.length === 0 && !isLoading && !isRefreshing) {
        return (<SafeAreaView className="flex-1 bg-slate-100">
            <ScrollView
                contentContainerStyle={{flexGrow: 1, justifyContent: 'center', alignItems: 'center', padding: 20}}
                refreshControl={<RefreshControl refreshing={isRefreshing} onRefresh={onRefresh} colors={["#0EA5E9"]}
                                                tintColor={"#0EA5E9"}/>}
            >
                <MaterialCommunityIcons name="alert-circle-outline" size={70} color="#EF4444"/>
                <Text className="text-xl font-semibold text-red-500 mt-4">Lỗi tải thông báo</Text>
                <Text className="text-gray-500 mt-1 text-center mb-6">{error}</Text>
                <TouchableOpacity
                    onPress={onRefresh}
                    className="bg-sky-500 px-6 py-3 rounded-lg shadow-md active:bg-sky-600"
                >
                    <Text className="text-white font-semibold text-base">Thử lại</Text>
                </TouchableOpacity>
            </ScrollView>
        </SafeAreaView>);
    }

    return (<SafeAreaView className="flex-1 bg-gray-100">
        {(notifications.length > 0 || unreadCount > 0 || error) && (
            <View className="px-4 py-3 flex-row justify-between items-center border-b border-gray-200 bg-white">
                <TouchableOpacity onPress={handleMarkAllAsRead} disabled={unreadCount === 0 || isLoading}>
                    <Text className={`font-medium ${unreadCount > 0 && !isLoading ? 'text-sky-500' : 'text-gray-400'}`}>
                        Đánh dấu đã đọc ({unreadCount})
                    </Text>
                </TouchableOpacity>
                <TouchableOpacity onPress={handleClearAllNotifications}
                                  disabled={notifications.length === 0 || isLoading}>
                    <Text
                        className={`font-medium ${notifications.length > 0 && !isLoading ? 'text-red-500' : 'text-gray-400'}`}>Xóa
                        tất cả</Text>
                </TouchableOpacity>
            </View>)}

        {notifications.length === 0 && !isLoading && !isRefreshing && !error ? (<ScrollView
            contentContainerStyle={{flexGrow: 1, justifyContent: 'center', alignItems: 'center', padding: 20}}
            refreshControl={<RefreshControl refreshing={isRefreshing} onRefresh={onRefresh} colors={["#0EA5E9"]}
                                            tintColor={"#0EA5E9"}/>}
        >
            <Ionicons name="notifications-off-outline" size={80} color="#CBD5E1"/>
            <Text className="text-xl font-semibold text-gray-500 mt-4">Không có thông báo</Text>
            <Text className="text-gray-400 mt-1 text-center">
                Tất cả các thông báo của bạn sẽ xuất hiện ở đây.
            </Text>
        </ScrollView>) : (<FlatList
            data={notifications}
            renderItem={({item}) => <NotificationItem item={item}/>}
            keyExtractor={item => item.id?.toString() || Math.random().toString()} // Use 'id'
            contentContainerStyle={{paddingBottom: 20}}
            onEndReached={loadMore}
            onEndReachedThreshold={0.5}
            ListFooterComponent={loadingMore && !isRefreshing ?
                <ActivityIndicator style={{marginVertical: 20}} size="small" color="#0EA5E9"/> : null}
            refreshControl={<RefreshControl refreshing={isRefreshing} onRefresh={onRefresh} colors={["#0EA5E9"]}
                                            tintColor={"#0EA5E9"}/>}
        />)}
    </SafeAreaView>);
}

export default NotificationScreen;

/* ===== src\screens\product\ProductDetailScreen.jsx ===== */

import { useCart } from '@/contexts/CartContext'; // Import useCart
import { productService } from '@/services'; // Import productService
import { FontAwesome, Ionicons } from '@expo/vector-icons';
import { Stack, useRouter } from 'expo-router';
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { ActivityIndicator, Alert, Dimensions, FlatList, Image, SafeAreaView, ScrollView, Text, TouchableOpacity, View } from 'react-native';

// --- Các component UI phụ trợ (không thay đổi) ---
const StarRating = ({ rating, size = 16, color = "#FFC107", reviewCount = 0, showText = true }) => {
    const fullStars = Math.floor(rating);
    const halfStar = rating % 1 >= 0.4;
    const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);
    return (
        <View className="flex-row items-center">
            {[...Array(fullStars)].map((_, i) => <FontAwesome key={`full_${i}`} name="star" size={size} color={color} />)}
            {halfStar && <FontAwesome name="star-half-empty" size={size} color={color} />}
            {[...Array(emptyStars)].map((_, i) => <FontAwesome key={`empty_${i}`} name="star-o" size={size} color={color} />)}
            {showText && <Text className="text-sm text-gray-600 ml-2">{rating ? rating.toFixed(1) : 'Mới'} {reviewCount > 0 ? `(${reviewCount} đánh giá)` : '(chưa có đánh giá)'}</Text>}
        </View>
    );
};

const InfoRow = ({ label, value }) => (
    <View className="flex-row py-1.5">
        <Text className="w-2/5 text-sm text-gray-500">{label}:</Text>
        <Text className="flex-1 text-sm text-gray-800 font-medium">{value || 'N/A'}</Text>
    </View>
);

const ReviewItem = ({ review }) => {
    const reviewDate = review.createdAt ? new Date(review.createdAt).toLocaleDateString('vi-VN') : 'N/A';
    return (
        <View className="py-3 border-b border-gray-200">
            <View className="flex-row justify-between items-center mb-1">
                <Text className="font-semibold text-gray-700">Người dùng ID: {review.userId}</Text> 
                <StarRating rating={review.vote} size={14} showText={false} />
            </View>
            <Text className="text-xs text-gray-500 mb-1.5">{reviewDate}</Text>
            <Text className="text-gray-700 leading-relaxed">{review.comment}</Text>
        </View>
    );
};

const { width: screenWidth } = Dimensions.get('window');

// --- Component chính ProductDetailScreen ---
function ProductDetailScreen({ id: productId }) {
    const router = useRouter();
    const { addProductToCart, isLoading: isAddingToCart } = useCart(); // Lấy hàm và trạng thái từ CartContext

    const [product, setProduct] = useState(null);
    const [reviews, setReviews] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [activeImageIndex, setActiveImageIndex] = useState(0);
    const [quantity, setQuantity] = useState(1); // Thêm state cho số lượng sản phẩm

    const [categoryNames, setCategoryNames] = useState({});

    const fetchProductDetails = useCallback(async () => {
        if (!productId) {
            setError("Không có ID sản phẩm.");
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        try {
            // 1. Fetch product details
            const productResponse = await productService.getProductById(productId);
            if (productResponse && productResponse.status === 200 && productResponse.result) {
                setProduct(productResponse.result);
                setQuantity(1); // Reset quantity to 1 when a new product is loaded

                // 2. Fetch category names (if product has categories)
                if (productResponse.result.categories && productResponse.result.categories.length > 0) {
                    const catNameMap = {};
                    try {
                        const allCategoriesResponse = await productService.getProductCategories();
                        if (allCategoriesResponse && allCategoriesResponse.status === 200 && allCategoriesResponse.result) {
                            allCategoriesResponse.result.forEach(cat => {
                                catNameMap[cat.id] = cat.name;
                            });
                            setCategoryNames(catNameMap);
                        }
                    } catch (catErr) {
                        console.warn("Could not fetch category names:", catErr.message);
                    }
                }

                // 3. Fetch product reviews (first few reviews)
                const reviewsResponse = await productService.getRatesByProductId(productId, 1, 5); // Fetch first 5 reviews
                if (reviewsResponse && reviewsResponse.status === 200 && reviewsResponse.result && reviewsResponse.result.data) {
                    setReviews(reviewsResponse.result.data);
                }

            } else {
                throw new Error(productResponse?.message || "Không tìm thấy sản phẩm.");
            }
        } catch (err) {
            console.error("Error fetching product details:", err);
            setError(err.message);
        } finally {
            setLoading(false);
        }
    }, [productId]);

    useEffect(() => {
        fetchProductDetails();
    }, [fetchProductDetails]);

    // Tính toán phần trăm giảm giá
    const discountPercent = useMemo(() => {
        if (!product || !product.price || !product.discount || product.price <= product.discount) return 0;
        // product.discountPercent đã được backend tính sẵn, sử dụng nó nếu có
        return product.discountPercent || Math.round(((product.price - product.discount) / product.price) * 100);
    }, [product]);

    // Hàm tăng số lượng
    const increaseQuantity = useCallback(() => {
        if (product && quantity < product.quantity) { // Giới hạn số lượng bằng số lượng tồn kho
            setQuantity(prev => prev + 1);
        }
    }, [quantity, product]);

    // Hàm giảm số lượng
    const decreaseQuantity = useCallback(() => {
        if (quantity > 1) { // Đảm bảo số lượng không nhỏ hơn 1
            setQuantity(prev => prev - 1);
        }
    }, [quantity]);

    // Hàm thêm vào giỏ hàng
    const handleAddToCart = async () => {
        if (!product) return;
        if (product.quantity === 0) {
            Alert.alert("Hết hàng", "Sản phẩm này tạm thời hết hàng.");
            return;
        }
        if (quantity > product.quantity) {
            Alert.alert("Không đủ hàng", `Chỉ còn ${product.quantity} sản phẩm trong kho. Vui lòng giảm số lượng.`);
            return;
        }

        const success = await addProductToCart(product.id, quantity); // Gọi hàm từ CartContext
        if (success) {
            Alert.alert("Thành công", `Đã thêm ${quantity} sản phẩm "${product.title}" vào giỏ hàng!`);
            // Optionally, refresh product details if quantity in stock needs to be updated immediately
            // Or rely on CartContext to handle fetching and UI update for cart icon.
            setQuantity(1); // Reset số lượng về 1 sau khi thêm vào giỏ
        } else {
            Alert.alert("Lỗi", "Không thể thêm sản phẩm vào giỏ hàng. Vui lòng thử lại.");
        }
    };

    // Hàm render item cho carousel ảnh
    const renderImageCarousel = ({ item }) => (
        <Image
            source={{ uri: item }} // API trả về URL đầy đủ
            style={{ width: screenWidth, height: 400 }} // Đảm bảo width bằng chiều rộng màn hình
            resizeMode="contain" // Chế độ hiển thị ảnh
            placeholder={{ uri: 'https://via.placeholder.com/600x800/e0e0e0/999999?text=Book+Image' }}
            transition={300}
        />
    );

    // Xử lý sự kiện scroll để cập nhật chỉ mục ảnh đang hiển thị
    const onScrollImage = (event) => {
        const slideSize = event.nativeEvent.layoutMeasurement.width;
        const index = event.nativeEvent.contentOffset.x / slideSize;
        setActiveImageIndex(Math.round(index));
    };

    // Điều hướng đến màn hình xem tất cả đánh giá
    const handleViewAllReviews = () => {
        router.push({
            pathname: '/(app)/product/reviews',
            params: { productId: product.id }
        });
    };

    // --- Render Loading, Error, hoặc Nội dung chính ---
    if (loading) {
        return (
            <SafeAreaView className="flex-1 justify-center items-center bg-white">
                <ActivityIndicator size="large" color="#0EA5E9" />
            </SafeAreaView>
        );
    }

    if (error || !product) {
        return (
            <SafeAreaView className="flex-1 justify-center items-center bg-slate-100 p-5">
                <Stack.Screen options={{ title: 'Lỗi' }} />
                <Ionicons name="alert-circle-outline" size={70} color="#F87171" />
                <Text className="text-xl font-semibold text-gray-700 mt-4">
                    {error ? "Lỗi tải sản phẩm" : "Không tìm thấy sản phẩm"}
                </Text>
                <Text className="text-gray-500 mt-1 text-center mb-3">
                    {error || "Sản phẩm bạn đang tìm kiếm không tồn tại hoặc đã bị xóa."}
                </Text>
                <TouchableOpacity
                    onPress={() => router.canGoBack() ? router.back() : router.replace('/(app)/product/')}
                    className="mt-6 bg-sky-500 px-5 py-2.5 rounded-lg shadow active:bg-sky-600"
                >
                    <Text className="text-white font-medium">Quay lại</Text>
                </TouchableOpacity>
            </SafeAreaView>
        );
    }

    // `product.discount` là giá bán (sale_price từ DB)
    // `product.price` là giá gốc (original_price từ DB)
    const productImages = product.imageUrls && product.imageUrls.length > 0 ? product.imageUrls : [product.thumbnail];
    const isOutOfStock = product.quantity === 0;

    return (
        <SafeAreaView className="flex-1 bg-white">
            <ScrollView showsVerticalScrollIndicator={false}>
                <View className="h-[400px] bg-slate-100">
                    <FlatList
                        data={productImages}
                        renderItem={renderImageCarousel}
                        keyExtractor={(item, index) => `img_${index}`}
                        horizontal
                        pagingEnabled
                        showsHorizontalScrollIndicator={false}
                        onScroll={onScrollImage}
                        scrollEventThrottle={16}
                    />
                    {productImages.length > 1 && (
                        <View className="absolute bottom-3 left-0 right-0 flex-row justify-center items-center space-x-2">
                            {productImages.map((_, index) => (
                                <View
                                    key={`dot_${index}`}
                                    className={`h-2 w-2 rounded-full ${index === activeImageIndex ? 'bg-sky-500' : 'bg-gray-400'}`}
                                />
                            ))}
                        </View>
                    )}
                </View>

                <View className="p-4">
                    <Text className="text-2xl font-bold text-gray-800 leading-tight">{product.title}</Text>
                    <Text className="text-base text-gray-600 mt-1">Tác giả: {product.author}</Text>

                    <View className="mt-3 flex-row items-end space-x-3">
                        <Text className="text-3xl font-bold text-sky-600">
                            {product.discount?.toLocaleString('vi-VN')}₫
                        </Text>
                        {discountPercent > 0 && (
                            <Text className="text-base text-gray-400 line-through">
                                {product.price?.toLocaleString('vi-VN')}₫
                            </Text>
                        )}
                        {discountPercent > 0 && (
                            <View className="bg-red-100 px-2 py-0.5 rounded-md border border-red-300">
                                <Text className="text-red-600 text-xs font-semibold">GIẢM {Math.round(discountPercent)}%</Text>
                            </View>
                        )}
                    </View>

                    <View className="mt-3">
                        <StarRating rating={product.averageRate} reviewCount={reviews.length} />
                    </View>

                    <Text className={`mt-3 text-sm font-medium ${isOutOfStock ? 'text-red-600' : 'text-green-600'}`}>
                        {isOutOfStock ? "Tạm hết hàng" : `Còn hàng (${product.quantity} sản phẩm)`}
                    </Text>
                </View>

                <View className="h-2 bg-slate-100 my-3" />

                <View className="p-4">
                    <Text className="text-lg font-semibold text-gray-800 mb-2">Thông tin chi tiết</Text>
                    <View className="space-y-1.5">
                        <InfoRow label="Nhà xuất bản" value={product.publisher} />
                        <InfoRow label="Năm xuất bản" value={product.publicationYear?.toString()} />
                        <InfoRow label="Số trang" value={product.pageSize?.toString()} />
                        <InfoRow label="Hình thức bìa" value={product.form} />
                        <InfoRow label="Kích thước" value={product.packageSize?.toString() + ' cm'} />
                        <InfoRow
                            label="Danh mục"
                            value={product.categories?.map(catId => categoryNames[catId] || `ID ${catId}`).join(', ') || 'N/A'}
                        />
                    </View>
                </View>

                <View className="h-2 bg-slate-100 my-3" />

                <View className="p-4">
                    <Text className="text-lg font-semibold text-gray-800 mb-2">Mô tả sản phẩm</Text>
                    <Text className="text-base text-gray-700 leading-relaxed text-justify">
                        {product.description}
                    </Text>
                </View>

                <View className="h-2 bg-slate-100 my-3" />
                <View className="p-4">
                    <View className="flex-row justify-between items-center mb-2">
                        <Text className="text-lg font-semibold text-gray-800">Đánh giá sản phẩm ({reviews.length})</Text>
                        {reviews.length > 0 && (
                            <TouchableOpacity onPress={handleViewAllReviews}> 
                                <Text className="text-sm text-sky-600 font-medium">Xem tất cả</Text>
                            </TouchableOpacity>
                        )}
                    </View>
                    {reviews.length > 0 ? (
                        reviews.map(review => <ReviewItem key={review.id.toString()} review={review} />)
                    ) : (
                        <Text className="text-gray-500">Chưa có đánh giá nào cho sản phẩm này.</Text>
                    )}
                </View>

            </ScrollView>

            <View className="border-t border-gray-200 p-3 bg-white flex-row items-center space-x-2">
                <View className="flex-row items-center border border-gray-300 rounded-lg overflow-hidden">
                    <TouchableOpacity
                        onPress={decreaseQuantity}
                        disabled={quantity <= 1 || isOutOfStock || isAddingToCart}
                        className={`p-3 ${quantity <= 1 || isOutOfStock || isAddingToCart ? 'bg-gray-100' : 'active:bg-gray-200'}`}
                    >
                        <Ionicons name="remove" size={20} color={quantity <= 1 || isOutOfStock ? "#9CA3AF" : "#4B5563"} />
                    </TouchableOpacity>
                    <Text className="px-4 py-3 text-base font-semibold text-gray-800">
                        {quantity}
                    </Text>
                    <TouchableOpacity
                        onPress={increaseQuantity}
                        disabled={isOutOfStock || quantity >= product.quantity || isAddingToCart}
                        className={`p-3 ${isOutOfStock || quantity >= product.quantity || isAddingToCart ? 'bg-gray-100' : 'active:bg-gray-200'}`}
                    >
                        <Ionicons name="add" size={20} color={isOutOfStock || quantity >= product.quantity ? "#9CA3AF" : "#4B5563"} />
                    </TouchableOpacity>
                </View>

                <TouchableOpacity
                    onPress={handleAddToCart}
                    disabled={isOutOfStock || isAddingToCart}
                    className={`flex-1 py-3.5 rounded-lg shadow ${isOutOfStock || isAddingToCart ? 'bg-gray-400' : 'bg-sky-500 active:bg-sky-600'}`}
                >
                    {isAddingToCart ? (
                        <ActivityIndicator color="#FFFFFF" />
                    ) : (
                        <Text className="text-white text-center text-base font-semibold">
                            {isOutOfStock ? "Hết hàng" : "Thêm vào giỏ"}
                        </Text>
                    )}
                </TouchableOpacity>
            </View>
        </SafeAreaView>
    );
}

export default ProductDetailScreen;

/* ===== src\screens\product\ProductReviewsScreen.jsx ===== */
// src/screens/product/ProductReviewsScreen.jsx
import { productService } from '@/services';
import { FontAwesome, Ionicons } from '@expo/vector-icons';
import React, { useCallback, useEffect, useState } from 'react';
import { ActivityIndicator, FlatList, RefreshControl, SafeAreaView, Text, View } from 'react-native';

const StarRating = ({ rating, size = 16, color = "#FFC107", showText = true }) => {
    const fullStars = Math.floor(rating);
    const halfStar = rating % 1 >= 0.4;
    const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);
    return (
        <View className="flex-row items-center">
            {[...Array(fullStars)].map((_, i) => <FontAwesome key={`full_${i}`} name="star" size={size} color={color} />)}
            {halfStar && <FontAwesome name="star-half-empty" size={size} color={color} />}
            {[...Array(emptyStars)].map((_, i) => <FontAwesome key={`empty_${i}`} name="star-o" size={size} color={color} />)}
            {showText && <Text className="text-sm text-gray-600 ml-2">{rating ? rating.toFixed(1) : 'Mới'}</Text>}
        </View>
    );
};

const ReviewItem = React.memo(({ review }) => {
    const reviewDate = review.createdAt ? new Date(review.createdAt).toLocaleDateString('vi-VN') : 'N/A';
    return (
        <View className="bg-white p-4 mb-3 mx-3 rounded-lg shadow">
            <View className="flex-row justify-between items-center mb-1">
                {/* userId từ backend là dạng number, không có username */}
                <Text className="font-semibold text-gray-700">Người dùng ID: {review.userId}</Text>
                <StarRating rating={review.vote} size={14} showText={false} />
            </View>
            <Text className="text-xs text-gray-500 mb-2">{reviewDate}</Text>
            <Text className="text-gray-700 leading-relaxed">{review.comment || "Không có bình luận."}</Text>
        </View>
    );
});

function ProductReviewsScreen({ productId }) {
    const [reviews, setReviews] = useState([]);
    const [loading, setLoading] = useState(true);
    const [loadingMore, setLoadingMore] = useState(false);
    const [refreshing, setRefreshing] = useState(false);
    const [error, setError] = useState(null);

    const [pageIndex, setPageIndex] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const pageSize = 10;

    const fetchReviews = useCallback(async (page = 1, isRefreshing = false) => {
        if (!productId) {
            setError("Không có ID sản phẩm để tải đánh giá.");
            setLoading(false);
            return;
        }
        if (!isRefreshing && page > 1 && page > totalPages) return; // Stop if no more pages

        if (page === 1) setLoading(true);
        else if (!isRefreshing) setLoadingMore(true);
        setError(null);

        try {
            const response = await productService.getRatesByProductId(productId, page, pageSize);
            if (response && response.status === 200 && response.result) {
                const newReviews = response.result.data || [];
                setReviews(prev => (page === 1 ? newReviews : [...prev, ...newReviews]));
                setTotalPages(response.result.totalPages || 1);
                setPageIndex(page);
            } else {
                throw new Error(response?.message || "Không thể tải đánh giá sản phẩm.");
            }
        } catch (err) {
            console.error("Error fetching reviews:", err);
            setError(err.message || "Đã xảy ra lỗi khi tải đánh giá.");
            if (page === 1) setReviews([]);
        } finally {
            setLoading(false);
            setLoadingMore(false);
            if (isRefreshing) setRefreshing(false);
        }
    }, [productId, totalPages]);

    useEffect(() => {
        fetchReviews(1, true); // Fetch initial data on mount
    }, [fetchReviews]);

    const onRefresh = () => {
        setRefreshing(true);
        fetchReviews(1, true);
    };

    const loadMoreReviews = () => {
        if (!loading && pageIndex < totalPages) {
            fetchReviews(pageIndex + 1);
        }
    };

    const renderFooter = () => {
        if (!loadingMore) return null;
        return <ActivityIndicator style={{ marginVertical: 20 }} size="large" color="#0EA5E9" />;
    };

    if (loading && !refreshing) {
        return (
            <SafeAreaView className="flex-1 justify-center items-center bg-white">
                <ActivityIndicator size="large" color="#0EA5E9" />
            </SafeAreaView>
        );
    }

    if (error && reviews.length === 0) {
        return (
            <SafeAreaView className="flex-1 justify-center items-center bg-slate-100 p-5">
                <Ionicons name="cloud-offline-outline" size={70} color="#CBD5E1" />
                <Text className="text-xl font-semibold text-gray-700 mt-4">Lỗi tải đánh giá</Text>
                <Text className="text-gray-500 mt-1 text-center mb-3">{error}</Text>
            </SafeAreaView>
        );
    }

    if (reviews.length === 0 && !loading && !refreshing) {
        return (
            <SafeAreaView className="flex-1 justify-center items-center bg-slate-100 p-5">
                <Ionicons name="star-outline" size={70} color="#CBD5E1" />
                <Text className="text-xl font-semibold text-gray-700 mt-4">Chưa có đánh giá nào</Text>
                <Text className="text-gray-500 mt-1 text-center">
                    Hãy là người đầu tiên đánh giá sản phẩm này!
                </Text>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView className="flex-1 bg-slate-100">
            <FlatList
                data={reviews}
                renderItem={({ item }) => <ReviewItem review={item} />}
                keyExtractor={item => item.id.toString()}
                contentContainerStyle={{ paddingTop: 10, paddingHorizontal: 0, paddingBottom: 20 }}
                onEndReached={loadMoreReviews}
                onEndReachedThreshold={0.5}
                ListFooterComponent={renderFooter}
                refreshControl={
                    <RefreshControl refreshing={refreshing} onRefresh={onRefresh} colors={["#0EA5E9"]} tintColor={"#0EA5E9"} />
                }
            />
        </SafeAreaView>
    );
}

export default ProductReviewsScreen;

/* ===== src\screens\product\ProductScreen.jsx ===== */
import {productService} from '@/services';
import {FontAwesome, Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import {useLocalSearchParams, useRouter} from 'expo-router';
import React, {useCallback, useEffect, useState} from 'react';
import {
    ActivityIndicator,
    FlatList,
    Image,
    RefreshControl,
    SafeAreaView,
    Text,
    TextInput,
    TouchableOpacity,
    View,
    ScrollView
} from 'react-native';

const StarRating = ({rating, size = 14, color = "#FFC107", reviewCount = 0}) => {
    const fullStars = Math.floor(rating);
    const halfStar = rating % 1 >= 0.4;
    const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);
    return (<View className="flex-row items-center">
        {[...Array(fullStars)].map((_, i) => <FontAwesome key={`full_${i}`} name="star" size={size}
                                                          color={color}/>)}
        {halfStar && <FontAwesome name="star-half-empty" size={size} color={color}/>}
        {[...Array(emptyStars)].map((_, i) => <FontAwesome key={`empty_${i}`} name="star-o" size={size}
                                                           color={color}/>)}
        {reviewCount > 0 && <Text className="text-xs text-gray-500 ml-1.5">({reviewCount})</Text>}
    </View>);
};

const ProductItem = ({item, onPress}) => {
    return (<TouchableOpacity
        onPress={onPress}
        className="bg-white rounded-lg shadow-md overflow-hidden m-2 flex-1 max-w-[48%] active:opacity-80"
    >
        <Image
            source={{uri: item.thumbnail}}
            className="w-full h-48"
            resizeMode="cover"
            placeholder={{uri: 'https://via.placeholder.com/270x400/e0e0e0/999999?text=Book'}}
            transition={300}
        />
        {item.discountPercent > 0 && (<View className="absolute top-2 right-2 bg-red-500 px-2 py-0.5 rounded-full">
            <Text className="text-white text-xs font-semibold">-{Math.round(item.discountPercent)}%</Text>
        </View>)}
        <View className="p-3">
            <Text className="text-sm font-semibold text-gray-800 leading-tight"
                  numberOfLines={2}>{item.title}</Text>
            <Text className="text-xs text-gray-500 mt-0.5" numberOfLines={1}>{item.author}</Text>
            <View className="mt-1.5">
                <Text className="text-base font-bold text-sky-600">
                    {item.discount?.toLocaleString('vi-VN')}₫
                </Text>
                {item.price > item.discount && (<Text className="text-xs text-gray-400 line-through">
                    {item.price?.toLocaleString('vi-VN')}₫
                </Text>)}
            </View>
            <View className="mt-1.5">
                <StarRating rating={item.averageRate} reviewCount={item.rates?.length || 0}/>
            </View>
        </View>
    </TouchableOpacity>);
};

const CategoryFilterChip = ({category, onPress, isSelected}) => (<TouchableOpacity
    onPress={onPress}
    className={`px-4 py-2 rounded-full m-1.5 border ${isSelected ? 'bg-sky-500 border-sky-500' : 'bg-white border-sky-300 active:bg-sky-100'}`}
>
    <Text className={`font-medium text-sm ${isSelected ? 'text-white' : 'text-sky-700'}`}>{category.name}</Text>
</TouchableOpacity>);

const SortOptionButton = ({label, onPress, isSelected}) => (<TouchableOpacity
    onPress={onPress}
    className={`px-3 py-1.5 rounded-md mx-1 ${isSelected ? 'bg-sky-500' : 'bg-gray-200 active:bg-gray-300'}`}
>
    <Text className={`text-xs font-medium ${isSelected ? 'text-white' : 'text-gray-700'}`}>{label}</Text>
</TouchableOpacity>);


function ProductScreen() {
    const router = useRouter();
    const params = useLocalSearchParams();

    const [products, setProducts] = useState([]);
    const [categories, setCategories] = useState([]);
    const [loading, setLoading] = useState(false);
    const [loadingMore, setLoadingMore] = useState(false);
    const [refreshing, setRefreshing] = useState(false);
    const [error, setError] = useState(null);

    const [pageIndex, setPageIndex] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const pageSize = 10;

    const [searchQuery, setSearchQuery] = useState('');
    const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

    const [selectedCategoryId, setSelectedCategoryId] = useState(null);
    const [sortBy, setSortBy] = useState('createdAt');
    const [sortDir, setSortDir] = useState('DESC');

    const sortOptions = [{label: 'Mới nhất', value: 'createdAt', dir: 'DESC'}, {
        label: 'Bán chạy', value: 'averageRate', dir: 'DESC'
    }, // Assuming averageRate proxies for best-selling
        {label: 'Giá: Thấp - Cao', value: 'discount', dir: 'ASC'}, {
            label: 'Giá: Cao - Thấp', value: 'discount', dir: 'DESC'
        }, {label: 'Giảm giá nhiều', value: 'discountPercent', dir: 'DESC'},];

    useEffect(() => {
        if (params.category_id) {
            setSelectedCategoryId(parseInt(params.category_id));
        } else {
            setSelectedCategoryId(null); // Ensure it's reset if not in params
        }

        if (params.sort_by) {
            if (params.sort_by === 'top_rating') {
                setSortBy('averageRate');
                setSortDir('DESC');
            } else if (params.sort_by === 'discountPercent') {
                setSortBy('discountPercent');
                setSortDir('DESC');
            } else {
                setSortBy(params.sort_by);
                if (params.sort_dir) {
                    setSortDir(params.sort_dir.toUpperCase());
                } else {
                    // Default sortDir for known sortBy if not provided
                    if (params.sort_by === 'createdAt') setSortDir('DESC'); else if (params.sort_by === 'averageRate') setSortDir('DESC'); else if (params.sort_by === 'discountPercent') setSortDir('DESC'); else setSortDir('ASC'); // Default for price etc.
                }
            }
        } else {
            // Reset to default if no sort_by param
            setSortBy('createdAt');
            setSortDir('DESC');
        }
    }, [params.category_id, params.sort_by, params.sort_dir]);


    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedSearchQuery(searchQuery);
        }, 500);
        return () => clearTimeout(handler);
    }, [searchQuery]);

    const fetchCategories = useCallback(async () => {
        try {
            const response = await productService.getProductCategories();
            if (response && response.status === 200 && response.result) {
                setCategories([{id: null, name: 'Tất cả'}, ...response.result]);
            }
        } catch (err) {
            console.error("Error fetching product categories:", err);
        }
    }, []);

    const fetchProducts = useCallback(async (page = 1, isRefreshing = false, newSearchOrFilter = false) => {
        if (loadingMore && !isRefreshing) return;
        if (page === 1) setLoading(true); else if (!isRefreshing) setLoadingMore(true);
        setError(null);

        const filterParams = {};
        if (debouncedSearchQuery.trim()) filterParams.title = debouncedSearchQuery.trim();
        if (selectedCategoryId) filterParams.categoryId = selectedCategoryId;
        if (sortBy) filterParams.sortBy = sortBy;
        if (sortDir) filterParams.sortDir = sortDir;

        try {
            const response = await productService.getActiveProducts(filterParams, page, pageSize);
            if (response && response.status === 200 && response.result) {
                const newProducts = response.result.data || [];
                if (isRefreshing || page === 1 || newSearchOrFilter) {
                    setProducts(newProducts);
                } else {
                    setProducts(prevProducts => [...prevProducts, ...newProducts]);
                }
                setTotalPages(response.result.totalPages || 1);
                setPageIndex(page);
            } else {
                throw new Error(response?.message || "Không thể tải danh sách sản phẩm.");
            }
        } catch (err) {
            setError(err.message);
            if (page === 1) setProducts([]);
        } finally {
            setLoading(false);
            setLoadingMore(false);
            if (isRefreshing) setRefreshing(false);
        }
    }, [debouncedSearchQuery, selectedCategoryId, sortBy, sortDir, pageSize, loadingMore]);


    useEffect(() => {
        fetchCategories();
    }, [fetchCategories]);

    useEffect(() => {
        fetchProducts(1, false, true);
    }, [debouncedSearchQuery, selectedCategoryId, sortBy, sortDir, fetchProducts]);


    const handleRefresh = () => {
        setRefreshing(true);
        fetchProducts(1, true);
    };

    const handleLoadMore = () => {
        if (!loadingMore && !loading && pageIndex < totalPages) {
            fetchProducts(pageIndex + 1);
        }
    };

    const handleProductPress = (product) => {
        router.push(`/(app)/product/${product.id}`);
    };

    const handleSortChange = (value, dir) => {
        setSortBy(value);
        setSortDir(dir);
        setPageIndex(1);
    };

    const renderFooter = () => {
        if (!loadingMore) return null;
        return <ActivityIndicator style={{marginVertical: 20}} size="large" color="#0EA5E9"/>;
    };

    return (<SafeAreaView className="flex-1 bg-slate-100">
        <View className="bg-white p-3 border-b border-gray-200 shadow-sm">
            <View className="flex-row items-center bg-slate-100 rounded-lg px-3 py-2.5">
                <Ionicons name="search-outline" size={22} color="#6B7280" className="mr-2"/>
                <TextInput
                    className="flex-1 text-base text-gray-800"
                    placeholder="Tìm kiếm sách, tác giả..."
                    placeholderTextColor="#9CA3AF"
                    value={searchQuery}
                    onChangeText={setSearchQuery}
                />
                {searchQuery ? (<TouchableOpacity onPress={() => setSearchQuery('')}>
                    <Ionicons name="close-circle" size={20} color="#9CA3AF"/>
                </TouchableOpacity>) : null}
            </View>
        </View>

        {categories.length > 1 && (<View className="py-2 bg-white border-b border-gray-200">
            <FlatList
                data={categories}
                renderItem={({item}) => (<CategoryFilterChip
                    category={item}
                    onPress={() => {
                        setSelectedCategoryId(item.id);
                        setPageIndex(1);
                    }}
                    isSelected={selectedCategoryId === item.id}
                />)}
                keyExtractor={item => item.id ? item.id.toString() : 'all_categories_product'}
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={{paddingHorizontal: 10}}
            />
        </View>)}

        <View className="px-3 py-2.5 bg-white border-b border-gray-200">
            <ScrollView horizontal showsHorizontalScrollIndicator={false}
                        contentContainerStyle={{alignItems: 'center'}}>
                {sortOptions.map(option => (<SortOptionButton
                    key={option.value + option.dir}
                    label={option.label}
                    onPress={() => handleSortChange(option.value, option.dir)}
                    isSelected={sortBy === option.value && sortDir === option.dir}
                />))}
            </ScrollView>
        </View>


        {loading && pageIndex === 1 && !refreshing ? (<View className="flex-1 justify-center items-center">
            <ActivityIndicator size="large" color="#0EA5E9"/>
        </View>) : error && products.length === 0 ? (<View className="flex-1 justify-center items-center p-5">
            <Ionicons name="cloud-offline-outline" size={70} color="#CBD5E1"/>
            <Text className="text-lg font-semibold text-gray-500 mt-4">Lỗi tải dữ liệu</Text>
            <Text className="text-gray-400 mt-1 text-center mb-3">{error}</Text>
            <TouchableOpacity
                onPress={() => fetchProducts(1, true)}
                className="bg-sky-500 px-5 py-2.5 rounded-lg shadow active:bg-sky-600"
            >
                <Text className="text-white font-medium">Thử lại</Text>
            </TouchableOpacity>
        </View>) : products.length === 0 && !loading ? (<View className="flex-1 justify-center items-center p-5">
            <MaterialCommunityIcons name="book-search-outline" size={70} color="#CBD5E1"/>
            <Text className="text-xl font-semibold text-gray-500 mt-4">Không tìm thấy sản phẩm</Text>
            <Text className="text-gray-400 mt-1 text-center">
                Vui lòng thử với từ khóa hoặc bộ lọc khác.
            </Text>
        </View>) : (<FlatList
            data={products}
            renderItem={({item}) => <ProductItem item={item} onPress={() => handleProductPress(item)}/>}
            keyExtractor={item => item.id.toString()}
            numColumns={2}
            contentContainerStyle={{paddingHorizontal: 6, paddingVertical: 8}}
            showsVerticalScrollIndicator={false}
            onEndReached={handleLoadMore}
            onEndReachedThreshold={0.5}
            ListFooterComponent={renderFooter}
            refreshControl={<RefreshControl refreshing={refreshing} onRefresh={handleRefresh}
                                            colors={["#0EA5E9"]}/>}
        />)}
    </SafeAreaView>);
}

export default ProductScreen;


/* ===== src\services\api.js ===== */
// src/services/api.js
import AsyncStorage from '@react-native-async-storage/async-storage';
import axios from 'axios';
import { router } from 'expo-router';

const API_BASE_URL = 'http://172.20.64.1:8888/api/v1'; // Đảm bảo IP này đúng và có thể truy cập từ thiết bị/emulator

const api = axios.create({
    baseURL: API_BASE_URL,
    headers: {
        // Không set 'Content-Type': 'application/json' mặc định ở đây
        // nếu bạn thường xuyên gửi FormData. Axios sẽ tự xử lý.
        // Hoặc chỉ set nếu không phải FormData.
    },
    timeout: 20000, // Tăng timeout cho upload file
});

api.interceptors.request.use(async (config) => {
    const token = await AsyncStorage.getItem('authToken');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }

    // Để Axios tự động set Content-Type và boundary cho FormData
    if (config.data instanceof FormData) {
        // KHÔNG set config.headers['Content-Type'] ở đây.
        // console.log('Request with FormData, Axios will set Content-Type.');
    } else if (!config.headers['Content-Type']) {
        // Nếu không phải FormData và chưa có Content-Type, có thể đặt mặc định là json
        config.headers['Content-Type'] = 'application/json';
    }

    return config;
}, (error) => {
    return Promise.reject(error);
});

// Response interceptor giữ nguyên
api.interceptors.response.use((response) => {
    return response.data;
}, async (error) => {
    const originalRequest = error.config;

    if (error.response) {
        const { status, data } = error.response;
        console.error('API Error:', status, data ? JSON.stringify(data) : error.message, 'for URL:', originalRequest.url);


        if (status === 401 && originalRequest.url !== '/identity/auth/login' && !originalRequest._retry) {
            originalRequest._retry = true;
            console.log('Token expired or invalid, attempting logout and redirect...');

            await AsyncStorage.multiRemove(['authToken', 'refreshToken', 'currentUser']);
            // Sử dụng router.replace để không thêm vào lịch sử điều hướng
            router.replace('/(auth)/login');
            // Trả về một lỗi cụ thể hơn để component có thể bắt và hiển thị thông báo
            return Promise.reject({ message: "Phiên đăng nhập đã hết hạn. Vui lòng đăng nhập lại.", status: 401, data: data });
        }
        // Trả về object lỗi chứa thông tin từ backend nếu có
        return Promise.reject(data || { message: error.message || 'An unknown error occurred', status: status });
    } else if (error.request) {
        console.error('Network Error (no response received):', error.request, 'for URL:', originalRequest.url);
        return Promise.reject({ message: 'Lỗi mạng. Vui lòng kiểm tra kết nối và thử lại.', status: -1 }); // -1 for network error
    } else {
        console.error('Error setting up request:', error.message, 'for URL:', originalRequest.url);
        return Promise.reject({ message: error.message || 'Có lỗi xảy ra khi gửi yêu cầu.', status: -2 }); // -2 for setup error
    }
});

export default api;

/* ===== src\services\blogService.js ===== */


/*
####################################################################
# blogService.js
####################################################################
*/
// src/services/blogService.js
import api from './api';

const blogService = {
    // GET /blog
    getAllBlogs: async (filter = {}, pageIndex = 1, pageSize = 10) => {
        const params = {
            ...filter,
            pageIndex: pageIndex > 0 ? pageIndex : 1, // API from example seems 1-based
            pageSize,
        };
        try {
            const response = await api.get('/blog/', { params });
            // axios_response_example shows pageIndex starting from 1 for blogs
            // Ensure backend BlogServiceImpl page is 0-indexed: page = pageIndex - 1
            // Or if backend is 1-indexed for this specific endpoint, keep as is.
            // Assuming example is correct and this specific endpoint uses 1-based for request.
            return response; // ApiResponse<PageResponse<BlogResponse>>
        } catch (error) {
            console.error('Get all blogs failed:', error.message || error);
            throw error;
        }
    },

    // GET /blog/{id}
    getBlogById: async (blogId) => {
        try {
            const response = await api.get(`/blog/${blogId}`);
            return response; // ApiResponse<BlogResponse>
        } catch (error) {
            console.error(`Get blog ${blogId} failed:`, error.message || error);
            throw error;
        }
    },

    // POST /blog
    createBlog: async (blogData, thumbnailFile) => {
        // blogData: { title, content, priority, categoryId }
        const formData = new FormData();
        formData.append('blog', JSON.stringify(blogData));
        formData.append('thumbnail', {
            uri: thumbnailFile.uri,
            name: thumbnailFile.fileName || `thumbnail-${Date.now()}.${thumbnailFile.uri.split('.').pop()}`,
            type: thumbnailFile.mimeType || 'image/jpeg',
        });
        try {
            const response = await api.post('/blog', formData);
            return response; // ApiResponse<BlogResponse>
        } catch (error) {
            console.error('Create blog failed:', error.message || error);
            throw error;
        }
    },

    // PUT /blog/{id}
    updateBlog: async (blogId, blogData, thumbnailFile = null) => {
        const formData = new FormData();
        formData.append('blog', JSON.stringify(blogData));
        if (thumbnailFile) {
            formData.append('thumbnail', {
                uri: thumbnailFile.uri,
                name: thumbnailFile.fileName || `thumb-update-${Date.now()}.${thumbnailFile.uri.split('.').pop()}`,
                type: thumbnailFile.mimeType || 'image/jpeg',
            });
        }
        try {
            const response = await api.put(`/blog/${blogId}`, formData);
            return response; // ApiResponse<BlogResponse>
        } catch (error) {
            console.error(`Update blog ${blogId} failed:`, error.message || error);
            throw error;
        }
    },

    // DELETE /blog/{id}
    deleteBlog: async (blogId) => {
        try {
            const response = await api.delete(`/blog/${blogId}`);
            return response; // ApiResponse<Void>
        } catch (error) {
            console.error(`Delete blog ${blogId} failed:`, error.message || error);
            throw error;
        }
    },

    // GET /blog/category
    getAllBlogCategories: async () => {
        try {
            const response = await api.get('/blog/category');
            return response; // ApiResponse<List<CategoryResponse>>
        } catch (error) {
            console.error('Get all blog categories failed:', error.message || error);
            throw error;
        }
    },

    // POST /blog/file/media - This seems redundant if createBlog handles upload.
    // But if needed for other purposes:
    uploadBlogMedia: async (mediaFile) => {
        const formData = new FormData();
        formData.append('file', {
            uri: mediaFile.uri,
            name: mediaFile.fileName || `blog-media-${Date.now()}.${mediaFile.uri.split('.').pop()}`,
            type: mediaFile.mimeType || 'application/octet-stream',
        });
        try {
            // Note: The path in api_endpoints.txt is /blog/file/media
            // The FeignClient in blog-service for FileServiceClientRepository has /file/media
            // The gateway route for file-service is /file/**, and for blog-service is /blog/**
            // If this call is intended for the FileService THROUGH the blog-service's FeignClient,
            // the path called from frontend should be /blog/file/media
            // If it's intended for the FileService directly (but prefixed by blog in gateway for some reason)
            // it still would be /blog/file/media via gateway.
            // The backend blog-service has FileServiceClientRepository with @FeignClient(name = "file-service", url = "${app.file-service.url}")
            // and methods like @PostMapping(value = "/file/media" ...).
            // This means blog-service internally calls file-service at file-service's /file/media.
            // The frontend API Gateway path for blog-service is /api/v1/blog.
            // So, POST /api/v1/blog/file/media is correct if blog-service itself exposes /file/media.
            // Based on `api_endpoints.txt` `POST blog/file/media` -> this implies a path *within* the blog service context.
            const response = await api.post('/blog/file/media', formData);
            return response; // ApiResponse<FileResponse>
        } catch (error) {
            console.error('Upload blog media failed:', error.message || error);
            throw error;
        }
    },

    // DELETE /blog/file/media/{fileName}
    deleteBlogMedia: async (fileName) => {
        try {
            const response = await api.delete(`/blog/file/media/${fileName}`);
            return response; // ApiResponse<FileResponse>
        } catch (error) {
            console.error(`Delete blog media ${fileName} failed:`, error.message || error);
            throw error;
        }
    },
};
export default blogService;

/* ===== src\services\cartService.js ===== */
// src/services/cartService.js
import api from './api';

const cartService = {
    /**
     * Thêm sản phẩm vào giỏ hàng hoặc cập nhật số lượng nếu sản phẩm đã tồn tại.
     * Backend sẽ tự động xử lý logic này.
     * @param {object} cartProductData - Dữ liệu sản phẩm trong giỏ hàng.
     *   `cartProductData` phải chứa:
     *   - `productId` (number): ID của sản phẩm.
     *   - `quantity` (number): Số lượng sản phẩm muốn thêm/cập nhật.
     * @returns {Promise<object>} ApiResponse<CartProductResponse> hoặc ApiResponse<string> nếu có lỗi.
     */
    addProductToCart: async (cartProductData) => { // { productId, quantity }
        try {
            const response = await api.post('/cart/cart-products', cartProductData);
            return response; // ApiResponse<CartProductResponse> (hoặc ApiResponse<string> tùy thuộc vào response của backend)
        } catch (error) {
            console.error('Add product to cart failed:', error.message || error);
            throw error;
        }
    },

    /**
     * Xóa một hoặc nhiều sản phẩm khỏi giỏ hàng.
     * @param {number[]} cartProductIds - Mảng các ID của CartProduct cần xóa.
     * @returns {Promise<object>} ApiResponse<string> (thường là message thành công)
     */
    removeProductsFromCart: async (cartProductIds) => { // Array<integer> of cart_product_ids
        try {
            // Đối với phương thức DELETE với body, Axios sử dụng `data` key trong config.
            const response = await api.delete('/cart/cart-products', { data: cartProductIds });
            return response; // ApiResponse<string>
        } catch (error) {
            console.error('Remove products from cart failed:', error.message || error);
            throw error;
        }
    },

    /**
     * Lấy thông tin giỏ hàng của người dùng hiện tại.
     * @returns {Promise<object>} ApiResponse<CartResponse>
     *   CartResponse: { id (cartId), userId, cartProducts: CartProduct[] }
     *   CartProduct: { id (cartProductId), cartId, productId, quantity, createdAt, updatedAt }
     *   (Lưu ý: CartProduct không có thông tin chi tiết của sản phẩm như tên, giá. Sẽ cần fetch từ productService).
     */
    getMyCart: async () => {
        try {
            // Dựa vào axios_response_example.txt, endpoint này tồn tại và trả về CartResponse.
            // Backend CartService sẽ tự động xác định user từ token JWT.
            const response = await api.get('/cart/');
            return response; // ApiResponse<CartResponse>
        } catch (error) {
            console.error('Get my cart failed:', error.message || error);
            // Quan trọng: Trả về một cấu trúc lỗi hoặc giỏ hàng rỗng để context có thể xử lý.
            // Nếu đây là lỗi 404 (giỏ hàng không tồn tại), có thể trả về một giỏ rỗng mặc định.
            if (error.status === 404) { // Giả sử backend trả về 404 nếu không tìm thấy giỏ
                return { status: 404, message: "Giỏ hàng của bạn đang trống.", result: { cartProducts: [] } };
            }
            throw error; // Ném các lỗi khác để xử lý chung
        }
    },

    // ----------------------------------------------------------------------
    // Các endpoints internal hoặc không cần dùng trực tiếp từ ứng dụng di động:
    // ----------------------------------------------------------------------

    /**
     * Endpoint nội bộ để tạo giỏ hàng cho người dùng.
     * Thường được gọi bởi Identity Service khi người dùng mới đăng ký.
     * Không nên gọi trực tiếp từ ứng dụng di động.
     * @param {object} cartCreateRequest - { userId, id (cartId) }
     * @returns {Promise<object>} ApiResponse<CartResponse>
     */
    _internalCreateCartForUser: async (cartCreateRequest) => {
        try {
            const response = await api.post('/cart/internal/users', cartCreateRequest);
            return response;
        } catch (error) {
            console.error('Internal create cart for user failed:', error.message || error);
            throw error;
        }
    }
};
export default cartService;

/* ===== src\services\categoryService.js ===== */

/*
####################################################################
# categoryService.js
####################################################################
*/
// src/services/categoryService.js
import api from './api';

const categoryService = {
    // GET /category
    getAllCategories: async (name, isAsc) => {
        const params = {};
        if (name) params.name = name;
        if (isAsc !== undefined) params.isAsc = isAsc;
        try {
            const response = await api.get('/category', { params });
            return response; // ApiResponse<List<CategoryResponse>> (tree structure)
        } catch (error) {
            console.error('Get all categories failed:', error.message || error);
            throw error;
        }
    },

    // GET /category/{id}
    getCategoryById: async (categoryId) => {
        try {
            const response = await api.get(`/category/${categoryId}`);
            return response; // ApiResponse<CategoryTreeResponse>
        } catch (error) {
            console.error(`Get category ${categoryId} failed:`, error.message || error);
            throw error;
        }
    },

    // POST /category (Admin/Staff only)
    createCategory: async (categoryData) => { // { name, priority, parentId, type }
        try {
            const response = await api.post('/category', categoryData);
            return response; // ApiResponse<CategoryResponse>
        } catch (error) {
            console.error('Create category failed:', error.message || error);
            throw error;
        }
    },

    // PUT /category/{id} (Admin/Staff only)
    updateCategory: async (categoryId, categoryData) => { // { name, priority, parentId, type }
        try {
            const response = await api.put(`/category/${categoryId}`, categoryData);
            return response; // ApiResponse<CategoryResponse>
        } catch (error) {
            console.error(`Update category ${categoryId} failed:`, error.message || error);
            throw error;
        }
    },

    // DELETE /category/{id} (Admin/Staff only)
    deleteCategory: async (categoryId) => {
        try {
            const response = await api.delete(`/category/${categoryId}`);
            return response; // ApiResponse<Void>
        } catch (error) {
            console.error(`Delete category ${categoryId} failed:`, error.message || error);
            throw error;
        }
    },

    // POST /category/seeding/{numberOfRecords} (Admin/Staff only)
    seedCategories: async (numberOfRecords) => {
        try {
            const response = await api.post(`/category/seeding/${numberOfRecords}`);
            return response; // ApiResponse<String>
        } catch (error) {
            console.error('Seed categories failed:', error.message || error);
            throw error;
        }
    },
};
export default categoryService;

/* ===== src\services\customerService.js ===== */
/*
####################################################################
# customerService.js
####################################################################
*/
// src/services/customerService.js
import api from './api';

const customerService = {
    // GET /customer (Admin/Staff only)
    getAllContacts: async (pageIndex = 1, pageSize = 10, sortDir) => {
        const params = {
            // Backend CustomerCareService uses 0-based page index for PageRequest.of
            pageIndex: pageIndex > 0 ? pageIndex : 1, // But API example uses 1-based
            pageSize,
        };
        if (sortDir) params.sortDir = sortDir;
        try {
            const response = await api.get('/customer', {params});
            // Assuming example is correct and this endpoint uses 1-based for request.
            return response; // ApiResponse<PageResponse<CustomerCareResponse>>
        } catch (error) {
            console.error('Get all customer contacts failed:', error.message || error);
            throw error;
        }
    },

    // GET /customer/{id} (Admin/Staff only)
    getContactById: async (contactId) => {
        try {
            const response = await api.get(`/customer/${contactId}`);
            return response; // ApiResponse<CustomerCareResponse>
        } catch (error) {
            console.error(`Get customer contact ${contactId} failed:`, error.message || error);
            throw error;
        }
    },

    // POST /customer
    createContact: async (contactData) => { // { name, phone, email, address, content }
        try {
            const response = await api.post('/customer/', contactData);
            return response; // ApiResponse<CustomerCareResponse>
        } catch (error) {
            console.error('Create customer contact failed:', error.message || error);
            throw error;
        }
    },

    // DELETE /customer/{id} (Admin/Staff only)
    deleteContact: async (contactId) => {
        try {
            const response = await api.delete(`/customer/${contactId}`);
            return response; // ApiResponse<Void>
        } catch (error) {
            console.error(`Delete customer contact ${contactId} failed:`, error.message || error);
            throw error;
        }
    },

    // POST /customer/seeding/{numberOfRecords} (Admin/Staff only)
    seedContacts: async (numberOfRecords) => {
        try {
            const response = await api.post(`/customer/seeding/${numberOfRecords}`);
            return response; // ApiResponse<String>
        } catch (error) {
            console.error('Seed customer contacts failed:', error.message || error);
            throw error;
        }
    },
};
export default customerService;

/* ===== src\services\fileService.js ===== */


/*
####################################################################
# fileService.js
####################################################################
*/
// src/services/fileService.js
import api from './api';

const fileService = {
    // POST /file/media
    uploadFile: async (file) => { // file: { uri, fileName, mimeType }
        const formData = new FormData();
        formData.append('file', {
            uri: file.uri,
            name: file.fileName || `upload-${Date.now()}.${file.uri.split('.').pop()}`,
            type: file.mimeType || 'application/octet-stream', // Ensure correct MIME type
        });
        try {
            const response = await api.post('/file/media', formData);
            return response; // ApiResponse<FileResponse { originalFileName, url }>
        } catch (error) {
            console.error('Upload file failed:', error.message || error);
            throw error;
        }
    },

    // GET /file/media/download/{fileName} - This returns the actual file resource
    // For mobile, usually you just need the URL to display an image or for a WebView.
    getDownloadUrl: (fileName) => {
        // Simply constructs the URL based on API base and path
        return `${api.defaults.baseURL}/file/media/download/${fileName}`;
    },

    // DELETE /file/media/{fileName}
    deleteFile: async (fileName) => {
        try {
            const response = await api.delete(`/file/media/${fileName}`);
            // Backend returns void, API spec does not specify response body, assume success if no error
            return { status: 200, message: "File deleted successfully", result: null, timestamp: new Date().toISOString() };
        } catch (error) {
            console.error(`Delete file ${fileName} failed:`, error.message || error);
            throw error;
        }
    },
};
export default fileService;

/* ===== src\services\identityService.js ===== */
import AsyncStorage from '@react-native-async-storage/async-storage';
import {Platform} from 'react-native';
import api from './api';

const AUTH_TOKEN_KEY = 'authToken';
const REFRESH_TOKEN_KEY = 'refreshToken';
const CURRENT_USER_KEY = 'currentUser';

const identityService = {
    // === Authentication ===
    login: async (credentials) => { // credentials: { username, password }
        try {
            const response = await api.post('/identity/auth/login', credentials);
            if (response && response.result && response.result.token) {
                await AsyncStorage.setItem(AUTH_TOKEN_KEY, response.result.token);
                // Assuming API might return refreshToken and user details upon login
                if (response.result.refreshToken) { // Hypothetical
                    await AsyncStorage.setItem(REFRESH_TOKEN_KEY, response.result.refreshToken);
                }
                // Fetch and store user info after login if not included in login response
                // For now, we assume login response is sufficient or getMyInfo is called separately
            }
            return response; // ApiResponse<AuthenticationResponse>
        } catch (error) {
            console.error('Login failed in identityService:', error.message || error);
            throw error;
        }
    },

    logout: async () => {
        try {
            const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
            if (token) {
                await api.post('/identity/auth/logout', {token});
            }
        } catch (apiError) {
            console.error('API Logout failed, proceeding with local logout:', apiError.message || apiError);
        } finally {
            await AsyncStorage.removeItem(AUTH_TOKEN_KEY);
            await AsyncStorage.removeItem(REFRESH_TOKEN_KEY);
            await AsyncStorage.removeItem(CURRENT_USER_KEY);
            console.log('Logged out locally, tokens and user info removed.');
        }
    },

    introspectToken: async (token) => {
        try {
            const response = await api.post('/identity/auth/introspect', {token});
            return response; // ApiResponse<IntrospectResponse>
        } catch (error) {
            console.error('Introspect token failed:', error.message || error);
            throw error;
        }
    },

    refreshToken: async () => {
        const currentRefreshToken = await AsyncStorage.getItem(REFRESH_TOKEN_KEY);
        if (!currentRefreshToken) {
            console.log('No refresh token available for refreshing session.');
            await identityService.logout();
            throw new Error('No refresh token available.');
        }
        try {
            const response = await api.post('/identity/auth/refresh-token', {token: currentRefreshToken});
            if (response && response.result && response.result.token) {
                await AsyncStorage.setItem(AUTH_TOKEN_KEY, response.result.token);
                // if (response.result.refreshToken) { // If API provides a new refresh token
                //    await AsyncStorage.setItem(REFRESH_TOKEN_KEY, response.result.refreshToken);
                // }
                return response.result.token;
            }
            await identityService.logout();
            throw new Error('Failed to refresh token, new token not received.');
        } catch (error) {
            console.error('Refresh token API call failed:', error.message || error);
            await identityService.logout();
            throw error;
        }
    },

    // === Password Recovery ===
    sendOtpForgotPassword: async (username) => {
        try {
            const response = await api.post('/identity/auth/password-recovery/otp', {username});
            return response; // ApiResponse<string>
        } catch (error) {
            console.error('Send OTP for forgot password failed:', error.message || error);
            throw error;
        }
    },

    verifyOtpForgotPassword: async (username, otp) => {
        try {
            const response = await api.post('/identity/auth/password-recovery/otp/verify', {username, otp});
            return response; // ApiResponse<VerifyOtpResponse>
        } catch (error) {
            console.error('Verify OTP for forgot password failed:', error.message || error);
            throw error;
        }
    },

    resetPasswordWithToken: async (newPassword, verificationToken) => {
        try {
            const response = await api.post('/identity/auth/password-recovery/reset', {newPassword, verificationToken});
            return response; // ApiResponse<string>
        } catch (error) {
            console.error('Reset password failed:', error.message || error);
            throw error;
        }
    },

    // === User Management ===
    register: async (userData) => { // userData: { username, password, email }
        try {
            const response = await api.post('/identity/users/register', userData);
            return response; // ApiResponse<UserResponse>
        } catch (error) {
            console.error('Registration failed in identityService:', error.message || error);
            throw error;
        }
    },

    updateMyProfileImage: async (imageFilePayload) => {
        const {fileInput, fileName, mimeType} = imageFilePayload;
        const formData = new FormData();

        console.log('🔄 Preparing FormData for profile image (identityService):');
        console.log('  ➡️ FileName:', fileName);
        console.log('  ➡️ MimeType:', mimeType);
        console.log('  ➡️ Type of fileInput:', typeof fileInput);

        if (Platform.OS === 'web' && fileInput instanceof Blob) {
            console.log('  fileInput is a Blob. Size:', fileInput.size);
            formData.append('profileImage', fileInput, fileName);
        } else if (typeof fileInput === 'string') { // For native URI
            console.log('  fileInput is a URI:', fileInput);
            formData.append('profileImage', {
                uri: fileInput, name: fileName, type: mimeType,
            });
        } else {
            console.error("❌ Invalid fileInput type in identityService.updateMyProfileImage");
            throw new Error("Loại file không hợp lệ để tải lên.");
        }

        try {
            // 👇 MODIFICATION HERE: Add headers config
            const response = await api.put('/identity/users/profile-image', formData, {
                headers: {
                    'Content-Type': 'multipart/form-data', // Explicitly set Content-Type
                },
            });
            // 👆 END MODIFICATION

            if (response && response.result) {
                await identityService.setCurrentUser(response.result);
            }
            return response;
        } catch (error) {
            console.error('❌ Update my profile image failed in identityService catch block.');
            if (error && error.status && error.message) {
                console.error(`  Interceptor Processed Error - Status: ${error.status}, Message: ${error.message}`);
                if (error.data) {
                    console.error('  Error Data:', JSON.stringify(error.data, null, 2));
                }
            } else if (error && error.message) {
                console.error('  Raw Error Message:', error.message);
            } else {
                console.error('  Unknown error structure:', JSON.stringify(error, null, 2));
            }
            throw error;
        }
    },

    updateMyPassword: async (userId, passwords) => { // passwords: { oldPassword, newPassword }
        try {
            const response = await api.patch(`/identity/users/${userId}/password`, passwords);
            return response; // ApiResponse<UserResponse>
        } catch (error) {
            console.error(`Update password for user ${userId} failed:`, error.message || error);
            throw error;
        }
    },

    // === Admin/Role Specific (usually not called from basic mobile client but included for completeness) ===
    getAllUsersForAdmin: async (pageIndex = 1, pageSize = 10) => {
        try {
            // Backend UserController uses 0-based pageIndex
            const response = await api.get('/identity/users', {
                params: {
                    pageIndex: pageIndex > 0 ? pageIndex - 1 : 0, pageSize
                }
            });
            return response; // ApiResponse<PageResponse<UserResponse>>
        } catch (error) {
            console.error('Admin: Get all users failed:', error.message || error);
            throw error;
        }
    },

    updateUserAsAdmin: async (userId, userData) => { // userData: { password, email, roles }
        try {
            const response = await api.put(`/identity/users/${userId}`, userData);
            return response; // ApiResponse<UserResponse>
        } catch (error) {
            console.error(`Admin: Update user ${userId} failed:`, error.message || error);
            throw error;
        }
    },

    deleteUserAsAdmin: async (userId) => {
        try {
            const response = await api.delete(`/identity/users/${userId}`);
            return response; // ApiResponse<UserResponse>
        } catch (error) {
            console.error(`Admin: Delete user ${userId} failed:`, error.message || error);
            throw error;
        }
    },

    seedUsersAsAdmin: async (numberOfRecords) => {
        try {
            const response = await api.post(`/identity/users/seeding/${numberOfRecords}`);
            return response; // ApiResponse<String>
        } catch (error) {
            console.error('Admin: Seed users failed:', error.message || error);
            throw error;
        }
    },

    // Permissions (Admin only)
    createPermission: async (permissionData) => { // { name, description }
        try {
            const response = await api.post('/identity/permissions', permissionData);
            return response; // ApiResponse<PermissionResponse>
        } catch (error) {
            throw error;
        }
    },
    getAllPermissions: async () => {
        try {
            const response = await api.get('/identity/permissions');
            return response; // ApiResponse<List<PermissionResponse>>
        } catch (error) {
            throw error;
        }
    },
    deletePermission: async (permissionName) => {
        try {
            const response = await api.delete(`/identity/permissions/${permissionName}`);
            return response; // ApiResponse<PermissionResponse>
        } catch (error) {
            throw error;
        }
    },

    // Roles (Admin only)
    createRole: async (roleData) => { // { name, description, permissions: ["perm1"] }
        try {
            const response = await api.post('/identity/roles', roleData);
            return response; // ApiResponse<RoleResponse>
        } catch (error) {
            throw error;
        }
    },
    getAllRoles: async () => {
        try {
            const response = await api.get('/identity/roles');
            return response; // ApiResponse<List<RoleResponse>>
        } catch (error) {
            throw error;
        }
    },
    deleteRole: async (roleName) => {
        try {
            const response = await api.delete(`/identity/roles/${roleName}`);
            return response; // ApiResponse<RoleResponse>
        } catch (error) {
            throw error;
        }
    },


    // === AsyncStorage Helpers ===
    getAuthToken: async () => AsyncStorage.getItem(AUTH_TOKEN_KEY),
    getRefreshToken: async () => AsyncStorage.getItem(REFRESH_TOKEN_KEY),
    getCurrentUser: async () => {
        const userJson = await AsyncStorage.getItem(CURRENT_USER_KEY);
        return userJson ? JSON.parse(userJson) : null;
    },
    setCurrentUser: async (userData) => {
        if (userData) {
            await AsyncStorage.setItem(CURRENT_USER_KEY, JSON.stringify(userData));
        } else {
            await AsyncStorage.removeItem(CURRENT_USER_KEY);
        }
    },
    isAuthenticated: async () => {
        const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
        return !!token; // True if token exists and is not empty
    },
};
export default identityService;

/* ===== src\services\index.js ===== */
// src/services/index.js
export {default as api} from './api';
export {default as blogService} from './blogService';
export {default as cartService} from './cartService';
export {default as categoryService} from './categoryService';
export {default as customerService} from './customerService';
export {default as fileService} from './fileService';
export {default as identityService} from './identityService';
export {default as notificationService} from './notificationService';
export {default as orderService} from './orderService';
export {default as paymentService} from './paymentService';
export {default as productService} from './productService';
export {default as profileService} from './profileService';


/* ===== src\services\notificationService.js ===== */
/* ===== notificationService.js ===== */
// src/services/notificationService.js
import api from './api';

const notificationService = {
    getMyNotifications: async (pageIndex = 1, pageSize = 10) => {
        try {
            const response = await api.get('/notification/my-notification', {
                params: {pageIndex, pageSize}
            });
            return response;
        } catch (error) {
            console.error('Get my notifications failed:', error.message || error);
            throw error;
        }
    },

    deleteNotification: async (id) => { // Parameter changed from notificationLogId to id
        try {
            const response = await api.delete(`/notification/my-notification/${id}`);
            return response;
        } catch (error) {
            console.error(`Delete notification ${id} failed:`, error.message || error);
            throw error;
        }
    },

    deleteAllNotifications: async () => {
        try {
            const response = await api.delete(`/notification/my-notification`);
            return response;
        } catch (error) {
            console.error(`Delete all notifications failed:`, error.message || error);
            throw error;
        }
    },

    markNotificationAsRead: async (id) => { // Parameter changed from notificationLogId to id
        try {
            const response = await api.patch(`/notification/my-notification/mark-as-read/${id}`);
            return response;
        } catch (error) {
            console.error(`Mark notification ${id} as read failed:`, error.message || error);
            throw error;
        }
    },

    markAllNotificationsAsRead: async () => {
        try {
            const response = await api.patch(`/notification/my-notification/mark-all-as-read`);
            return response;
        } catch (error) {
            console.error(`Mark all notifications as read failed:`, error.message || error);
            throw error;
        }
    }
};

export default notificationService;

/* ===== src\services\orderService.js ===== */
import api from './api';

const orderService = {
    // POST /order
    createOrder: async (orderData) => {
        // orderData: { profileId, paymentMethod, note, orderProducts: [{productId, quantity}] }
        try {
            const response = await api.post('/order/', orderData);
            return response; // ApiResponse<OrderResponse>
        } catch (error) {
            console.error('Create order failed:', error.message || error);
            throw error;
        }
    },

    // GET /order (Admin/Staff only)
    getAllOrdersForAdmin: async (pageIndex = 1, pageSize = 10, createdAt, paymentStatus, paymentMethod) => {
        const params = {
            pageIndex: pageIndex > 0 ? pageIndex : 1, // Example uses 1-based
            pageSize,
        };
        if (createdAt) params.createdAt = createdAt; // Format: dd-MM-yyyy
        if (paymentStatus !== undefined) params.paymentStatus = paymentStatus;
        if (paymentMethod !== undefined) params.paymentMethod = paymentMethod;

        try {
            const response = await api.get('/order', { params });
            return response; // ApiResponse<PageResponse<OrderResponse>>
        } catch (error) {
            console.error('Admin: Get all orders failed:', error.message || error);
            throw error;
        }
    },

    // GET /order/{orderId} (Admin/Staff only)
    getOrderByIdForAdmin: async (orderId) => {
        try {
            const response = await api.get(`/order/${orderId}`);
            return response; // ApiResponse<OrderResponse>
        } catch (error) {
            console.error(`Admin: Get order ${orderId} failed:`, error.message || error);
            throw error;
        }
    },

    // GET /order/my-orders (User)
    getMyOrders: async (pageIndex = 1, pageSize = 10) => {
        try {
            const response = await api.get('/order/my-orders', {
                // Backend OrderService uses 0-based pageIndex for PageRequest.of
                params: { pageIndex: pageIndex > 0 ? pageIndex : 1, pageSize } // Assuming API expects 1-based
            });
            return response; // ApiResponse<PageResponse<OrderResponse>>
        } catch (error) {
            console.error('Get my orders failed:', error.message || error);
            throw error;
        }
    },

    // GET /order/my-orders/{orderId} (User)
    getMyOrderById: async (orderId) => {
        try {
            const response = await api.get(`/order/my-orders/${orderId}`);
            return response; // ApiResponse<OrderResponse>
        } catch (error) {
            console.error(`Get my order ${orderId} failed:`, error.message || error);
            throw error;
        }
    },

    // POST /order/{orderId}/cancer (User) - Note: backend has 'cancer' typo
    cancelOrder: async (orderId, cancelData) => { // cancelData: { note }
        try {
            const response = await api.post(`/order/${orderId}/cancer`, cancelData);
            return response; // ApiResponse<String>
        } catch (error) {
            console.error(`Cancel order ${orderId} failed:`, error.message || error);
            throw error;
        }
    },

    // PATCH /order/{orderId} (Admin/Staff only)
    updateOrderStatusAsAdmin: async (orderId, statusData) => { // statusData: { status }
        try {
            const response = await api.patch(`/order/${orderId}`, statusData);
            return response; // ApiResponse<OrderResponse>
        } catch (error) {
            console.error(`Admin: Update order status for ${orderId} failed:`, error.message || error);
            throw error;
        }
    },
};
export default orderService;

/* ===== src\services\paymentService.js ===== */

/*
####################################################################
# paymentService.js
####################################################################
*/
// src/services/paymentService.js
import api from './api';

const paymentService = {
    // POST /payment/momo/{orderId}
    createMomoPayment: async (orderId) => {
        try {
            const response = await api.post(`/payment/momo/${orderId}`);
            return response; // ApiResponse<MomoResponse>
        } catch (error) {
            console.error(`Create Momo payment for order ${orderId} failed:`, error.message || error);
            throw error;
        }
    },

    // GET /payment/vnpay/{orderId}
    getVNPayPaymentUrl: async (orderId, bankCode = '') => {
        const params = {};
        if (bankCode) {
            params.bankCode = bankCode;
        }
        try {
            // This endpoint returns ApiResponse<Map<String, String>> where map is {"payUrl": "..."}
            const response = await api.get(`/payment/vnpay/${orderId}`, { params });
            return response;
        } catch (error) {
            console.error(`Get VNPay payment URL for order ${orderId} failed:`, error.message || error);
            throw error;
        }
    },
    // Note: /momo_return and /vnpay_return are callback URLs for the backend, not directly called by the mobile app.
};
export default paymentService;

/* ===== src\services\productService.js ===== */
import api from './api';

const productService = {
    // GET /product
    getAllProducts: async (filter = {}, pageIndex = 1, pageSize = 10) => {
        const params = {
            ...filter,
            pageIndex: pageIndex > 0 ? pageIndex : 1, // API example uses 1-based
            pageSize,
        };
        try {
            const response = await api.get('/product/active', { params });
            return response; // ApiResponse<PageResponse<ProductResponse>>
        } catch (error) {
            console.error('Get all products failed:', error.message || error);
            throw error;
        }
    },

    // GET /product/active
    getActiveProducts: async (filter = {}, pageIndex = 1, pageSize = 10) => {
        const params = {
            ...filter,
            pageIndex: pageIndex > 0 ? pageIndex : 1, // API example uses 1-based
            pageSize,
        };
        try {
            const response = await api.get('/product/active', { params });
            return response; // ApiResponse<PageResponse<ProductResponse>>
        } catch (error) {
            console.error('Get active products failed:', error.message || error);
            throw error;
        }
    },

    // GET /product/top-discount
    getTopDiscountProducts: async () => {
        try {
            const response = await api.get('/product/top-discount');
            return response; // ApiResponse<List<ProductResponse>>
        } catch (error) {
            console.error('Get top discount products failed:', error.message || error);
            throw error;
        }
    },

    // GET /product/top-rating
    getTopRatingProducts: async () => {
        try {
            const response = await api.get('/product/top-rating');
            return response; // ApiResponse<List<ProductResponse>>
        } catch (error) {
            console.error('Get top rating products failed:', error.message || error);
            throw error;
        }
    },

    // GET /product/{productId}
    getProductById: async (productId) => {
        try {
            const response = await api.get(`/product/${productId}`);
            return response; // ApiResponse<ProductResponse>
        } catch (error) {
            console.error(`Get product ${productId} failed:`, error.message || error);
            throw error;
        }
    },

    // POST /product (Admin/Staff only)
    createProduct: async (productData, thumbnailFile, imageFiles = []) => {
        // productData: ProductRequest DTO
        const formData = new FormData();
        formData.append('product', JSON.stringify(productData));
        formData.append('thumbnail', {
            uri: thumbnailFile.uri,
            name: thumbnailFile.fileName || `thumb-${Date.now()}`,
            type: thumbnailFile.mimeType || 'image/jpeg',
        });
        imageFiles.forEach((file, index) => {
            formData.append('images', {
                uri: file.uri,
                name: file.fileName || `image-${index}-${Date.now()}`,
                type: file.mimeType || 'image/jpeg',
            });
        });
        try {
            const response = await api.post('/product', formData);
            return response; // ApiResponse<ProductResponse>
        } catch (error) {
            console.error('Create product failed:', error.message || error);
            throw error;
        }
    },

    // PUT /product/{productId} (Admin/Staff only)
    updateProduct: async (productId, productData, thumbnailFile = null, imageFiles = []) => {
        const formData = new FormData();
        formData.append('product', JSON.stringify(productData));
        if (thumbnailFile) {
            formData.append('thumbnail', {
                uri: thumbnailFile.uri,
                name: thumbnailFile.fileName || `thumb-update-${Date.now()}`,
                type: thumbnailFile.mimeType || 'image/jpeg',
            });
        }
        if (imageFiles && imageFiles.length > 0) {
            imageFiles.forEach((file, index) => {
                formData.append('images', {
                    uri: file.uri,
                    name: file.fileName || `image-update-${index}-${Date.now()}`,
                    type: file.mimeType || 'image/jpeg',
                });
            });
        }
        try {
            const response = await api.put(`/product/${productId}`, formData);
            return response; // ApiResponse<ProductResponse>
        } catch (error) {
            console.error(`Update product ${productId} failed:`, error.message || error);
            throw error;
        }
    },

    // DELETE /product/{productId} (Admin/Staff only)
    deleteProduct: async (productId) => {
        try {
            const response = await api.delete(`/product/${productId}`);
            return response; // ApiResponse<ProductResponse> (or Void/message)
        } catch (error) {
            console.error(`Delete product ${productId} failed:`, error.message || error);
            throw error;
        }
    },

    // PUT /product/active/{id} (Admin/Staff only)
    updateProductStatus: async (productId, isActive) => {
        try {
            const response = await api.put(`/product/active/${productId}`, isActive, {
                headers: { 'Content-Type': 'application/json' } // Ensure correct content type for boolean body
            });
            return response; // ApiResponse<ProductResponse>
        } catch (error) {
            console.error(`Update product ${productId} status failed:`, error.message || error);
            throw error;
        }
    },

    // === Product Category Routes (within Product Service) ===
    // GET /product/category
    getProductCategories: async () => {
        try {
            const response = await api.get('/product/category');
            return response; // ApiResponse<List<CategoryResponse>>
        } catch (error) {
            console.error('Get product categories failed:', error.message || error);
            throw error;
        }
    },

    // === Product Rate Routes (within Product Service) ===
    // GET /product/rate
    getAllProductRates: async (pageIndex = 1, pageSize = 10) => {
        try {
            const response = await api.get('/product/rate', {
                params: { pageIndex: pageIndex > 0 ? pageIndex : 1, pageSize } // API example uses 1-based
            });
            return response; // ApiResponse<PageResponse<RateResponse>>
        } catch (error) {
            console.error('Get all product rates failed:', error.message || error);
            throw error;
        }
    },

    // GET /product/rate/{id}
    getRateById: async (rateId) => {
        try {
            const response = await api.get(`/product/rate/${rateId}`);
            return response; // ApiResponse<RateResponse>
        } catch (error) {
            console.error(`Get rate ${rateId} failed:`, error.message || error);
            throw error;
        }
    },

    // GET /product/rate/product/{productId}
    getRatesByProductId: async (productId, pageIndex = 1, pageSize = 10) => {
        try {
            const response = await api.get(`/product/rate/product/${productId}`, {
                params: { pageIndex: pageIndex > 0 ? pageIndex : 1, pageSize } // API example uses 1-based
            });
            return response; // ApiResponse<PageResponse<RateResponse>>
        } catch (error) {
            console.error(`Get rates for product ${productId} failed:`, error.message || error);
            throw error;
        }
    },

    // POST /product/rate
    createRate: async (rateData) => { // { productId, vote, comment }
        try {
            const response = await api.post('/product/rate', rateData);
            return response; // ApiResponse<RateResponse>
        } catch (error) {
            console.error('Create rate failed:', error.message || error);
            throw error;
        }
    },

    // DELETE /product/rate/{id}
    deleteRate: async (rateId) => {
        try {
            const response = await api.delete(`/product/rate/${rateId}`);
            return response; // ApiResponse<RateResponse> (or Void/message)
        } catch (error) {
            console.error(`Delete rate ${rateId} failed:`, error.message || error);
            throw error;
        }
    },
};
export default productService;

/* ===== src\services\profileService.js ===== */


/*
####################################################################
# profileService.js (Replaces userService.js)
####################################################################
*/
// src/services/profileService.js
import api from './api';
import identityService from './identityService'; // To update current user info locally

const profileService = {
    // GET /identity/users/info (lấy thông tin user hiện tại - đã có trong identityService, nhưng profileService có thể wrap nó)
    getMyInfo: async () => {
        try {
            const response = await api.get('/identity/users/info'); // Path from UserController
            if (response && response.result) {
                await identityService.setCurrentUser(response.result);
            }
            return response; // ApiResponse<UserResponse>
        } catch (error) {
            console.error('Get my info (profile context) failed:', error.message || error);
            throw error;
        }
    },

    // PUT /identity/users/info (cập nhật thông tin user hiện tại)
    updateMyInfo: async (userInfo) => { // userInfo: { email } based on UserUpdateInfoRequest
        try {
            const response = await api.put('/identity/users/info', userInfo); // Path from UserController
            if (response && response.result) {
                await identityService.setCurrentUser(response.result);
            }
            return response; // ApiResponse<UserResponse>
        } catch (error) {
            console.error('Update my info (profile context) failed:', error.message || error);
            throw error;
        }
    },

    // GET /identity/users/{userId} (Lấy thông tin user theo ID)
    getUserProfileById: async (userId) => {
        try {
            const response = await api.get(`/identity/users/${userId}`); // Path from UserController
            return response; // ApiResponse<UserResponse>
        } catch (error) {
            console.error(`Get user profile for ${userId} failed:`, error.message || error);
            throw error;
        }
    },

    // === Profile/Address specific endpoints from ProfileController ===
    // POST /profile
    createShippingProfile: async (profileData) => {
        // profileData: { fullName, phone, address, gender ("MALE" | "FEMALE") }
        try {
            const response = await api.post('/profile/', profileData);
            return response; // ApiResponse<ProfileResponse>
        } catch (error) {
            console.error('Create shipping profile failed:', error.message || error);
            throw error;
        }
    },

    // GET /profile/my-profile
    getMyShippingProfiles: async (pageIndex = 1, pageSize = 10) => {
        try {
            // Backend ProfileService uses 1-based pageIndex
            const response = await api.get('/profile/my-profile', { params: { pageIndex, pageSize } });
            return response; // ApiResponse<PageResponse<ProfileResponse>>
        } catch (error) {
            console.error('Get my shipping profiles failed:', error.message || error);
            throw error;
        }
    },

    // PUT /profile/{profileId}
    updateShippingProfile: async (profileId, profileData) => {
        // profileData: { fullName, phone, address, gender }
        try {
            const response = await api.put(`/profile/${profileId}`, profileData);
            return response; // ApiResponse<ProfileResponse>
        } catch (error) {
            console.error(`Update shipping profile ${profileId} failed:`, error.message || error);
            throw error;
        }
    },

    // GET /profile/{profileId}
    getShippingProfileById: async (profileId) => {
        try {
            const response = await api.get(`/profile/${profileId}`);
            return response; // ApiResponse<ProfileResponse>
        } catch (error) {
            console.error(`Get shipping profile ${profileId} failed:`, error.message || error);
            throw error;
        }
    },

    // DELETE /profile/{profileId}
    deleteShippingProfile: async (profileId) => {
        try {
            const response = await api.delete(`/profile/${profileId}`);
            return response; // ApiResponse<String>
        } catch (error) {
            console.error(`Delete shipping profile ${profileId} failed:`, error.message || error);
            throw error;
        }
    },
};
export default profileService;

/* ===== src\utils\imageUtils.js ===== */
// src/utils/imageUtils.js (hoặc nơi bạn muốn đặt)
export function dataURIToBlob(dataURI) {
    if (!dataURI || !dataURI.startsWith('data:')) {
        console.error("Invalid dataURI provided to dataURIToBlob");
        return null;
    }
    try {
        // Tách phần base64 và mime type
        const [header, base64Data] = dataURI.split(',');
        if (!header || !base64Data) {
            console.error("Malformed dataURI: could not split header and base64 data.");
            return null;
        }

        const mimeMatch = header.match(/:(.*?);/);
        if (!mimeMatch || mimeMatch.length < 2) {
            console.error("Malformed dataURI: could not extract mime type.");
            return null;
        }
        const mimeString = mimeMatch[1];

        // Chuyển đổi base64 thành dữ liệu nhị phân
        const byteCharacters = atob(base64Data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeString });
    } catch (e) {
        console.error("Error converting data URI to Blob:", e);
        return null;
    }
}


/* ===== BINARY FILES (PATHS ONLY) ===== */
/* Binary file: src\assets\fonts\SpaceMono-Regular.ttf */
/* Binary file: src\assets\images\adaptive-icon.png */
/* Binary file: src\assets\images\icon.png */
/* Binary file: src\assets\images\splash-icon.png */

/* ===== IGNORED FILES & DIRECTORIES ===== */
/* The following items were excluded based on ignore rules */

/* .gitignore patterns: */
/*   node_modules/ */
/*   .expo/ */
/*   dist/ */
/*   web-build/ */
/*   expo-env.d.ts */
/*   .idea/ */
/*   .vscode/ */
/*   .kotlin/ */
/*   *.orig.* */
/*   *.jks */
/*   *.p8 */
/*   *.p12 */
/*   *.key */
/*   *.mobileprovision */
/*   .metro-health-check* */
/*   npm-debug.* */
/*   yarn-debug.* */
/*   yarn-error.* */
/*   .DS_Store */
/*   *.pem */
/*   .env*.local */
/*   *.tsbuildinfo */
/*   app-example */

/* .watchignore patterns: */
/*   node_modules/ */
/*   .git/ */
/*   .env */
/*   .gitignore */
/*   app.d.ts */
/*   babel.config.js */
/*   eslint.config.js */
/*   expo-env.d.ts */
/*   global.d.ts */
/*   metro.config.js */
/*   nativewind-env.d.ts */
/*   package-lock.json */
/*   postcss.config.js */
/*   README.md */
/*   tailwind.config.js */
/*   tsconfig.json */

/* Ignored items list: */
/* Ignored directories: */
/*   .codebase/ */
/*   .expo\types/ */
/*   .expo\web/ */
/*   .git\hooks/ */
/*   .git\info/ */
/*   .git\logs/ */
/*   .git\objects/ */
/*   .git\refs/ */
/*   .idea\caches/ */
/*   .idea\inspectionProfiles/ */
/*   node_modules\.bin/ */
/*   node_modules\@0no-co/ */
/*   node_modules\@alloc/ */
/*   node_modules\@ampproject/ */
/*   node_modules\@babel/ */
/*   node_modules\@egjs/ */
/*   node_modules\@emnapi/ */
/*   node_modules\@eslint/ */
/*   node_modules\@eslint-community/ */
/*   node_modules\@expo/ */
/*   node_modules\@faker-js/ */
/*   node_modules\@firebase/ */
/*   node_modules\@grpc/ */
/*   node_modules\@humanfs/ */
/*   node_modules\@humanwhocodes/ */
/*   node_modules\@ide/ */
/*   node_modules\@isaacs/ */
/*   node_modules\@istanbuljs/ */
/*   node_modules\@jest/ */
/*   node_modules\@jridgewell/ */
/*   node_modules\@modelcontextprotocol/ */
/*   node_modules\@napi-rs/ */
/*   node_modules\@nodelib/ */
/*   node_modules\@nolyfill/ */
/*   node_modules\@pkgjs/ */
/*   node_modules\@protobufjs/ */
/*   node_modules\@radix-ui/ */
/*   node_modules\@react-native/ */
/*   node_modules\@react-native-async-storage/ */
/*   node_modules\@react-native-firebase/ */
/*   node_modules\@react-navigation/ */
/*   node_modules\@rneui/ */
/*   node_modules\@rtsao/ */
/*   node_modules\@sinclair/ */
/*   node_modules\@sinonjs/ */
/*   node_modules\@tybys/ */
/*   node_modules\@types/ */
/*   node_modules\@typescript-eslint/ */
/*   node_modules\@unrs/ */
/*   node_modules\@urql/ */
/*   node_modules\@xmldom/ */
/*   node_modules\abort-controller/ */
/*   node_modules\accepts/ */
/*   node_modules\acorn/ */
/*   node_modules\acorn-jsx/ */
/*   node_modules\agent-base/ */
/*   node_modules\ajv/ */
/*   node_modules\ajv-formats/ */
/*   node_modules\anser/ */
/*   node_modules\ansi-escapes/ */
/*   node_modules\ansi-regex/ */
/*   node_modules\ansi-styles/ */
/*   node_modules\any-promise/ */
/*   node_modules\anymatch/ */
/*   node_modules\arg/ */
/*   node_modules\argparse/ */
/*   node_modules\array-buffer-byte-length/ */
/*   node_modules\array-includes/ */
/*   node_modules\array-timsort/ */
/*   node_modules\array.prototype.findlast/ */
/*   node_modules\array.prototype.findlastindex/ */
/*   node_modules\array.prototype.flat/ */
/*   node_modules\array.prototype.flatmap/ */
/*   node_modules\array.prototype.tosorted/ */
/*   node_modules\arraybuffer.prototype.slice/ */
/*   node_modules\asap/ */
/*   node_modules\assert/ */
/*   node_modules\async-function/ */
/*   node_modules\async-limiter/ */
/*   node_modules\asynckit/ */
/*   node_modules\autoprefixer/ */
/*   node_modules\available-typed-arrays/ */
/*   node_modules\axios/ */
/*   node_modules\babel-jest/ */
/*   node_modules\babel-plugin-istanbul/ */
/*   node_modules\babel-plugin-jest-hoist/ */
/*   node_modules\babel-plugin-polyfill-corejs2/ */
/*   node_modules\babel-plugin-polyfill-corejs3/ */
/*   node_modules\babel-plugin-polyfill-regenerator/ */
/*   node_modules\babel-plugin-react-native-web/ */
/*   node_modules\babel-plugin-syntax-hermes-parser/ */
/*   node_modules\babel-plugin-transform-flow-enums/ */
/*   node_modules\babel-preset-current-node-syntax/ */
/*   node_modules\babel-preset-expo/ */
/*   node_modules\babel-preset-jest/ */
/*   node_modules\badgin/ */
/*   node_modules\balanced-match/ */
/*   node_modules\base64-js/ */
/*   node_modules\better-opn/ */
/*   node_modules\big-integer/ */
/*   node_modules\binary-extensions/ */
/*   node_modules\body-parser/ */
/*   node_modules\bplist-creator/ */
/*   node_modules\bplist-parser/ */
/*   node_modules\brace-expansion/ */
/*   node_modules\braces/ */
/*   node_modules\browserslist/ */
/*   node_modules\bser/ */
/*   node_modules\buffer/ */
/*   node_modules\buffer-from/ */
/*   node_modules\bytes/ */
/*   node_modules\call-bind/ */
/*   node_modules\call-bind-apply-helpers/ */
/*   node_modules\call-bound/ */
/*   node_modules\caller-callsite/ */
/*   node_modules\caller-path/ */
/*   node_modules\callsites/ */
/*   node_modules\camelcase/ */
/*   node_modules\camelcase-css/ */
/*   node_modules\caniuse-lite/ */
/*   node_modules\chalk/ */
/*   node_modules\chokidar/ */
/*   node_modules\chownr/ */
/*   node_modules\chrome-launcher/ */
/*   node_modules\chromium-edge-launcher/ */
/*   node_modules\ci-info/ */
/*   node_modules\cli-cursor/ */
/*   node_modules\cli-spinners/ */
/*   node_modules\client-only/ */
/*   node_modules\cliui/ */
/*   node_modules\clone/ */
/*   node_modules\clone-deep/ */
/*   node_modules\color/ */
/*   node_modules\color-convert/ */
/*   node_modules\color-name/ */
/*   node_modules\color-string/ */
/*   node_modules\combined-stream/ */
/*   node_modules\commander/ */
/*   node_modules\comment-json/ */
/*   node_modules\compressible/ */
/*   node_modules\compression/ */
/*   node_modules\concat-map/ */
/*   node_modules\connect/ */
/*   node_modules\content-disposition/ */
/*   node_modules\content-type/ */
/*   node_modules\convert-source-map/ */
/*   node_modules\cookie/ */
/*   node_modules\cookie-signature/ */
/*   node_modules\core-js-compat/ */
/*   node_modules\core-util-is/ */
/*   node_modules\cors/ */
/*   node_modules\cosmiconfig/ */
/*   node_modules\cross-fetch/ */
/*   node_modules\cross-spawn/ */
/*   node_modules\crypto-random-string/ */
/*   node_modules\css-in-js-utils/ */
/*   node_modules\cssesc/ */
/*   node_modules\csstype/ */
/*   node_modules\data-view-buffer/ */
/*   node_modules\data-view-byte-length/ */
/*   node_modules\data-view-byte-offset/ */
/*   node_modules\debug/ */
/*   node_modules\decode-uri-component/ */
/*   node_modules\deep-extend/ */
/*   node_modules\deep-is/ */
/*   node_modules\deepmerge/ */
/*   node_modules\defaults/ */
/*   node_modules\define-data-property/ */
/*   node_modules\define-lazy-prop/ */
/*   node_modules\define-properties/ */
/*   node_modules\delayed-stream/ */
/*   node_modules\depd/ */
/*   node_modules\destroy/ */
/*   node_modules\detect-libc/ */
/*   node_modules\didyoumean/ */
/*   node_modules\dlv/ */
/*   node_modules\doctrine/ */
/*   node_modules\dotenv/ */
/*   node_modules\dotenv-expand/ */
/*   node_modules\dunder-proto/ */
/*   node_modules\eastasianwidth/ */
/*   node_modules\ee-first/ */
/*   node_modules\electron-to-chromium/ */
/*   node_modules\emoji-regex/ */
/*   node_modules\encodeurl/ */
/*   node_modules\env-editor/ */
/*   node_modules\error-ex/ */
/*   node_modules\error-stack-parser/ */
/*   node_modules\es-abstract/ */
/*   node_modules\es-define-property/ */
/*   node_modules\es-errors/ */
/*   node_modules\es-iterator-helpers/ */
/*   node_modules\es-object-atoms/ */
/*   node_modules\es-set-tostringtag/ */
/*   node_modules\es-shim-unscopables/ */
/*   node_modules\es-to-primitive/ */
/*   node_modules\escalade/ */
/*   node_modules\escape-html/ */
/*   node_modules\escape-string-regexp/ */
/*   node_modules\eslint/ */
/*   node_modules\eslint-config-expo/ */
/*   node_modules\eslint-import-resolver-node/ */
/*   node_modules\eslint-import-resolver-typescript/ */
/*   node_modules\eslint-module-utils/ */
/*   node_modules\eslint-plugin-expo/ */
/*   node_modules\eslint-plugin-import/ */
/*   node_modules\eslint-plugin-react/ */
/*   node_modules\eslint-plugin-react-hooks/ */
/*   node_modules\eslint-scope/ */
/*   node_modules\eslint-visitor-keys/ */
/*   node_modules\espree/ */
/*   node_modules\esprima/ */
/*   node_modules\esquery/ */
/*   node_modules\esrecurse/ */
/*   node_modules\estraverse/ */
/*   node_modules\esutils/ */
/*   node_modules\etag/ */
/*   node_modules\event-target-shim/ */
/*   node_modules\eventsource/ */
/*   node_modules\eventsource-parser/ */
/*   node_modules\exec-async/ */
/*   node_modules\expo/ */
/*   node_modules\expo-application/ */
/*   node_modules\expo-asset/ */
/*   node_modules\expo-blur/ */
/*   node_modules\expo-constants/ */
/*   node_modules\expo-device/ */
/*   node_modules\expo-file-system/ */
/*   node_modules\expo-font/ */
/*   node_modules\expo-haptics/ */
/*   node_modules\expo-image/ */
/*   node_modules\expo-image-loader/ */
/*   node_modules\expo-image-picker/ */
/*   node_modules\expo-keep-awake/ */
/*   node_modules\expo-linking/ */
/*   node_modules\expo-modules-autolinking/ */
/*   node_modules\expo-modules-core/ */
/*   node_modules\expo-notifications/ */
/*   node_modules\expo-router/ */
/*   node_modules\expo-splash-screen/ */
/*   node_modules\expo-status-bar/ */
/*   node_modules\expo-symbols/ */
/*   node_modules\expo-system-ui/ */
/*   node_modules\expo-web-browser/ */
/*   node_modules\exponential-backoff/ */
/*   node_modules\express/ */
/*   node_modules\express-rate-limit/ */
/*   node_modules\fast-deep-equal/ */
/*   node_modules\fast-glob/ */
/*   node_modules\fast-json-stable-stringify/ */
/*   node_modules\fast-levenshtein/ */
/*   node_modules\fast-uri/ */
/*   node_modules\fastq/ */
/*   node_modules\fb-watchman/ */
/*   node_modules\fbjs/ */
/*   node_modules\fbjs-css-vars/ */
/*   node_modules\fdir/ */
/*   node_modules\file-entry-cache/ */
/*   node_modules\fill-range/ */
/*   node_modules\filter-obj/ */
/*   node_modules\finalhandler/ */
/*   node_modules\find-up/ */
/*   node_modules\flat-cache/ */
/*   node_modules\flatted/ */
/*   node_modules\flow-enums-runtime/ */
/*   node_modules\follow-redirects/ */
/*   node_modules\fontfaceobserver/ */
/*   node_modules\for-each/ */
/*   node_modules\for-in/ */
/*   node_modules\for-own/ */
/*   node_modules\foreground-child/ */
/*   node_modules\form-data/ */
/*   node_modules\forwarded/ */
/*   node_modules\fraction.js/ */
/*   node_modules\freeport-async/ */
/*   node_modules\fresh/ */
/*   node_modules\fs.realpath/ */
/*   node_modules\function-bind/ */
/*   node_modules\function.prototype.name/ */
/*   node_modules\functions-have-names/ */
/*   node_modules\gensync/ */
/*   node_modules\get-caller-file/ */
/*   node_modules\get-intrinsic/ */
/*   node_modules\get-package-type/ */
/*   node_modules\get-proto/ */
/*   node_modules\get-symbol-description/ */
/*   node_modules\get-tsconfig/ */
/*   node_modules\getenv/ */
/*   node_modules\glob/ */
/*   node_modules\glob-parent/ */
/*   node_modules\globals/ */
/*   node_modules\globalthis/ */
/*   node_modules\gopd/ */
/*   node_modules\graceful-fs/ */
/*   node_modules\graphemer/ */
/*   node_modules\has-bigints/ */
/*   node_modules\has-flag/ */
/*   node_modules\has-own-prop/ */
/*   node_modules\has-property-descriptors/ */
/*   node_modules\has-proto/ */
/*   node_modules\has-symbols/ */
/*   node_modules\has-tostringtag/ */
/*   node_modules\hasown/ */
/*   node_modules\hermes-estree/ */
/*   node_modules\hermes-parser/ */
/*   node_modules\hoist-non-react-statics/ */
/*   node_modules\hosted-git-info/ */
/*   node_modules\http-errors/ */
/*   node_modules\https-proxy-agent/ */
/*   node_modules\hyphenate-style-name/ */
/*   node_modules\iconv-lite/ */
/*   node_modules\ieee754/ */
/*   node_modules\ignore/ */
/*   node_modules\image-size/ */
/*   node_modules\import-fresh/ */
/*   node_modules\imurmurhash/ */
/*   node_modules\inflight/ */
/*   node_modules\inherits/ */
/*   node_modules\ini/ */
/*   node_modules\inline-style-prefixer/ */
/*   node_modules\internal-slot/ */
/*   node_modules\invariant/ */
/*   node_modules\ipaddr.js/ */
/*   node_modules\is-arguments/ */
/*   node_modules\is-array-buffer/ */
/*   node_modules\is-arrayish/ */
/*   node_modules\is-async-function/ */
/*   node_modules\is-bigint/ */
/*   node_modules\is-binary-path/ */
/*   node_modules\is-boolean-object/ */
/*   node_modules\is-bun-module/ */
/*   node_modules\is-callable/ */
/*   node_modules\is-core-module/ */
/*   node_modules\is-data-view/ */
/*   node_modules\is-date-object/ */
/*   node_modules\is-directory/ */
/*   node_modules\is-docker/ */
/*   node_modules\is-extendable/ */
/*   node_modules\is-extglob/ */
/*   node_modules\is-finalizationregistry/ */
/*   node_modules\is-fullwidth-code-point/ */
/*   node_modules\is-generator-function/ */
/*   node_modules\is-glob/ */
/*   node_modules\is-map/ */
/*   node_modules\is-nan/ */
/*   node_modules\is-number/ */
/*   node_modules\is-number-object/ */
/*   node_modules\is-plain-obj/ */
/*   node_modules\is-plain-object/ */
/*   node_modules\is-promise/ */
/*   node_modules\is-regex/ */
/*   node_modules\is-set/ */
/*   node_modules\is-shared-array-buffer/ */
/*   node_modules\is-string/ */
/*   node_modules\is-symbol/ */
/*   node_modules\is-typed-array/ */
/*   node_modules\is-weakmap/ */
/*   node_modules\is-weakref/ */
/*   node_modules\is-weakset/ */
/*   node_modules\is-wsl/ */
/*   node_modules\isarray/ */
/*   node_modules\isexe/ */
/*   node_modules\isobject/ */
/*   node_modules\istanbul-lib-coverage/ */
/*   node_modules\istanbul-lib-instrument/ */
/*   node_modules\iterator.prototype/ */
/*   node_modules\jackspeak/ */
/*   node_modules\jest-environment-node/ */
/*   node_modules\jest-get-type/ */
/*   node_modules\jest-haste-map/ */
/*   node_modules\jest-message-util/ */
/*   node_modules\jest-mock/ */
/*   node_modules\jest-regex-util/ */
/*   node_modules\jest-util/ */
/*   node_modules\jest-validate/ */
/*   node_modules\jest-worker/ */
/*   node_modules\jimp-compact/ */
/*   node_modules\jiti/ */
/*   node_modules\js-tokens/ */
/*   node_modules\js-yaml/ */
/*   node_modules\jsc-safe-url/ */
/*   node_modules\jsesc/ */
/*   node_modules\json-buffer/ */
/*   node_modules\json-parse-better-errors/ */
/*   node_modules\json-schema-traverse/ */
/*   node_modules\json-stable-stringify-without-jsonify/ */
/*   node_modules\json5/ */
/*   node_modules\jsx-ast-utils/ */
/*   node_modules\keyv/ */
/*   node_modules\kind-of/ */
/*   node_modules\kleur/ */
/*   node_modules\lan-network/ */
/*   node_modules\leven/ */
/*   node_modules\levn/ */
/*   node_modules\lighthouse-logger/ */
/*   node_modules\lightningcss/ */
/*   node_modules\lightningcss-win32-x64-msvc/ */
/*   node_modules\lilconfig/ */
/*   node_modules\lines-and-columns/ */
/*   node_modules\locate-path/ */
/*   node_modules\lodash/ */
/*   node_modules\lodash.debounce/ */
/*   node_modules\lodash.merge/ */
/*   node_modules\lodash.throttle/ */
/*   node_modules\log-symbols/ */
/*   node_modules\loose-envify/ */
/*   node_modules\lru-cache/ */
/*   node_modules\makeerror/ */
/*   node_modules\marky/ */
/*   node_modules\math-intrinsics/ */
/*   node_modules\media-typer/ */
/*   node_modules\memoize-one/ */
/*   node_modules\merge-descriptors/ */
/*   node_modules\merge-options/ */
/*   node_modules\merge-stream/ */
/*   node_modules\merge2/ */
/*   node_modules\metro/ */
/*   node_modules\metro-babel-transformer/ */
/*   node_modules\metro-cache/ */
/*   node_modules\metro-cache-key/ */
/*   node_modules\metro-config/ */
/*   node_modules\metro-core/ */
/*   node_modules\metro-file-map/ */
/*   node_modules\metro-minify-terser/ */
/*   node_modules\metro-resolver/ */
/*   node_modules\metro-runtime/ */
/*   node_modules\metro-source-map/ */
/*   node_modules\metro-symbolicate/ */
/*   node_modules\metro-transform-plugins/ */
/*   node_modules\metro-transform-worker/ */
/*   node_modules\micromatch/ */
/*   node_modules\mime/ */
/*   node_modules\mime-db/ */
/*   node_modules\mime-types/ */
/*   node_modules\mimic-fn/ */
/*   node_modules\minimatch/ */
/*   node_modules\minimist/ */
/*   node_modules\minipass/ */
/*   node_modules\minizlib/ */
/*   node_modules\mixin-object/ */
/*   node_modules\mkdirp/ */
/*   node_modules\ms/ */
/*   node_modules\mz/ */
/*   node_modules\nanoid/ */
/*   node_modules\napi-postinstall/ */
/*   node_modules\nativewind/ */
/*   node_modules\natural-compare/ */
/*   node_modules\negotiator/ */
/*   node_modules\nested-error-stacks/ */
/*   node_modules\node-fetch/ */
/*   node_modules\node-forge/ */
/*   node_modules\node-int64/ */
/*   node_modules\node-releases/ */
/*   node_modules\normalize-path/ */
/*   node_modules\normalize-range/ */
/*   node_modules\npm-package-arg/ */
/*   node_modules\nullthrows/ */
/*   node_modules\ob1/ */
/*   node_modules\object-assign/ */
/*   node_modules\object-hash/ */
/*   node_modules\object-inspect/ */
/*   node_modules\object-is/ */
/*   node_modules\object-keys/ */
/*   node_modules\object.assign/ */
/*   node_modules\object.entries/ */
/*   node_modules\object.fromentries/ */
/*   node_modules\object.groupby/ */
/*   node_modules\object.values/ */
/*   node_modules\on-finished/ */
/*   node_modules\on-headers/ */
/*   node_modules\once/ */
/*   node_modules\onetime/ */
/*   node_modules\open/ */
/*   node_modules\opencollective-postinstall/ */
/*   node_modules\optionator/ */
/*   node_modules\ora/ */
/*   node_modules\own-keys/ */
/*   node_modules\p-limit/ */
/*   node_modules\p-locate/ */
/*   node_modules\p-try/ */
/*   node_modules\package-json-from-dist/ */
/*   node_modules\parent-module/ */
/*   node_modules\parse-json/ */
/*   node_modules\parse-png/ */
/*   node_modules\parseurl/ */
/*   node_modules\path-exists/ */
/*   node_modules\path-is-absolute/ */
/*   node_modules\path-key/ */
/*   node_modules\path-parse/ */
/*   node_modules\path-scurry/ */
/*   node_modules\path-to-regexp/ */
/*   node_modules\picocolors/ */
/*   node_modules\picomatch/ */
/*   node_modules\pify/ */
/*   node_modules\pirates/ */
/*   node_modules\pkce-challenge/ */
/*   node_modules\plist/ */
/*   node_modules\pngjs/ */
/*   node_modules\possible-typed-array-names/ */
/*   node_modules\postcss/ */
/*   node_modules\postcss-import/ */
/*   node_modules\postcss-js/ */
/*   node_modules\postcss-load-config/ */
/*   node_modules\postcss-nested/ */
/*   node_modules\postcss-selector-parser/ */
/*   node_modules\postcss-value-parser/ */
/*   node_modules\prelude-ls/ */
/*   node_modules\pretty-bytes/ */
/*   node_modules\pretty-format/ */
/*   node_modules\proc-log/ */
/*   node_modules\progress/ */
/*   node_modules\promise/ */
/*   node_modules\prompts/ */
/*   node_modules\prop-types/ */
/*   node_modules\proxy-addr/ */
/*   node_modules\proxy-from-env/ */
/*   node_modules\punycode/ */
/*   node_modules\qrcode-terminal/ */
/*   node_modules\qs/ */
/*   node_modules\query-string/ */
/*   node_modules\queue/ */
/*   node_modules\queue-microtask/ */
/*   node_modules\range-parser/ */
/*   node_modules\raw-body/ */
/*   node_modules\rc/ */
/*   node_modules\react/ */
/*   node_modules\react-devtools-core/ */
/*   node_modules\react-dom/ */
/*   node_modules\react-fast-compare/ */
/*   node_modules\react-freeze/ */
/*   node_modules\react-is/ */
/*   node_modules\react-native/ */
/*   node_modules\react-native-css-interop/ */
/*   node_modules\react-native-edge-to-edge/ */
/*   node_modules\react-native-gesture-handler/ */
/*   node_modules\react-native-is-edge-to-edge/ */
/*   node_modules\react-native-ratings/ */
/*   node_modules\react-native-reanimated/ */
/*   node_modules\react-native-safe-area-context/ */
/*   node_modules\react-native-screens/ */
/*   node_modules\react-native-size-matters/ */
/*   node_modules\react-native-web/ */
/*   node_modules\react-native-webview/ */
/*   node_modules\react-refresh/ */
/*   node_modules\read-cache/ */
/*   node_modules\readdirp/ */
/*   node_modules\reflect.getprototypeof/ */
/*   node_modules\regenerate/ */
/*   node_modules\regenerate-unicode-properties/ */
/*   node_modules\regenerator-runtime/ */
/*   node_modules\regexp.prototype.flags/ */
/*   node_modules\regexpu-core/ */
/*   node_modules\regjsgen/ */
/*   node_modules\regjsparser/ */
/*   node_modules\repeat-string/ */
/*   node_modules\require-directory/ */
/*   node_modules\require-from-string/ */
/*   node_modules\requireg/ */
/*   node_modules\resolve/ */
/*   node_modules\resolve-from/ */
/*   node_modules\resolve-pkg-maps/ */
/*   node_modules\resolve-workspace-root/ */
/*   node_modules\resolve.exports/ */
/*   node_modules\restore-cursor/ */
/*   node_modules\reusify/ */
/*   node_modules\rimraf/ */
/*   node_modules\router/ */
/*   node_modules\run-parallel/ */
/*   node_modules\safe-array-concat/ */
/*   node_modules\safe-buffer/ */
/*   node_modules\safe-push-apply/ */
/*   node_modules\safe-regex-test/ */
/*   node_modules\safer-buffer/ */
/*   node_modules\sax/ */
/*   node_modules\scheduler/ */
/*   node_modules\schema-utils/ */
/*   node_modules\semver/ */
/*   node_modules\send/ */
/*   node_modules\serialize-error/ */
/*   node_modules\serve-static/ */
/*   node_modules\server-only/ */
/*   node_modules\set-function-length/ */
/*   node_modules\set-function-name/ */
/*   node_modules\set-proto/ */
/*   node_modules\setimmediate/ */
/*   node_modules\setprototypeof/ */
/*   node_modules\sf-symbols-typescript/ */
/*   node_modules\shallow-clone/ */
/*   node_modules\shallowequal/ */
/*   node_modules\shebang-command/ */
/*   node_modules\shebang-regex/ */
/*   node_modules\shell-quote/ */
/*   node_modules\side-channel/ */
/*   node_modules\side-channel-list/ */
/*   node_modules\side-channel-map/ */
/*   node_modules\side-channel-weakmap/ */
/*   node_modules\signal-exit/ */
/*   node_modules\simple-plist/ */
/*   node_modules\simple-swizzle/ */
/*   node_modules\sisteransi/ */
/*   node_modules\slash/ */
/*   node_modules\slugify/ */
/*   node_modules\source-map/ */
/*   node_modules\source-map-js/ */
/*   node_modules\source-map-support/ */
/*   node_modules\split-on-first/ */
/*   node_modules\sprintf-js/ */
/*   node_modules\stable-hash/ */
/*   node_modules\stack-utils/ */
/*   node_modules\stackframe/ */
/*   node_modules\stacktrace-parser/ */
/*   node_modules\statuses/ */
/*   node_modules\stream-buffers/ */
/*   node_modules\strict-uri-encode/ */
/*   node_modules\string-width/ */
/*   node_modules\string-width-cjs/ */
/*   node_modules\string.prototype.matchall/ */
/*   node_modules\string.prototype.repeat/ */
/*   node_modules\string.prototype.trim/ */
/*   node_modules\string.prototype.trimend/ */
/*   node_modules\string.prototype.trimstart/ */
/*   node_modules\strip-ansi/ */
/*   node_modules\strip-ansi-cjs/ */
/*   node_modules\strip-bom/ */
/*   node_modules\strip-json-comments/ */
/*   node_modules\structured-headers/ */
/*   node_modules\styleq/ */
/*   node_modules\sucrase/ */
/*   node_modules\superstruct/ */
/*   node_modules\supports-color/ */
/*   node_modules\supports-hyperlinks/ */
/*   node_modules\supports-preserve-symlinks-flag/ */
/*   node_modules\tailwindcss/ */
/*   node_modules\tar/ */
/*   node_modules\temp-dir/ */
/*   node_modules\terminal-link/ */
/*   node_modules\terser/ */
/*   node_modules\test-exclude/ */
/*   node_modules\thenify/ */
/*   node_modules\thenify-all/ */
/*   node_modules\throat/ */
/*   node_modules\tinyglobby/ */
/*   node_modules\tmpl/ */
/*   node_modules\to-regex-range/ */
/*   node_modules\toidentifier/ */
/*   node_modules\tr46/ */
/*   node_modules\ts-api-utils/ */
/*   node_modules\ts-interface-checker/ */
/*   node_modules\tsconfig-paths/ */
/*   node_modules\type-check/ */
/*   node_modules\type-detect/ */
/*   node_modules\type-fest/ */
/*   node_modules\type-is/ */
/*   node_modules\typed-array-buffer/ */
/*   node_modules\typed-array-byte-length/ */
/*   node_modules\typed-array-byte-offset/ */
/*   node_modules\typed-array-length/ */
/*   node_modules\typescript/ */
/*   node_modules\ua-parser-js/ */
/*   node_modules\unbox-primitive/ */
/*   node_modules\undici/ */
/*   node_modules\undici-types/ */
/*   node_modules\unicode-canonical-property-names-ecmascript/ */
/*   node_modules\unicode-match-property-ecmascript/ */
/*   node_modules\unicode-match-property-value-ecmascript/ */
/*   node_modules\unicode-property-aliases-ecmascript/ */
/*   node_modules\unique-string/ */
/*   node_modules\unpipe/ */
/*   node_modules\unrs-resolver/ */
/*   node_modules\update-browserslist-db/ */
/*   node_modules\uri-js/ */
/*   node_modules\use-latest-callback/ */
/*   node_modules\use-sync-external-store/ */
/*   node_modules\util/ */
/*   node_modules\util-deprecate/ */
/*   node_modules\utils-merge/ */
/*   node_modules\uuid/ */
/*   node_modules\validate-npm-package-name/ */
/*   node_modules\vary/ */
/*   node_modules\vlq/ */
/*   node_modules\walker/ */
/*   node_modules\warn-once/ */
/*   node_modules\wcwidth/ */
/*   node_modules\webidl-conversions/ */
/*   node_modules\whatwg-fetch/ */
/*   node_modules\whatwg-url/ */
/*   node_modules\whatwg-url-without-unicode/ */
/*   node_modules\which/ */
/*   node_modules\which-boxed-primitive/ */
/*   node_modules\which-builtin-type/ */
/*   node_modules\which-collection/ */
/*   node_modules\which-typed-array/ */
/*   node_modules\wonka/ */
/*   node_modules\word-wrap/ */
/*   node_modules\wrap-ansi/ */
/*   node_modules\wrap-ansi-cjs/ */
/*   node_modules\wrappy/ */
/*   node_modules\write-file-atomic/ */
/*   node_modules\ws/ */
/*   node_modules\xcode/ */
/*   node_modules\xml2js/ */
/*   node_modules\xmlbuilder/ */
/*   node_modules\y18n/ */
/*   node_modules\yallist/ */
/*   node_modules\yaml/ */
/*   node_modules\yargs/ */
/*   node_modules\yargs-parser/ */
/*   node_modules\yocto-queue/ */
/*   node_modules\zod/ */
/*   node_modules\zod-to-json-schema/ */

/* Ignored files: */
/*   .env */
/*   .expo\README.md */
/*   .expo\devices.json */
/*   .git\COMMIT_EDITMSG */
/*   .git\HEAD */
/*   .git\config */
/*   .git\description */
/*   .git\index */
/*   .gitignore */
/*   .idea\.gitignore */
/*   .idea\book_store_mobile.iml */
/*   .idea\modules.xml */
/*   .idea\vcs.xml */
/*   .idea\workspace.xml */
/*   .vscode\settings.json */
/*   README.md */
/*   app.d.ts */
/*   babel.config.js */
/*   eslint.config.js */
/*   expo-env.d.ts */
/*   global.d.ts */
/*   metro.config.js */
/*   nativewind-env.d.ts */
/*   node_modules\.package-lock.json */
/*   package-lock.json */
/*   postcss.config.js */
/*   tailwind.config.js */
/*   tsconfig.json */
