/* ===== src/main/java/com/hau/event/dto/NotificationEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationEvent {
    private String channel;
    private String recipient;
    private String templateCode;
    private Map<String, Object> params;
}


/* ===== src/main/java/com/hau/notificationservice/config/CustomJwtDecoder.java ===== */
package com.hau.notificationservice.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== src/main/java/com/hau/notificationservice/config/JwtAuthenticationEntryPoint.java ===== */
package com.hau.notificationservice.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.notificationservice.dto.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== src/main/java/com/hau/notificationservice/config/SecurityConfig.java ===== */
package com.hau.notificationservice.config;


import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== src/main/java/com/hau/notificationservice/controller/EmailController.java ===== */
package com.hau.notificationservice.controller;

import com.hau.notificationservice.dto.ApiResponse;
import com.hau.notificationservice.dto.EmailResponse;
import com.hau.notificationservice.dto.SendEmailRequest;
import com.hau.notificationservice.service.EmailService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;

@RestController
@RequiredArgsConstructor
@Slf4j
public class EmailController {
    private final EmailService emailService;

    @PostMapping("/email")
    ApiResponse<EmailResponse> sendEmail(@RequestBody SendEmailRequest sendEmailRequest) {
        return ApiResponse.<EmailResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Gửi email thành công")
                .result(emailService.sendEmail(sendEmailRequest))
                .timestamp(LocalDateTime.now())
                .build();
    }

}


/* ===== src/main/java/com/hau/notificationservice/controller/FcmTokenController.java ===== */
package com.hau.notificationservice.controller;

import com.hau.notificationservice.dto.ApiResponse;
import com.hau.notificationservice.dto.FcmTokenCreateRequest;
import com.hau.notificationservice.dto.FcmTokenResponse;
import com.hau.notificationservice.service.FcmTokenService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping("/fcm-token")
public class FcmTokenController {
    private final FcmTokenService fcmTokenService;

    @PostMapping
    public ResponseEntity<ApiResponse<FcmTokenResponse>> fcmTokenResponse(@RequestBody FcmTokenCreateRequest fcmTokenCreateRequest) {
        ApiResponse<FcmTokenResponse> fcmTokenResponse = fcmTokenService.fcmTokenResponseApiResponse(fcmTokenCreateRequest);
        return new ResponseEntity<>(fcmTokenResponse, HttpStatus.CREATED);
    }
}


/* ===== src/main/java/com/hau/notificationservice/controller/NotificationController.java ===== */
package com.hau.notificationservice.controller;

import com.hau.event.dto.NotificationEvent;
import com.hau.notificationservice.service.NotificationProcessingService;
import com.hau.notificationservice.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

@RequiredArgsConstructor
@Slf4j
@Component
public class NotificationController {

    private final NotificationService notificationService;
    private final NotificationProcessingService notificationProcessingService;

    @KafkaListener(topics = "forgot-password-topic")
    public void listenOtpTopic(NotificationEvent notificationEvent) {
        notificationService.handleNotification(notificationEvent);
    }

    @KafkaListener(topics = "order-create-notification-topic")
    public void listenOrderCreateTopic(NotificationEvent notificationEvent) {
        notificationService.handleNotification(notificationEvent);
        notificationProcessingService.processOrderCreateNotification(notificationEvent);
    }

    @KafkaListener(topics = "order-updated-status-topic")
    public void listenOrderUpdatedStatusTopic(NotificationEvent notificationEvent) {
        notificationProcessingService.processOrderUpdatedStatusNotification(notificationEvent);
    }
}

/* ===== src/main/java/com/hau/notificationservice/controller/NotificationFirebaseController.java ===== */
package com.hau.notificationservice.controller;

import com.hau.notificationservice.dto.*;
import com.hau.notificationservice.service.FCMService;
import com.hau.notificationservice.service.NotificationProcessingService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;

@RestController
@RequiredArgsConstructor
@Slf4j
public class NotificationFirebaseController {
    private final FCMService fcmService;
    private final NotificationProcessingService notificationProcessingService;

    @PostMapping("/firebase")
    public ResponseEntity sendNotification(@RequestBody NotificationRequest request) {
        if (request.getToken() != null && (request.getTokens() == null || request.getTokens().isEmpty())) {
            List<String> tokens = new ArrayList<>();
            tokens.add(request.getToken());
            request.setTokens(tokens);
        }

        fcmService.sendMessageToTokens(request);
        return new ResponseEntity<>(new NotificationResponse(HttpStatus.OK.value(), "Thông báo đã được gửi."), HttpStatus.OK);
    }

    @GetMapping("my-notification")
    public ResponseEntity<ApiResponse<PageResponse<NotificationResponseToUser>>> getMyNotifications(
            @RequestParam(required = false, defaultValue = "1") int pageIndex,
            @RequestParam(required = false, defaultValue = "10") int pageSize
    ) {
        ApiResponse<PageResponse<NotificationResponseToUser>> response = notificationProcessingService.notificationResponseToUser(pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);

    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteNotification(@PathVariable String id) {
        ApiResponse<String> response = notificationProcessingService.deleteNotification(id);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }
}

/* ===== src/main/java/com/hau/notificationservice/dto/ApiResponse.java ===== */
package com.hau.notificationservice.dto;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== src/main/java/com/hau/notificationservice/dto/EmailRequest.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EmailRequest {
    private Sender sender;
    private List<Recipient> to;
    private String subject;
    private String htmlContent;
}


/* ===== src/main/java/com/hau/notificationservice/dto/EmailResponse.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EmailResponse {
    private String messageId;
}


/* ===== src/main/java/com/hau/notificationservice/dto/ErrorsResponse.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== src/main/java/com/hau/notificationservice/dto/FcmTokenCreateRequest.java ===== */
package com.hau.notificationservice.dto;


import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class FcmTokenCreateRequest {
    @NotBlank(message = "Token cannot be blank")
    private String token;
}


/* ===== src/main/java/com/hau/notificationservice/dto/FcmTokenResponse.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class FcmTokenResponse {
    private String id;
    private String token;
    private Integer userId;
}


/* ===== src/main/java/com/hau/notificationservice/dto/NotificationRequest.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.Map;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class NotificationRequest {
    private Integer userId;
    private String title;
    private String body;
    private String topic;
    // Hỗ trợ cả token đơn lẻ và danh sách token
    private String token;
    private List<String> tokens;
    // Dữ liệu bổ sung
    private Map<String, String> data;
}

/* ===== src/main/java/com/hau/notificationservice/dto/NotificationResponse.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class NotificationResponse {
    private int status;
    private String message;
}


/* ===== src/main/java/com/hau/notificationservice/dto/NotificationResponseToUser.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.Map;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class NotificationResponseToUser {
    private Integer userId;
    private String title;
    private String body;
    private String topic;
    private Map<String, String> data;
}

/* ===== src/main/java/com/hau/notificationservice/dto/PageResponse.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}


/* ===== src/main/java/com/hau/notificationservice/dto/Recipient.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Recipient {
    private String name;
    private String email;
}


/* ===== src/main/java/com/hau/notificationservice/dto/SendEmailRequest.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SendEmailRequest {
    private Recipient to;
    private String subject;
    private String htmlContent;
}


/* ===== src/main/java/com/hau/notificationservice/dto/Sender.java ===== */
package com.hau.notificationservice.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Sender {
    private String name;
    private String email;
}


/* ===== src/main/java/com/hau/notificationservice/entity/FcmToken.java ===== */
package com.hau.notificationservice.entity;

import lombok.*;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.MongoId;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Document(collection = "fcm_token")
@CompoundIndex(name = "userId_token_unique_idx", def = "{'userId': 1, 'token': 1}", unique = true)
public class FcmToken {
    @MongoId
    private String id;

    private Integer userId;
    private String token;
}


/* ===== src/main/java/com/hau/notificationservice/entity/Notification.java ===== */
package com.hau.notificationservice.entity;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.MongoId;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Document(collection = "notification")
public class Notification {
    @MongoId
    private String id;

    private Integer userId;
    private String title;
    private String body;
    private String topic;
    private String token;
    private List<String> tokens;
    private Map<String, String> data;

    @CreatedDate
    private LocalDateTime createdAt;
}


/* ===== src/main/java/com/hau/notificationservice/exception/AppException.java ===== */
package com.hau.notificationservice.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== src/main/java/com/hau/notificationservice/exception/GlobalExceptionHandler.java ===== */
package com.hau.notificationservice.exception;

import com.hau.notificationservice.dto.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions(Exception ex) {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== src/main/java/com/hau/notificationservice/mapper/NotificationMapper.java ===== */
package com.hau.notificationservice.mapper;

import com.hau.notificationservice.dto.NotificationRequest;
import com.hau.notificationservice.dto.NotificationResponseToUser;
import com.hau.notificationservice.entity.Notification;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface NotificationMapper {
    Notification toNotification(NotificationRequest notificationRequest);

    NotificationResponseToUser toNotificationResponseToUser(Notification notification);
}


/* ===== src/main/java/com/hau/notificationservice/NotificationServiceApplication.java ===== */
package com.hau.notificationservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class NotificationServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(NotificationServiceApplication.class, args);
    }

}


/* ===== src/main/java/com/hau/notificationservice/repository/EmailClient.java ===== */
package com.hau.notificationservice.repository;

import com.hau.notificationservice.dto.EmailRequest;
import com.hau.notificationservice.dto.EmailResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;

@FeignClient(name = "email-client", url = "${app.email-service.url}")
public interface EmailClient {
    @PostMapping(value = "/v3/smtp/email", produces = MediaType.APPLICATION_JSON_VALUE)
    EmailResponse sendEmail(@RequestHeader("api-key") String apiKey,
                            @RequestBody EmailRequest emailRequest);
}


/* ===== src/main/java/com/hau/notificationservice/repository/FcmTokenRepository.java ===== */
package com.hau.notificationservice.repository;

import com.hau.notificationservice.entity.FcmToken;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface FcmTokenRepository extends MongoRepository<FcmToken, String> {
    List<FcmToken> findFcmTokenByUserId(Integer userId);
    Optional<FcmToken> findByUserIdAndToken(Integer userId, String token);
}


/* ===== src/main/java/com/hau/notificationservice/repository/NotificationRepository.java ===== */
package com.hau.notificationservice.repository;

import com.hau.notificationservice.entity.Notification;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface NotificationRepository extends MongoRepository<Notification, String> {
    Page<Notification> findNotificationByUserId(Integer userId, Pageable pageable);
    Optional<Notification> findByIdAndUserId(String id, Integer userId);
}


/* ===== src/main/java/com/hau/notificationservice/service/EmailService.java ===== */
package com.hau.notificationservice.service;

import com.hau.notificationservice.dto.EmailRequest;
import com.hau.notificationservice.dto.EmailResponse;
import com.hau.notificationservice.dto.SendEmailRequest;
import com.hau.notificationservice.dto.Sender;
import com.hau.notificationservice.exception.AppException;
import com.hau.notificationservice.repository.EmailClient;
import feign.FeignException;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class EmailService {
    private final EmailClient emailClient;

    @Value("${app.email-service.api-key}")
    private String apiKey;

    public EmailResponse sendEmail(SendEmailRequest sendEmailRequest) {
        EmailRequest emailRequest = EmailRequest.builder()
                .sender(Sender.builder()
                        .name("Hiệu sách Hà Nội")
                        .email("datdnk3@gmail.com")
                        .build())
                .to(List.of(sendEmailRequest.getTo()))
                .subject(sendEmailRequest.getSubject())
                .htmlContent(sendEmailRequest.getHtmlContent())
                .build();
        try {
            return emailClient.sendEmail(apiKey, emailRequest);
        } catch (FeignException e) {
            throw new AppException(HttpStatus.BAD_REQUEST,
                    "Gửi email thất bại",
                    e.getMessage());
        }
    }
}


/* ===== src/main/java/com/hau/notificationservice/service/FCMInitializer.java ===== */
package com.hau.notificationservice.service;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import java.io.IOException;

@Slf4j
@Service
public class FCMInitializer {
    @Value("${app.firebase-configuration-file}")
    private String firebaseConfigPath;

    @PostConstruct
    public void initialize() {
        try {
            FirebaseOptions options = new FirebaseOptions.Builder()
                    .setCredentials(GoogleCredentials.fromStream(new ClassPathResource(firebaseConfigPath).getInputStream())).build();
            if (FirebaseApp.getApps().isEmpty()) {
                FirebaseApp.initializeApp(options);
                log.info("Firebase application initialized");
            }
        } catch (IOException e) {
            log.error(e.getMessage());
        }
    }
}


/* ===== src/main/java/com/hau/notificationservice/service/FCMService.java ===== */
package com.hau.notificationservice.service;

import com.google.firebase.messaging.*;
import com.hau.notificationservice.dto.NotificationRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;

@Service
@Slf4j
public class FCMService {
    public void sendMessageToTokens(NotificationRequest request) {
        if (request.getTokens() == null || request.getTokens().isEmpty()) {
            log.error("No tokens provided for sending notifications");
            return;
        }

        List<String> successfulTokens = new ArrayList<>();
        List<String> failedTokens = new ArrayList<>();

        for (String token : request.getTokens()) {
            try {
                Message message = getPreconfiguredMessageToToken(request, token);
                String response = sendAndGetResponse(message);
                successfulTokens.add(token);
                log.info("Sent message to token: {}, response: {}", token, response);
            } catch (Exception e) {
                failedTokens.add(token);
                log.error("Failed to send message to token: {}, error: {}", token, e.getMessage());
            }
        }

        log.info("Notification sending summary: Success: {}, Failed: {}",
                successfulTokens.size(), failedTokens.size());

        if (!failedTokens.isEmpty()) {
            log.error("Failed tokens: {}", failedTokens);
        }
    }

    private String sendAndGetResponse(Message message) throws InterruptedException, ExecutionException {
        return FirebaseMessaging.getInstance().sendAsync(message).get();
    }

    private AndroidConfig getAndroidConfig(String topic) {
        return AndroidConfig.builder()
                .setTtl(Duration.ofMinutes(2).toMillis()).setCollapseKey(topic)
                .setPriority(AndroidConfig.Priority.HIGH)
                .setNotification(AndroidNotification.builder()
                        .setTag(topic).build()).build();
    }

    private ApnsConfig getApnsConfig(String topic) {
        return ApnsConfig.builder()
                .setAps(Aps.builder().setCategory(topic).setThreadId(topic).build()).build();
    }

    private Message getPreconfiguredMessageToToken(NotificationRequest request, String token) {
        return getPreconfiguredMessageBuilder(request)
                .setToken(token)
                .build();
    }

    private Message.Builder getPreconfiguredMessageBuilder(NotificationRequest request) {
        AndroidConfig androidConfig = getAndroidConfig(request.getTopic());
        ApnsConfig apnsConfig = getApnsConfig(request.getTopic());
        Notification notification = Notification.builder()
                .setTitle(request.getTitle())
                .setBody(request.getBody())
                .build();

        Message.Builder builder = Message.builder()
                .setApnsConfig(apnsConfig)
                .setAndroidConfig(androidConfig)
                .setNotification(notification);

        if (request.getData() != null && !request.getData().isEmpty()) {
            builder.putAllData(request.getData());
        }

        return builder;
    }
}

/* ===== src/main/java/com/hau/notificationservice/service/FcmTokenService.java ===== */
package com.hau.notificationservice.service;

import com.hau.notificationservice.dto.ApiResponse;
import com.hau.notificationservice.dto.FcmTokenCreateRequest;
import com.hau.notificationservice.dto.FcmTokenResponse;
import com.hau.notificationservice.entity.FcmToken;
import com.hau.notificationservice.exception.AppException;
import com.hau.notificationservice.repository.FcmTokenRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class FcmTokenService {
    private final FcmTokenRepository fcmTokenRepository;

    public ApiResponse<FcmTokenResponse> fcmTokenResponseApiResponse(FcmTokenCreateRequest fcmTokenCreateRequest) {
        Integer userId = Integer.valueOf(SecurityContextHolder.getContext().getAuthentication().getName());
        String token = fcmTokenCreateRequest.getToken(); // Lấy token từ request

        Optional<FcmToken> existingToken = fcmTokenRepository.findByUserIdAndToken(userId, token);

        if (existingToken.isEmpty()) {
            FcmToken newFcmToken = FcmToken.builder()
                    .token(token)
                    .userId(userId)
                    .build();

            newFcmToken = fcmTokenRepository.save(newFcmToken);

            return ApiResponse.<FcmTokenResponse>builder()
                    .status(201) // Created - Tài nguyên mới đã được tạo thành công
                    .message("FCM Token đã được thêm mới.")
                    .result(FcmTokenResponse.builder()
                            .id(newFcmToken.getId())
                            .token(newFcmToken.getToken())
                            .userId(newFcmToken.getUserId())
                            .build())
                    .timestamp(LocalDateTime.now())
                    .build();
        } else {
            throw new AppException(HttpStatus.BAD_REQUEST, "FCM Token đã tồn tại cho người dùng này.", null);
        }
    }
}


/* ===== src/main/java/com/hau/notificationservice/service/NotificationProcessingService.java ===== */
package com.hau.notificationservice.service;

import com.hau.event.dto.NotificationEvent;
import com.hau.notificationservice.dto.ApiResponse;
import com.hau.notificationservice.dto.NotificationRequest;
import com.hau.notificationservice.dto.NotificationResponseToUser;
import com.hau.notificationservice.dto.PageResponse;
import com.hau.notificationservice.entity.FcmToken;
import com.hau.notificationservice.entity.Notification;
import com.hau.notificationservice.exception.AppException;
import com.hau.notificationservice.mapper.NotificationMapper;
import com.hau.notificationservice.repository.FcmTokenRepository;
import com.hau.notificationservice.repository.NotificationRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class NotificationProcessingService {
    private final FcmTokenRepository fcmTokenRepository;
    private final FCMService fcmService;
    private final NotificationMapper notificationMapper;
    private final NotificationRepository notificationRepository;

    public void processOrderCreateNotification(NotificationEvent notificationEvent) {
        Integer userId = (Integer) notificationEvent.getParams().get("userId");

        List<FcmToken> fcmTokens = fcmTokenRepository.findFcmTokenByUserId(userId);

        List<String> tokensToSend = fcmTokens.stream()
                .map(FcmToken::getToken)
                .toList();
        Map<String, String> data = new HashMap<>();
        data.put("orderId", notificationEvent.getParams().get("orderId").toString());
        NotificationRequest notificationRequest = NotificationRequest.builder()
                .userId(userId)
                .topic("order created")
                .title("Chúc mừng bạn đã đặt hàng thành công")
                .body("Đơn hàng của bạn đã được đặt thành công với mã đơn hàng: " + notificationEvent.getParams().get("orderId"))
                .tokens(tokensToSend)
                .data(data)
                .build();
        Notification notification = notificationMapper.toNotification(notificationRequest);
        notificationRepository.save(notification);
        fcmService.sendMessageToTokens(notificationRequest);
    }

    public void processOrderUpdatedStatusNotification(NotificationEvent notificationEvent) {
        Integer userId = (Integer) notificationEvent.getParams().get("userId");
        Integer oderStatus = (Integer) notificationEvent.getParams().get("orderStatus");

        List<FcmToken> fcmTokens = fcmTokenRepository.findFcmTokenByUserId(userId);

        List<String> tokensToSend = fcmTokens.stream()
                .map(FcmToken::getToken)
                .toList();
        Map<String, String> data = new HashMap<>();
        data.put("orderId", notificationEvent.getParams().get("orderId").toString());

        String notificationBody = getNotificationBody(oderStatus);

        NotificationRequest notificationRequest = NotificationRequest.builder()
                .userId(userId)
                .topic("order updated")
                .title("Cập nhật trạng thái đơn hàng")
                .body(notificationBody)
                .tokens(tokensToSend)
                .data(data)
                .build();
        Notification notification = notificationMapper.toNotification(notificationRequest);
        notificationRepository.save(notification);
        fcmService.sendMessageToTokens(notificationRequest);
    }

    public ApiResponse<PageResponse<NotificationResponseToUser>> notificationResponseToUser(int pageIndex, int pageSize) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        Integer userId = Integer.valueOf(authentication.getName());

        Sort sort = Sort.by("createdAt").descending();
        Pageable pageable = PageRequest.of(pageIndex - 1, pageSize, sort);
        Page<Notification> notifications = notificationRepository.findNotificationByUserId(userId, pageable);

        List<NotificationResponseToUser> notificationResponses = notifications.stream()
                .map(notificationMapper::toNotificationResponseToUser)
                .toList();
        return ApiResponse.<PageResponse<NotificationResponseToUser>>builder()
                .status(200)
                .message("Lấy thông báo thành công")
                .result(
                        PageResponse.<NotificationResponseToUser>builder()
                                .data(notificationResponses)
                                .currentPage(pageIndex)
                                .pageSize(pageSize)
                                .totalElements(notifications.getTotalElements())
                                .totalPages(notifications.getTotalPages())
                                .build()
                )
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<String> deleteNotification(String notificationId) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        Integer userId = Integer.valueOf(authentication.getName());

        Notification notification = notificationRepository.findByIdAndUserId(notificationId, userId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Thông báo không tồn tại", null));

        notificationRepository.delete(notification);
        return ApiResponse.<String>builder()
                .status(200)
                .message("Xoá thông báo thành công")
                .timestamp(LocalDateTime.now())
                .build();
    }

    private static String getNotificationBody(Integer oderStatus) {
        String notificationBody;
        switch (oderStatus) {
            case 0 -> notificationBody = "Đơn hàng của bạn đã được giao thành công";
            case 1 -> notificationBody = "Đơn hàng của bạn đã được xác nhận";
            case 2 -> notificationBody = "Đơn hàng của bạn đang chờ đơn vị vận chuyển đến lấy hàng";
            case 3 -> notificationBody = "Đơn hàng của bạn đã được giao cho đơn vị vận chuyển";
            case 4 -> notificationBody = "Đơn hàng của bạn đã được hủy";
            default -> notificationBody = "Lỗi không xác định trạng thái đơn hàng";
        }
        return notificationBody;
    }
}


/* ===== src/main/java/com/hau/notificationservice/service/NotificationService.java ===== */
package com.hau.notificationservice.service;

import com.google.firebase.messaging.*;
import com.hau.event.dto.NotificationEvent;
import com.hau.notificationservice.dto.Recipient;
import com.hau.notificationservice.dto.SendEmailRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.thymeleaf.context.Context;
import org.thymeleaf.spring6.SpringTemplateEngine;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationService {

    private final EmailService emailService;
    private final SpringTemplateEngine templateEngine;


    public void handleNotification(NotificationEvent notificationEvent) {
        String templateCode = notificationEvent.getTemplateCode();
        String subject;
        String htmlContent = switch (templateCode) {
            case "otp-email-template" -> {
                subject = "Mã OTP Xác Thực - Đặt Lại Mật Khẩu";
                yield processOtpTemplate(notificationEvent);
            }
            case "order-created-email-template" -> {
                subject = "Xác Nhận Đơn Hàng";
                yield processOrderTemplate(notificationEvent);
            }
            default -> throw new IllegalArgumentException("Template code không hợp lệ: " + templateCode);
        };

        emailService.sendEmail(SendEmailRequest.builder()
                .to(Recipient.builder()
                        .email(notificationEvent.getRecipient())
                        .build())
                .subject(subject)
                .htmlContent(htmlContent)
                .build());
    }

    private String processOtpTemplate(NotificationEvent notificationEvent) {
        Context context = new Context();
        Map<String, Object> params = notificationEvent.getParams();
        context.setVariable("username", params.get("username"));
        context.setVariable("otp", params.get("otp"));
        context.setVariable("expiryMinutes", params.get("expiryMinutes"));

        return templateEngine.process("otp-email-template", context);
    }

    private String processOrderTemplate(NotificationEvent notificationEvent) {
        Context context = new Context();
        Map<String, Object> params = notificationEvent.getParams();

        context.setVariable("username", params.get("username"));
        context.setVariable("fullName", params.get("fullName"));
        context.setVariable("orderId", params.get("orderId"));
        context.setVariable("totalPrice", params.get("totalPrice"));
        context.setVariable("address", params.get("address"));
        context.setVariable("phone", params.get("phone"));
        context.setVariable("paymentMethod", params.get("paymentMethod"));
        context.setVariable("paymentStatus", params.get("paymentStatus"));
        context.setVariable("status", params.get("status"));
        context.setVariable("note", params.get("note"));
        context.setVariable("createdAt", params.get("createdAt"));
        context.setVariable("orderProducts", params.get("orderProducts"));


        return templateEngine.process("order-created-email-template", context);
    }
}

/* ===== src/main/resources/application-sample.yml ===== */
server:
  port: 8088
  servlet:
    context-path: /notification
spring:
  application:
    name: notification-service
  data:
    mongodb:
      uri: mongodb://root:root@localhost:27017/notification_db?authSource=admin
  kafka:
    bootstrap-servers: localhost:9094
    consumer:
      group-id: notification-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
app:
  email-service:
    url: https://api.brevo.com
    api-key:
  firebase-configuration-file:


/* ===== src/main/resources/application.yml ===== */
server:
  port: 8088
  servlet:
    context-path: /notification
spring:
  application:
    name: notification-service
  data:
    mongodb:
      uri: mongodb://root:123456789@localhost:27017/notification_db?authSource=admin
  kafka:
    bootstrap-servers: localhost:9094
    consumer:
      group-id: notification-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
app:
  email-service:
    url: https://api.brevo.com
    api-key:
  firebase-configuration-file:


/* ===== src/main/resources/templates/order-created-email-template.html ===== */
<!DOCTYPE html>
<html lang="vi" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xác Nhận Đơn Hàng</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.7;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            font-size: 16px;  /* Tăng kích thước chữ cơ bản */
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #ffffff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .header {
            background-color: #4285f4;
            padding: 22px;
            text-align: center;
            color: white;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;  /* Tăng kích thước tiêu đề */
        }

        .content {
            padding: 12px;
            font-size: 14px;  /* Tăng kích thước nội dung */
        }
        .order-id-container {
            text-align: center;
            margin-bottom: 25px;
        }
        .order-id {
            font-size: 16px;  /* Tăng kích thước */
            font-weight: bold;
            color: #4285f4;
            display: inline-block;
            padding: 12px 24px;
            border: 2px solid #d1e0ff;
            background-color: #f5f8ff;
            border-radius: 6px;
        }
        .order-summary {
            background-color: #f5f8ff;
            border: 1px solid #d1e0ff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            font-size: 14px;  /* Tăng kích thước */
        }
        .status-container {
            display: flex;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .status-label {
            min-width: 166px;
            font-weight: bold;
            margin-right: 10px;
            font-size: 14px;
        }
        .order-status, .payment-status {
            display: inline-block;
            padding: 7px 14px;
            border-radius: 4px;
            margin-right: 10px;
            font-size: 16px;
            font-weight: bold;
        }
        .order-status {
            background-color: #e8f0fe;
            color: #4285f4;
        }
        .payment-status {
            background-color: #e6f4ea;
            color: #34a853;
        }
        .payment-pending {
            background-color: #ffe8e8;
            color: #e53935;
        }
        .info-item {
            display: flex;
            margin-bottom: 12px;
        }
        .info-label {
            font-weight: bold;
            min-width: 95px;  /* Tăng chiều rộng để phù hợp với nhãn dài hơn */
            margin-right: 10px;
        }
        .info-value {
            flex: 1;
        }
        .section-divider {
            height: 1px;
            background-color: #d1e0ff;
            margin: 20px 0;
        }
        .order-details {
            margin: 30px 0;
            padding: 14px;
            background-color: #f5f5f5;
            border-left: 5px solid #4285f4;
            font-size: 16px;
        }
        .order-details h3 {
            font-size: 18px;
            margin-top: 0;
        }
        .product-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 13px;
        }
        .product-table th, .product-table td {
            padding: 6px 0;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        .product-table th {
            background-color: #f5f8ff;
            font-size: 12px;
        }
        .total-price {
            font-size: 18px;  /* Tăng kích thước */
            font-weight: bold;
            text-align: right;
            color: #e53935;  /* Đổi sang màu đỏ */
            margin-top: 20px;
        }
        .note {
            font-style: italic;
            margin-top: 18px;
            padding: 15px;
            background-color: #fffde7;
            border-left: 4px solid #ffd600;
            font-size: 14px;
        }
        .footer {
            background-color: #f5f5f5;
            padding: 25px;
            text-align: center;
            font-size: 16px;
            color: #666;
        }
        .social-icons {
            margin-top: 18px;
        }
        .social-icons a {
            display: inline-block;
            margin: 0 10px;
            color: #4285f4;
            text-decoration: none;
            font-size: 16px;
        }

        @media (max-width: 576px) {
            .container {
                width: 100%;
                border-radius: 0;
            }
            .content {
                padding: 20px 4px;
            }
            .product-table {
                font-size: 14px;
            }
            .info-item {
                flex-direction: column;
            }
            .info-label {
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Xác Nhận Đơn Hàng</h1>
    </div>

    <div class="content">
        <p>Xin chào <strong th:text="${username}">Nguyễn Văn A</strong>!</p>

        <p>Cảm ơn bạn đã đặt hàng tại cửa hàng của chúng tôi. Đơn hàng của bạn đã được tiếp nhận và đang được xử lý.</p>

        <div class="order-id-container">
            <div class="order-id">Mã đơn hàng: <span th:text="${orderId}">#ORD12345</span></div>
        </div>

        <div class="order-summary">
            <div class="status-container">
                <div class="status-label">Trạng thái đơn hàng:</div>
                <div class="info-value" th:text="${status}">Chờ xác nhận</div>
            </div>
            <div class="status-container">
                <div class="status-label">Trạng thái thanh toán:</div>
                <div class="info-value" th:text="${paymentStatus}">Chưa thanh toán</div>
            </div>
            <div class="status-container">
                <div class="status-label">Ngày đặt hàng:</div>
                <div class="info-value" th:text="${createdAt[2] + '/' + createdAt[1] + '/' + createdAt[0] + ' ' + createdAt[3] + ':' + createdAt[4]}">01/05/2025 10:30</div>
            </div>
            <div class="status-container">
                <div class="status-label">Phương thức thanh toán:</div>
                <div class="info-value" th:text="${paymentMethod}">Thanh toán khi nhận hàng</div>
            </div>

            <div class="section-divider"></div>

            <div class="info-item">
                <div class="info-label">Người nhận:</div>
                <div class="info-value" th:text="${fullName}">Nguyễn Văn A</div>
            </div>
            <div class="info-item">
                <div class="info-label">Địa chỉ:</div>
                <div class="info-value" th:text="${address}">123 Đường ABC, Phường XYZ, Quận 123, TP Hà Nội</div>
            </div>
            <div class="info-item">
                <div class="info-label">Số điện thoại:</div>
                <div class="info-value" th:text="${phone}">0912345678</div>
            </div>
        </div>

        <div class="order-details">
            <h3>Chi tiết đơn hàng:</h3>
            <table class="product-table">
                <thead>
                <tr>
                    <th>Sản phẩm</th>
                    <th>Số lượng</th>
                    <th>Đơn giá</th>
                    <th>Thành tiền</th>
                </tr>
                </thead>
                <tbody>
                <tr th:each="product : ${orderProducts}">
                    <td th:text="${product.productName}">Tên sản phẩm</td>
                    <td style="right: 0" th:text="${product.quantity}">1</td>
                    <td style="right: 0" th:text="${#numbers.formatDecimal(product.price, 0, 'COMMA', 0, 'POINT')}">100.000 VNĐ</td>
                    <td style="right: 0" th:text="${#numbers.formatDecimal(product.price * product.quantity, 0, 'COMMA', 0, 'POINT')}">100.000 VNĐ</td>
                </tr>
                </tbody>
            </table>
            <div class="total-price">Tổng tiền: <span th:text="${#numbers.formatDecimal(totalPrice, 0, 'COMMA', 0, 'POINT')} + ' VNĐ'">300.000 VNĐ</span></div>

            <div th:if="${note != ''}" class="note">
                <strong>Ghi chú:</strong> <span th:text="${note}">Gọi điện trước khi giao hàng.</span>
            </div>
        </div>

        <p>Nếu bạn có bất kỳ câu hỏi hoặc thắc mắc nào về đơn hàng, vui lòng liên hệ với đội ngũ hỗ trợ của chúng tôi qua email <a href="mailto:support@example.com">hausupport@gmail.com</a> hoặc hotline <strong>1900 1009</strong>.</p>
    </div>

    <div class="footer">
        <p>Trân trọng,<br /><strong>Đội Ngũ Chăm Sóc Khách Hàng</strong></p>
        <p>© 2025 Đại học Kiến trúc Hà Nội. Tất cả các quyền được bảo lưu.</p>
        <p>Địa chỉ: Km 10, Đường Nguyễn Trãi, Quận Thanh Xuân, TP Hà Nội.</p>

        <div class="social-icons">
            <a href="#" title="Facebook">Facebook</a> |
            <a href="#" title="Instagram">Instagram</a> |
            <a href="#" title="LinkedIn">LinkedIn</a>
        </div>
    </div>
</div>
</body>
</html>

/* ===== src/main/resources/templates/otp-email-template.html ===== */
<!DOCTYPE html>
<html lang="vi" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mã OTP Xác Thực - Đặt Lại Mật Khẩu</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background-color: #ffffff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .header {
            background-color: #4285f4;
            padding: 20px;
            text-align: center;
            color: white;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
        }

        .content {
            padding: 30px;
        }
        .otp-container {
            background-color: #f5f8ff;
            border: 1px solid #d1e0ff;
            border-radius: 6px;
            padding: 15px;
            margin: 25px 0;
            text-align: center;
        }
        .otp-code {
            font-size: 32px;
            font-weight: bold;
            color: #4285f4;
            letter-spacing: 4px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        .timer {
            background-color: #ffe8e8;
            border-radius: 4px;
            padding: 8px 15px;
            display: inline-block;
            margin-top: 15px;
            font-weight: bold;
            color: #e53935;
        }
        .instructions {
            margin: 25px 0;
            padding: 15px;
            background-color: #f5f5f5;
            border-left: 4px solid #4285f4;
        }
        .footer {
            background-color: #f5f5f5;
            padding: 20px;
            text-align: center;
            font-size: 14px;
            color: #666;
        }
        .social-icons {
            margin-top: 15px;
        }
        .social-icons a {
            display: inline-block;
            margin: 0 10px;
            color: #4285f4;
            text-decoration: none;
        }
        .warning {
            color: #e53935;
            font-weight: bold;
        }

        @media only screen and (max-width: 600px) {
            .container {
                width: 100%;
                border-radius: 0;
            }
            .content {
                padding: 20px 15px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Xác Thực Tài Khoản</h1>
    </div>

    <div class="content">
        <p>Xin chào <strong th:text="${username}">admin</strong>!</p>

        <p>Chúng tôi đã nhận được yêu cầu đặt lại mật khẩu cho tài khoản của bạn. Để tiếp tục quá trình này, vui lòng sử dụng mã OTP dưới đây:</p>

        <div class="otp-container">
            <p>Mã OTP của bạn là</p>
            <div class="otp-code" th:text="${otp}">123456</div>
            <div class="timer">
                Hết hạn sau <strong th:text="${expiryMinutes}">5</strong> phút
            </div>
        </div>

        <div class="instructions">
            <h3>Hướng dẫn:</h3>
            <ol>
                <li>Nhập mã OTP trên vào trang đặt lại mật khẩu.</li>
                <li>Tạo mật khẩu mới an toàn cho tài khoản của bạn.</li>
                <li>Đăng nhập bằng mật khẩu mới.</li>
            </ol>
        </div>

        <p class="warning">⚠️ Lưu ý quan trọng:</p>
        <ul>
            <li>Không chia sẻ mã OTP này với bất kỳ ai, kể cả nhân viên của chúng tôi.</li>
            <li>Mã OTP chỉ có hiệu lực trong vòng <strong th:text="${expiryMinutes}">5</strong> phút và chỉ sử dụng được 1 lần.</li>
            <li>Nếu bạn không yêu cầu đặt lại mật khẩu, vui lòng bỏ qua email này và kiểm tra tài khoản của bạn.</li>
        </ul>

        <p>Nếu bạn gặp khó khăn hoặc cần trợ giúp, hãy liên hệ với đội ngũ hỗ trợ của chúng tôi qua email <a href="mailto:support@example.com">hausupport@gmail.com</a> hoặc hotline <strong>1900 1009</strong>.</p>
    </div>

    <div class="footer">
        <p>Trân trọng,<br /><strong>Đội Ngũ Quản Trị Viên</strong></p>
        <p>© 2025 Đại học Kiến trúc Hà Nội. Tất cả các quyền được bảo lưu.</p>
        <p>Địa chỉ: Km 10, Đường Nguyễn Trãi, Quận Thanh Xuân , TP Hà Nội.</p>

        <div class="social-icons">
            <a href="#" title="Facebook">Facebook</a> |
            <a href="#" title="Instagram">Instagram</a> |
            <a href="#" title="LinkedIn">LinkedIn</a>
        </div>
    </div>
</div>
</body>
</html>

/* ===== src/test/java/com/hau/notificationservice/NotificationServiceApplicationTests.java ===== */
package com.hau.notificationservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class NotificationServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


///////////////////////////////////////////////

/* ===== NotificationContext.js ===== */
// src/contexts/NotificationContext.js
import React, {createContext, useCallback, useContext, useEffect, useState} from 'react';
import {notificationService} from '../services';
import {useAuth} from './AuthContext';

const NotificationContext = createContext(null);

export const NotificationProvider = ({children}) => {
    const [notifications, setNotifications] = useState([]);
    const [unreadCount, setUnreadCount] = useState(0);
    const [isLoading, setIsLoading] = useState(false);
    const [loadingMore, setLoadingMore] = useState(false);
    const [error, setError] = useState(null);
    const {isAuthenticated, user} = useAuth();

    const [pageIndex, setPageIndex] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const pageSize = 15;

    const fetchNotifications = useCallback(async (page = 1, isRefreshing = false) => {
        if (!isAuthenticated || !user) {
            setNotifications([]);
            setUnreadCount(0);
            setPageIndex(1);
            setTotalPages(1);
            setIsLoading(false);
            setLoadingMore(false);
            return;
        }
        if (loadingMore && !isRefreshing) return;

        if (page === 1) setIsLoading(true); else if (!isRefreshing) setLoadingMore(true);
        setError(null);

        try {
            const response = await notificationService.getMyNotifications(page, pageSize);

            console.log(response)

            if (response && response.status === 200 && response.result) {
                const newNotifications = response.result.data || [];
                if (isRefreshing || page === 1) {
                    setNotifications(newNotifications);
                } else {
                    setNotifications(prev => [...prev, ...newNotifications]);
                }
                setTotalPages(response.result.totalPages || 1);
                setPageIndex(page);
            } else {
                throw new Error(response?.message || "Không thể tải thông báo.");
            }
        } catch (err) {
            console.error('Fetch notifications error:', err);
            setError(err.message);
            if (page === 1) setNotifications([]);
        } finally {
            setIsLoading(false);
            setLoadingMore(false);
            // UI component (NotificationScreen) sẽ quản lý trạng thái refreshing của chính nó.
        }
    }, [isAuthenticated, user, pageSize, loadingMore]);

    useEffect(() => {
        if (isAuthenticated) {
            fetchNotifications(1, true); // Initial fetch or fetch on auth change
        } else {
            // Clear data if user logs out or is not authenticated
            setNotifications([]);
            setUnreadCount(0);
            setPageIndex(1);
            setTotalPages(1);
        }
    }, [isAuthenticated, fetchNotifications]); // fetchNotifications is stable due to useCallback

    useEffect(() => {
        if (isAuthenticated) {
            const currentUnread = notifications.filter(n => n.status !== 'READ' && n.status !== 'FAILED').length;
            setUnreadCount(currentUnread);
        }
    }, [notifications, isAuthenticated]);

    const markAsRead = async (notificationLogId) => {
        if (!isAuthenticated) return false;
        setError(null);
        try {
            const response = await notificationService.markNotificationAsRead(notificationLogId);
            if (response && response.status === 200) {
                setNotifications(prev => prev.map(n => n.notification_log_id === notificationLogId ? {
                    ...n,
                    status: 'READ'
                } : n));
                return true;
            } else {
                throw new Error(response?.message || "Không thể đánh dấu đã đọc.");
            }
        } catch (err) {
            console.error('Mark as read error:', err);
            setError(err.message);
            return false;
        }
    };

    const markAllAsRead = async () => {
        if (!isAuthenticated) return false;
        setError(null);
        try {
            const response = await notificationService.markAllNotificationsAsRead();
            if (response && response.status === 200) {
                setNotifications(prev => prev.map(n => ({...n, status: 'READ'})));
                return true;
            } else {
                throw new Error(response?.message || "Không thể đánh dấu tất cả đã đọc.");
            }
        } catch (err) {
            console.error('Mark all as read error:', err);
            setError(err.message);
            return false;
        }
    };

    const deleteNotificationById = async (notificationLogId) => {
        if (!isAuthenticated) return false;
        setError(null);
        try {
            const response = await notificationService.deleteNotification(notificationLogId);
            if (response && response.status === 200) {
                setNotifications(prev => prev.filter(n => n.notification_log_id !== notificationLogId));
                return true;
            } else {
                throw new Error(response?.message || "Không thể xóa thông báo.");
            }
        } catch (err) {
            console.error('Delete notification error:', err);
            setError(err.message);
            return false;
        }
    };

    const deleteAllNotifications = async () => {
        if (!isAuthenticated || notifications.length === 0) return false;
        setError(null);
        setIsLoading(true);
        try {
            const response = await notificationService.deleteAllNotifications();
            if (response && response.status === 200) {
                setNotifications([]);
                setUnreadCount(0);
                setPageIndex(1);
                setTotalPages(1);
                return true;
            } else {
                throw new Error(response?.message || "Không thể xóa tất cả thông báo.");
            }
        } catch (err) {
            console.error('Delete all notifications error:', err);
            setError(err.message || 'Lỗi xóa tất cả thông báo.');
            return false;
        } finally {
            setIsLoading(false);
        }
    };

    const registerDeviceToken = async (deviceToken, deviceType = 'MOBILE') => {
        if (!isAuthenticated || !user) return false;
        try {
            const response = await notificationService.registerFcmToken(deviceToken);
            if (response && response.status === 201) {
                console.log('FCM token registered successfully:', response.result);
                return true;
            }
            console.warn('FCM token registration did not return expected success:', response);
            return false;
        } catch (err) {
            console.error('Register FCM token error:', err);
            return false;
        }
    };

    const value = {
        notifications,
        unreadCount,
        isLoading,
        loadingMore,
        error,
        pageIndex,
        totalPages,
        fetchNotifications,
        markAsRead,
        markAllAsRead,
        deleteNotificationById,
        deleteAllNotifications,
        registerDeviceToken,
    };

    return (<NotificationContext.Provider value={value}>
        {children}
    </NotificationContext.Provider>);
};

export const useNotification = () => {
    const context = useContext(NotificationContext);
    if (!context) {
        throw new Error('useNotification must be used within a NotificationProvider');
    }
    return context;
};

export default NotificationContext;

/* ===== NotificationScreen.jsx ===== */
// src/screens/notification/NotificationScreen.jsx
import {useNotification} from '@/contexts/NotificationContext';
import {Ionicons, MaterialCommunityIcons} from '@expo/vector-icons';
import React, {useCallback, useState} from 'react'; // Removed useEffect as initial fetch is in context
import {
    ActivityIndicator, Alert, FlatList, RefreshControl, SafeAreaView, Text, TouchableOpacity, View
} from 'react-native';

const timeAgo = (isoString) => {
    if (!isoString) return 'N/A';
    const date = new Date(isoString);
    const seconds = Math.floor((new Date() - date) / 1000);
    let interval = seconds / 31536000;
    if (interval > 1) return Math.floor(interval) + " năm trước";
    interval = seconds / 2592000;
    if (interval > 1) return Math.floor(interval) + " tháng trước";
    interval = seconds / 86400;
    if (interval > 1) return Math.floor(interval) + " ngày trước";
    interval = seconds / 3600;
    if (interval > 1) return Math.floor(interval) + " giờ trước";
    interval = seconds / 60;
    if (interval > 1) return Math.floor(interval) + " phút trước";
    return Math.floor(seconds) + " giây trước";
};

const NotificationIcon = ({channel, templateCode}) => {
    let iconName = "bell-outline";
    let iconColor = "#6B7280";

    if (channel === 'EMAIL') {
        iconName = "email-outline";
        iconColor = "#0284c7";
    } else if (channel === 'PUSH_NOTIFICATION') {
        iconName = "bell-ring-outline";
        iconColor = "#fb923c";
    } else if (channel === 'SMS') {
        iconName = "message-text-outline";
        iconColor = "#3b82f6";
    }

    if (templateCode) {
        if (templateCode.includes("order")) {
            iconName = "cart-check";
            iconColor = "#16a34a";
        } else if (templateCode.includes("otp")) {
            iconName = "key-variant";
            iconColor = "#f59e0b";
        }
    }
    return <MaterialCommunityIcons name={iconName} size={28} color={iconColor}/>;
};


function NotificationScreen() {
    const {
        notifications,
        isLoading,
        loadingMore,
        error,
        pageIndex,
        totalPages,
        fetchNotifications,
        markAsRead,
        markAllAsRead,
        deleteNotificationById,
        deleteAllNotifications, // Use this from context
    } = useNotification();

    const [isRefreshing, setIsRefreshing] = useState(false); // Local state for RefreshControl

    const handleNotificationPress = useCallback(async (item) => {
        if (item.status !== 'READ') {
            const success = await markAsRead(item.notification_log_id);
            if (!success) {
                Alert.alert("Lỗi", "Không thể đánh dấu đã đọc. Vui lòng thử lại.");
            }
        }
        Alert.alert("Thông báo", `Đã mở thông báo: ${item.title}`);
    }, [markAsRead]);

    const handleMarkAllAsRead = async () => {
        if (notifications.some(n => n.status !== 'READ' && n.status !== 'FAILED')) {
            const success = await markAllAsRead();
            if (!success) {
                Alert.alert("Lỗi", "Không thể đánh dấu tất cả đã đọc. Vui lòng thử lại.");
            }
        }
    };

    const handleClearAllNotifications = () => {
        Alert.alert("Xác nhận", "Bạn có chắc chắn muốn xóa tất cả thông báo không?", [{text: "Hủy", style: "cancel"}, {
            text: "Xóa", onPress: async () => {
                const success = await deleteAllNotifications(); // Call from context
                if (!success && !isLoading) { // Check !isLoading to avoid double alert if error is already set by context
                    Alert.alert("Lỗi", "Không thể xóa tất cả thông báo. Vui lòng thử lại.");
                }
            }, style: "destructive"
        }]);
    };

    const handleDeleteOneNotification = useCallback(async (notificationLogId) => {
        Alert.alert("Xác nhận xóa", "Bạn có chắc chắn muốn xóa thông báo này?", [{text: "Hủy", style: "cancel"}, {
            text: "Xóa", style: "destructive", onPress: async () => {
                const success = await deleteNotificationById(notificationLogId);
                if (!success) {
                    Alert.alert("Lỗi", "Không thể xóa thông báo. Vui lòng thử lại.");
                }
            },
        },]);
    }, [deleteNotificationById]);

    const onRefresh = useCallback(async () => {
        setIsRefreshing(true);
        await fetchNotifications(1, true); // page = 1, isRefreshing = true
        setIsRefreshing(false);
    }, [fetchNotifications]);

    const loadMore = () => {
        if (!loadingMore && !isLoading && pageIndex < totalPages) {
            fetchNotifications(pageIndex + 1);
        }
    };

    const NotificationItem = (({item}) => (<TouchableOpacity
        onPress={() => handleNotificationPress(item)}
        className={`p-4 border-b border-gray-200 flex-row items-start ${item.status !== 'READ' && item.status !== 'FAILED' ? 'bg-sky-50' : 'bg-white'}`}
    >
        <View className="mr-4 mt-1">
            <NotificationIcon channel={item.channel} templateCode={item.template_code}/>
            {item.status !== 'READ' && item.status !== 'FAILED' && (
                <View className="absolute top-0 right-0 w-2.5 h-2.5 bg-red-500 rounded-full border border-white"/>)}
        </View>
        <View className="flex-1">
            <Text
                className={`text-base font-semibold ${item.status !== 'READ' && item.status !== 'FAILED' ? 'text-gray-900' : 'text-gray-700'}`}>{item.title}</Text>
            <Text className="text-sm text-gray-600 mt-0.5" numberOfLines={2}>{item.body}</Text>
            <Text className="text-xs text-gray-400 mt-1.5">{timeAgo(item.sent_at || item.createdAt)}</Text>
        </View>
        <TouchableOpacity onPress={() => handleDeleteOneNotification(item.notification_log_id)}
                          className="p-1 ml-2 self-center">
            <Ionicons name="trash-bin-outline" size={20} color="#EF4444"/>
        </TouchableOpacity>
    </TouchableOpacity>));

    // Show main loading indicator only on initial load when notifications array is empty
    if (isLoading && notifications.length === 0 && !isRefreshing) {
        return (<SafeAreaView className="flex-1 justify-center items-center bg-slate-100">
            <ActivityIndicator size="large" color="#0EA5E9"/>
        </SafeAreaView>);
    }

    if (error && notifications.length === 0) {
        return (<SafeAreaView className="flex-1 justify-center items-center bg-slate-100 p-5">
            <MaterialCommunityIcons name="alert-circle-outline" size={70} color="#EF4444"/>
            <Text className="text-xl font-semibold text-red-500 mt-4">Lỗi tải thông báo</Text>
            <Text className="text-gray-500 mt-1 text-center mb-6">{error}</Text>
            <TouchableOpacity
                onPress={onRefresh}
                className="bg-sky-500 px-6 py-3 rounded-lg shadow-md active:bg-sky-600"
            >
                <Text className="text-white font-semibold text-base">Thử lại</Text>
            </TouchableOpacity>
        </SafeAreaView>);
    }

    return (<SafeAreaView className="flex-1 bg-gray-100">
        <View className="px-4 py-3 flex-row justify-end items-center border-b border-gray-200 bg-white">
            {notifications.some(n => n.status !== 'READ' && n.status !== 'FAILED') && (
                <TouchableOpacity onPress={handleMarkAllAsRead} className="mr-4">
                    <Text className="text-sky-600 font-medium">Đánh dấu tất cả đã đọc</Text>
                </TouchableOpacity>)}
            {notifications.length > 0 && (<TouchableOpacity onPress={handleClearAllNotifications}>
                <Text className="text-red-500 font-medium">Xóa tất cả</Text>
            </TouchableOpacity>)}
        </View>

        {notifications.length === 0 && !isLoading && !isRefreshing ? (
            <View className="flex-1 justify-center items-center p-5">
                <Ionicons name="notifications-off-outline" size={80} color="#CBD5E1"/>
                <Text className="text-xl font-semibold text-gray-500 mt-4">Không có thông báo</Text>
                <Text className="text-gray-400 mt-1 text-center">
                    Tất cả các thông báo của bạn sẽ xuất hiện ở đây.
                </Text>
            </View>) : (<FlatList
            data={notifications}
            renderItem={({item}) => <NotificationItem item={item}/>}
            keyExtractor={item => item.notification_log_id?.toString() || item.id?.toString() || Math.random().toString()} // Robust key
            contentContainerStyle={{paddingBottom: 20}}
            onEndReached={loadMore}
            onEndReachedThreshold={0.5}
            ListFooterComponent={loadingMore ?
                <ActivityIndicator style={{marginVertical: 20}} size="small" color="#0EA5E9"/> : null}
            refreshControl={<RefreshControl refreshing={isRefreshing} onRefresh={onRefresh} colors={["#0EA5E9"]}
                                            tintColor={"#0EA5E9"}/>}
        />)}
    </SafeAreaView>);
}

export default NotificationScreen;

/* ===== notificationService.js ===== */
// src/services/notificationService.js
import api from './api';

const notificationService = {
    // POST /notification/fcm-token
    // Corresponds to FcmTokenController.fcmTokenResponse
    // Request: FcmTokenCreateRequest { token }
    // Response: ApiResponse<FcmTokenResponse>
    registerFcmToken: async (token) => {
        try {
            const response = await api.post('/notification/fcm-token', {token});
            return response; // Expects ApiResponse<FcmTokenResponse>
        } catch (error) {
            console.error('Register FCM token failed:', error.message || error);
            throw error;
        }
    },

    // GET /notification/my-notifications (Assumption, based on NotificationContext.js)
    // Backend equivalent might be NotificationFirebaseController.getMyNotifications
    // Request Params: pageIndex, pageSize
    // Response: ApiResponse<PageResponse<NotificationResponseToUser>>
    getMyNotifications: async (pageIndex = 1, pageSize = 10) => {
        try {
            const response = await api.get('/notification/my-notification', { // Corrected path based on typical REST and context
                params: {pageIndex, pageSize}
            });
            return response; // Expects ApiResponse<PageResponse<NotificationLog-like structure>>
        } catch (error) {
            console.error('Get my notifications failed:', error.message || error);
            // Return a default structure or throw, as NotificationContext handles it
            // For consistency with NotificationContext's error handling:
            throw error;
        }
    },

    // PATCH /notification/{notificationLogId}/read (Assumption, based on NotificationContext.js)
    // Backend equivalent not directly specified, but a common pattern.
    // Let's assume the backend has a similar endpoint or it's handled via a general update.
    // For now, this matches NotificationContext's expectation.
    // Response: ApiResponse<NotificationLog-like structure> or success message
    markNotificationAsRead: async (notificationLogId) => {
        try {
            // Assuming backend supports PATCH /notification/{id}/read or similar
            const response = await api.patch(`/notification/${notificationLogId}/read`);
            return response;
        } catch (error) {
            console.error(`Mark notification ${notificationLogId} as read failed:`, error.message || error);
            throw error;
        }
    },

    // POST /notification/mark-all-read (Assumption, based on NotificationContext.js)
    // Backend equivalent not directly specified.
    // Response: ApiResponse<String> or success message
    markAllNotificationsAsRead: async () => {
        try {
            const response = await api.post(`/notification/mark-all-read`);
            return response;
        } catch (error) {
            console.error(`Mark all notifications as read failed:`, error.message || error);
            throw error;
        }
    },

    // DELETE /notification/{notificationLogId} (Assumption, based on NotificationContext.js)
    // Backend equivalent not directly specified.
    // Response: ApiResponse<String> or success/void
    deleteNotification: async (notificationLogId) => {
        try {
            const response = await api.delete(`/notification/${notificationLogId}`);
            return response;
        } catch (error) {
            console.error(`Delete notification ${notificationLogId} failed:`, error.message || error);
            throw error;
        }
    },

    // DELETE /notification/all (Assumption, for "Clear All" functionality)
    // Backend equivalent not directly specified.
    // Response: ApiResponse<String> or success/void
    deleteAllNotifications: async () => {
        try {
            const response = await api.delete(`/notification/all`); // Assuming an endpoint like this
            return response;
        } catch (error) {
            console.error(`Delete all notifications failed:`, error.message || error);
            throw error;
        }
    }
};

export default notificationService;

